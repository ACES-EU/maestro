(* Generated by Frama-C WP *)

Goal typed_erase_has_post_2.
Hint erase,has,property.
Proof.
unfold P_has_K, P_has_K, P_no_doubles.
intros.
unfold "~" at 1.
intro CONTRA.
destruct H14.
destruct H14.
destruct H19.
destruct H20.
assert (x = i). {
 case (Z.eq_dec x i);[auto|intro XY].
 contradict H20.
 apply H4;auto.
}
destruct CONTRA as [y CONTRA].
destruct CONTRA.
destruct H24.
destruct H25.
case (Z.eq_dec x y);intro XY.
- subst y.
  subst i.
  rewrite access_update in H26.
  auto.
- subst i.
  rewrite access_update_neq in H25;
     [|assert (shift_sint32 a y <> shift_sint32 a_1 x)
         by (apply H18;auto);auto].
  contradict H25;auto.
  apply H4;auto.
  rewrite access_update_neq in H26;[auto|intro SHIFT_EQ].
  injection SHIFT_EQ.
  contradict XY.
  SearchAbout (_ + _ = _ + _ -> _ = _).
  apply Z.add_reg_l in XY;exact XY.
Qed.

Goal typed_find_empty_loop_inv_for_non_full_2_established.
Hint established,find_empty,non_full.
Proof.
Require Import Psatz.
unfold P_full.
intros.
rename H3 into NONFULL.
apply Classical_Pred_Type.not_all_ex_not in NONFULL.
destruct NONFULL as [x NONFULL].
apply Classical_Prop.imply_to_and in NONFULL.
destruct NONFULL as [XL0 NONFULL].
apply Classical_Prop.imply_to_and in NONFULL.
destruct NONFULL as [XLIM NOTBUSY].
apply Z.eq_dne in NOTBUSY.
rename i into y.
case (Z_lt_le_dec y x);intro IXI.
- exists x.
  split;[auto|split];[auto with zarith|].
  rewrite <- (Q_loop_bijection x);auto.
- exists (x + 1000000).
  split;[lia|split];[lia|].
  rewrite Int.Comm.
  rewrite <- (Q_loop_injection x);[|auto].
  rewrite <- (Q_loop_bijection x);auto.
Qed.

Goal typed_find_key_loop_inv_for_has_2_established.
Hint established,find_key,has.
Proof.
Require Import Psatz.
intros.
rename H6 into HAS.
unfold P_has_K in HAS.
destruct HAS as [x HAS].
destruct HAS.
destruct H11.
rename i into i'.
rename i_1 into i.
case (Z_lt_le_dec i x);intro IXI.
- exists x.
  split;[auto|split];[auto with zarith|].
  rewrite <- (Q_loop_bijection x);auto.
- exists (x + 1000000).
  split;[lia|split];[lia|].
  rewrite Int.Comm.
  rewrite <- (Q_loop_injection x);[|auto].
  rewrite <- (Q_loop_bijection x);auto.
Qed.

Goal typed_find_key_loop_inv_for_has_2_preserved.
Hint find_key,has,preserved.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_lemma_loop_injection.
Hint loop_injection,property.
Proof.
Require Import Psatz.
intros i IG0.
unfold L_loop_l.
assert (forall x, x > 0 -> Cmod (x + i) x = Cmod i x). {
 intros x XG0.
 destruct (Cmod_cases i x) as [CM1p CM1rest].
 destruct CM1rest as [CM1n CM1rest].
 destruct (Cmod_cases (x + i) x) as [CM2p CM2rest].
 destruct CM2rest as [CM2n CM2rest].
 pose (Z_mod_plus_full i 1 x) as MOD.
 rewrite Z.mul_1_l in MOD.
 rewrite Z.add_comm in MOD.
 induction i.
  - rewrite CM1p;[|lia|lia].
    rewrite CM2p;[|lia|lia].
    auto.
  - rewrite CM1p;[|lia|lia].
    rewrite CM2p;[|lia|lia].
    auto.
  - contradict IG0;auto.
 }
rewrite H;[auto|lia].
Qed.

Goal typed_put_assert_3.
Hint property,put.
Proof.
(* auto with zarith. *)
Qed.


