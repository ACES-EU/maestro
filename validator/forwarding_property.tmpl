//Capture the final state.
assert map_vec_chain_coherent<flow_id>(?final_flow_map, ?final_flow_vec, ?final_flow_chain);
emap<flow_id> flow_emap = emap(flow_map, flow_vec, flow_chain);
emap<flow_id> final_flow_emap = emap(final_flow_map, final_flow_vec, final_flow_chain);

#define EXP_TIME (10)
#define EXT_IP_ADDR external_addr
#define EXT_PORT 1

#define DEFAULT_DROP(hd1, hd2, hd3) \
     case hd1(x): assert nil == sent_on_ports; \
     case hd2(x): assert nil == sent_on_ports; \
     case hd3(x): assert nil == sent_on_ports
#define NIL_DROP case nil: assert nil == sent_on_ports;

bit_and_hack();
if (EXP_TIME < now) {// consider only normal moments, remote from the start of the epoch

  if (a_packet_received) {

    flow_emap = emap_expire_all(flow_emap, now - EXP_TIME);

    switch(recv_headers) { case cons(h1,t1): switch(h1) { case tcpudp_hdr(hdr1):
      switch(hdr1) { case tcpudp_hdrc(isrc_port, idst_port):
        switch(t1) { case cons(h2,t2): switch(h2) { case ip_hdr(hdr2):
          switch(hdr2) { case ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                        ittl, inpid, icksum, isaddr, idaddr):
            switch(t2) { case cons(h3,t3): switch(h3) { case ether_hdr(hdr3):
              switch(hdr3) { case ether_hdrc(iesaddr, iedaddr, ietype):

    //0x10 - IPv4
    if ((ietype & 0x10) == 0x10) {
      // 6/17 -> TCP/UDP
      if (inpid == 6 || inpid == 17) {
        if (received_on_port == EXT_PORT) {
          // packet from the external network
          int flow_indx = idst_port - start_port;
          if (emap_has_idx(flow_emap, flow_indx)) { 
            // flow is present in the table
            flow_id internal_flow = emap_get_key(flow_emap, flow_indx);
            flow_emap = emap_refresh_idx(flow_emap, flow_indx, now);
            switch(internal_flow) { case flid(sp, dp, sip, dip, idev, prot):
              if (dip  != isaddr ||
                  dp   != isrc_port  ||
                  prot != inpid) {
                assert nil == sent_on_ports;
              } else {
                assert cons(idev, nil) == sent_on_ports;
                assert sent_headers ==
                       cons(ether_hdr(ether_hdrc(_, _, ietype)),
                       cons(ip_hdr(ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                             ittl, inpid, _, dip, sip)),
                       cons(tcpudp_hdr(tcpudp_hdrc(dp, sp)), nil)));
              }
            }
          } else {
            // no flow in the table
            assert nil == sent_on_ports;
          }
        } else {
          // packet from the internal network
          flow_id internal_flow_id = flid(isrc_port, idst_port,
                                          isaddr, idaddr,
                                          received_on_port,
                                          inpid);
          if (emap_has(flow_emap, internal_flow_id)) {
            // flow present in the table
            int idx = emap_get(flow_emap, internal_flow_id);
            flow_emap = emap_refresh_idx(flow_emap, idx, now);
            assert cons(EXT_PORT, nil) == sent_on_ports;
            assert sent_headers ==
                   cons(ether_hdr(ether_hdrc(_, _, ietype)),
                   cons(ip_hdr(ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                         ittl, inpid, _, EXT_IP_ADDR, idaddr)),
                   cons(tcpudp_hdr(tcpudp_hdrc(idx + start_port, idst_port)), nil)));
          } else {
            // No flow in the table
            if (emap_full(flow_emap)) {
              // Flowtable overflow
              assert nil == sent_on_ports;
            } else {
              // The flow must have been inserted
              int idx = the_index_allocated;
              flow_emap = emap_add(flow_emap, internal_flow_id, idx, now);

              assert cons(EXT_PORT, nil) == sent_on_ports;
              assert sent_headers ==
                     cons(ether_hdr(ether_hdrc(_, _, ietype)),
                     cons(ip_hdr(ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                           ittl, inpid, _, EXT_IP_ADDR, idaddr)),
                     cons(tcpudp_hdr(tcpudp_hdrc(idx + start_port, idst_port)), nil)));
            }
          }
        }
      } else {
        // Non TCP or UDP packet
        assert nil == sent_on_ports;
      }
    } else {
      // Non IPv4 packet
      assert nil == sent_on_ports;
    }

              }
              DEFAULT_DROP(tcp_hdr, ip_hdr, tcpudp_hdr); } NIL_DROP; }
          }
          DEFAULT_DROP(tcp_hdr, ether_hdr, tcpudp_hdr); } NIL_DROP; }
      }
      DEFAULT_DROP(tcp_hdr, ip_hdr, ether_hdr); } NIL_DROP; }
  }
assert final_flow_emap == flow_emap;
}

