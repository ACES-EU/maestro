assert mapp<ether_addri>(_, ether_addrp, eth_addr_hash, nop_true, mapc(_, ?final_dyn_map, _));
assert mapp<stat_keyi>(_, static_keyp, st_key_hash, nop_true, mapc(_, ?final_stat_map, _));
assert vectorp<ether_addri>(_, ether_addrp, ?final_dyn_key_vec, _);
assert vectorp<stat_keyi>(_, static_keyp, ?final_stat_key_vec, _);
assert vectorp<uint16_t>(_, dyn_valp, ?final_dyn_val_vec, _);
assert double_chainp(?final_chain,_);

#define PACKETS_EQUAL(pkta, pktb)                                 \
    pkta.ether.ether_type     == pktb.ether.ether_type &&      \
    pkta.ether.s_addr.addr_bytes[0]     == pktb.ether.s_addr.addr_bytes[0] &&      \
    pkta.ether.s_addr.addr_bytes[1]     == pktb.ether.s_addr.addr_bytes[1] &&      \
    pkta.ether.s_addr.addr_bytes[2]     == pktb.ether.s_addr.addr_bytes[2] &&      \
    pkta.ether.s_addr.addr_bytes[3]     == pktb.ether.s_addr.addr_bytes[3] &&      \
    pkta.ether.s_addr.addr_bytes[4]     == pktb.ether.s_addr.addr_bytes[4] &&      \
    pkta.ether.s_addr.addr_bytes[5]     == pktb.ether.s_addr.addr_bytes[5] &&      \
    pkta.ether.d_addr.addr_bytes[0]     == pktb.ether.d_addr.addr_bytes[0] &&      \
    pkta.ether.d_addr.addr_bytes[1]     == pktb.ether.d_addr.addr_bytes[1] &&      \
    pkta.ether.d_addr.addr_bytes[2]     == pktb.ether.d_addr.addr_bytes[2] &&      \
    pkta.ether.d_addr.addr_bytes[3]     == pktb.ether.d_addr.addr_bytes[3] &&      \
    pkta.ether.d_addr.addr_bytes[4]     == pktb.ether.d_addr.addr_bytes[4] &&      \
    pkta.ether.d_addr.addr_bytes[5]     == pktb.ether.d_addr.addr_bytes[5] &&      \
    pkta.ipv4.version_ihl     == pktb.ipv4.version_ihl &&      \
    pkta.ipv4.type_of_service == pktb.ipv4.type_of_service &&  \
    pkta.ipv4.total_length    == pktb.ipv4.total_length &&     \
    pkta.ipv4.packet_id       == pktb.ipv4.packet_id &&        \
    pkta.ipv4.fragment_offset == pktb.ipv4.fragment_offset &&  \
    pkta.ipv4.time_to_live    == pktb.ipv4.time_to_live &&     \
    pkta.ipv4.next_proto_id   == pktb.ipv4.next_proto_id &&    \
    pkta.ipv4.src_addr   == pktb.ipv4.src_addr &&    \
    pkta.ipv4.dst_addr   == pktb.ipv4.dst_addr &&    \
    (pktb.ipv4.next_proto_id != 6 ||                             \
     (pkta.tcp.sent_seq         == pktb.tcp.sent_seq &&        \
      pkta.tcp.recv_ack         == pktb.tcp.recv_ack &&      \
      pkta.tcp.data_off         == pktb.tcp.data_off &&      \
      pkta.tcp.tcp_flags        == pktb.tcp.tcp_flags &&     \
      pkta.tcp.rx_win           == pktb.tcp.rx_win &&        \
      pkta.tcp.tcp_urp          == pktb.tcp.tcp_urp))

list<pair<ether_addri, int> > dyn_map = initial_dyn_map;
list<pair<ether_addri, real> > dyn_key_vec = initial_dyn_key_vec;
dchain dyn_chain = initial_chain;
list<pair<uint16_t, real> > dyn_val_vec = initial_dyn_val_vec;

list<pair<stat_keyi, int> > stat_map = initial_stat_map;
list<pair<stat_keyi, real> > stat_vec = initial_stat_key_vec;
dchain stat_chain;//dummy

bit_and_hack();
if (300 < now) {// consider only normal moments, remote from the start of the epoch

  if (a_packet_received) {

    assert ether_addrp(&(the_received_packet.ether.d_addr), ?dst_addr);
    assert ether_addrp(&(the_received_packet.ether.s_addr), ?src_addr);
    stat_keyi static_key = stkc(received_on_port, dst_addr);

    dyn_map = emap_expire_all_map(dyn_map, dyn_key_vec, dyn_chain, now - 10);
    dyn_key_vec = emap_expire_all_vec(dyn_map, dyn_key_vec, dyn_chain, now - 10);
    dyn_chain = emap_expire_all_chain(dyn_map, dyn_key_vec, dyn_chain, now - 10);

   // State postcondition
   if (emap_has(dyn_map, dyn_key_vec, dyn_chain, src_addr)) {
     dyn_chain = emap_rejuvenate_chain(dyn_map, dyn_key_vec, dyn_chain, src_addr, now);
   } else {
      if (!emap_full(dyn_map, dyn_key_vec, dyn_chain)) {
        int idx = the_index_allocated;//emap_get_next_int(flow_map, flow_vec, flow_chain);
        dyn_chain = emap_allocate_int(dyn_map, dyn_key_vec, dyn_chain, now, idx);
        dyn_map = emap_add_map(dyn_map, dyn_key_vec, dyn_chain, src_addr, idx);
        dyn_key_vec = emap_add_vec(dyn_map, dyn_key_vec, dyn_chain, src_addr, idx);
        dyn_val_vec = update(idx, pair(received_on_port, 1.0), dyn_val_vec);
      }
    }

    // Output packet postcondition
    if (emap_has(stat_map, stat_vec, stat_chain, static_key)) {
      int output_port = emap_get(stat_map, stat_vec, stat_chain, static_key);
      if (output_port == -2 ||
          output_port == received_on_port) {
        assert false == a_packet_sent;
        assert false == a_packet_flooded;
      } else {
        assert true == a_packet_sent;
        assert false == a_packet_flooded;
        assert sent_on_port == output_port;
        assert PACKETS_EQUAL(the_received_packet, sent_packet);
      }
    } else {
      if (emap_has(dyn_map, dyn_key_vec, dyn_chain, dst_addr)) {
        int idx = emap_get(dyn_map, dyn_key_vec, dyn_chain, dst_addr);
        int output_port = fst(nth(idx, dyn_val_vec));
        if (output_port == received_on_port) {
          assert false == a_packet_sent;
          assert false == a_packet_flooded;
        } else {
          assert true == a_packet_sent;
          assert false == a_packet_flooded;
          assert sent_on_port == output_port;
          assert PACKETS_EQUAL(the_received_packet, sent_packet);
        }
      } else {
        assert true == a_packet_flooded;
        assert flooded_except_port == received_on_port;
        assert PACKETS_EQUAL(the_received_packet, sent_packet);
      }
    }
  }

assert final_dyn_map == dyn_map;
assert final_dyn_key_vec == dyn_key_vec;
assert final_chain == dyn_chain;
assert final_dyn_val_vec == dyn_val_vec;
assert final_stat_map == stat_map;
assert final_stat_key_vec == stat_vec;
}
