
#define EXP_TIME 10
#define BACKEND_EXP_TIME 60

//Capture the final state.
assert map_vec_chain_coherent<lb_flowi>(?final_flow_map, ?final_flow_vec, ?final_flow_chain);
assert map_vec_chain_coherent<uint32_t>(?final_backend_ip_map, ?final_ip_veca, ?final_active_backends);
assert vectorp<uint32_t>(fidbid_veca_ptr, u_integer, ?final_fidbid_veca, _);
assert vectorp<uint32_t>(cht_ptr, u_integer, ?final_cht, _);
assert vectorp<lb_backendi>(backends_veca_ptr, lb_backendp, ?final_backends_veca, _);

#define DEFAULT_DROP(hd1, hd2, hd3) \
     case hd1(x): assert false == a_packet_sent; \
     case hd2(x): assert false == a_packet_sent; \
     case hd3(x): assert false == a_packet_sent
#define NIL_DROP case nil: assert false == a_packet_sent;

emap<lb_flowi> flow_emap = emap(flow_map, flow_vec, flow_chain);
emap<uint32_t> backend_ip_emap = emap(backend_ip_map, ip_veca, active_backends);
vector<uint32_t> fidbid_vec = vector(fidbid_veca);
vector<lb_backendi> backends_vec = vector(backends_veca);

emap<lb_flowi> final_flow_emap = emap(final_flow_map, final_flow_vec, final_flow_chain);
emap<uint32_t> final_backend_ip_emap = emap(final_backend_ip_map, final_ip_veca, final_active_backends);
vector<uint32_t> final_fidbid_vec = vector(final_fidbid_veca);
vector<lb_backendi> final_backends_vec = vector(final_backends_veca);

// Consider only normal moments, remote from the start of the epoch
if (EXP_TIME < now && BACKEND_EXP_TIME < now) {

  if (a_packet_received) {

    flow_emap = emap_expire_all(flow_emap, now - EXP_TIME);
    backend_ip_emap = emap_expire_all(backend_ip_emap, now - BACKEND_EXP_TIME);

    if (is_ipv4) {

    switch(recv_headers) { case cons(h1,t1): switch(h1) { case tcpudp_hdr(hdr1):
      switch(hdr1) { case tcpudp_hdrc(isrc_port, idst_port):
        switch(t1) { case cons(h2,t2): switch(h2) { case ip_hdr(hdr2):
          switch(hdr2) { case ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                        ittl, inpid, icksum, isaddr, idaddr):
            switch(t2) { case cons(h3,t3): switch(h3) { case ether_hdr(hdr3):
              switch(hdr3) { case ether_hdrc(iesaddr, iedaddr, ietype):

      // 6/17 -> TCP/UDP
      if (inpid == 6 || inpid == 17) {

        // 0 -> Packet received from the external network
        if (received_on_port == 0) {

          lb_flowi packet_flow = lb_flowc(isaddr, idaddr, isrc_port, idst_port, inpid);

          bool alloc_flow_and_process_packet = false;
          if (emap_has(flow_emap, packet_flow)) {
            int flow_id = emap_get(flow_emap, packet_flow);
            int backend_id = vector_get(fidbid_vec, flow_id);
            if (emap_has_idx(backend_ip_emap, backend_id)) {
              flow_emap = emap_refresh_idx(flow_emap, emap_get(flow_emap, packet_flow), now);
              lb_backendi backend = vector_get(backends_vec, backend_id);
              switch(backend) { case lb_backendc(nic, mac, ip):
                assert sent_on_port == nic;
                assert sent_headers ==
                       cons(ether_hdr(ether_hdrc(_, mac, ietype)),
                       cons(ip_hdr(ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                   ittl, inpid, _, isaddr, ip)),
                       cons(tcpudp_hdr(tcpudp_hdrc(isrc_port, idst_port)), nil)));
              }
            } else {
              flow_emap = emap_erase(flow_emap, packet_flow);
              alloc_flow_and_process_packet = true;
            }
          } else {
            alloc_flow_and_process_packet = true;
          }
          //flow_map, fwd_flow, out_dev = pp_with_flow_alloc(paket_flow, flow_map, backend_ip_map, now);
          if (alloc_flow_and_process_packet) {
            if (emap_exists_with_cht(backend_ip_emap, cht, lb_flow_hash_2(packet_flow))) {
              int bknd = emap_choose_with_cht(backend_ip_emap, cht, lb_flow_hash_2(packet_flow));
              if (emap_full(flow_emap)) {
                // do not change the state
              } else {
                int idx = the_index_allocated;
                flow_emap = emap_add(flow_emap, packet_flow, idx, now);
                fidbid_vec = vector_set(fidbid_vec, idx, bknd);
              }
              lb_backendi backend = vector_get(backends_vec, bknd);
              assert true == a_packet_sent;
              switch(backend) { case lb_backendc(nic, mac, ip):
                assert sent_on_port == nic;
                assert sent_headers ==
                       cons(ether_hdr(ether_hdrc(_, mac, ietype)),
                       cons(ip_hdr(ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                   ittl, inpid, _, isaddr, ip)),
                       cons(tcpudp_hdr(tcpudp_hdrc(isrc_port, idst_port)), nil)));
              }
            } else {
              assert false == a_packet_sent;
            }
          }
        } else { // A heartbeat packet from a backend
          {
            if (emap_has(backend_ip_emap, isaddr)) {
              backend_ip_emap = emap_refresh_idx(backend_ip_emap,
                                                 emap_get(backend_ip_emap, isaddr),
                                                 now);
            } else {
              if (emap_full(backend_ip_emap)) {
                // What you gonna do? (nothing, the question is rhetorical)
              } else {
                int idx = the_index_allocated;
                backend_ip_emap = emap_add(backend_ip_emap, isaddr, idx, now);
                backends_vec = vector_set(backends_vec, idx,
                                          lb_backendc(received_on_port, iesaddr, isaddr));
              }
            }
          }
          assert false == a_packet_sent;
        }
      } else {
        // Non-TCP/UDP packet
        assert false == a_packet_sent;
      }
              }
              DEFAULT_DROP(tcp_hdr, ip_hdr, tcpudp_hdr); } NIL_DROP; }
          }
          DEFAULT_DROP(tcp_hdr, ether_hdr, tcpudp_hdr); } NIL_DROP; }
      }
      DEFAULT_DROP(tcp_hdr, ip_hdr, ether_hdr); } NIL_DROP; }
    } else {
      // Non-IPv4 packet
      assert false == a_packet_sent;
    }

  }//a packet received

assert final_flow_emap == flow_emap;
assert final_fidbid_vec == fidbid_vec;
assert final_backends_vec == backends_vec;
assert final_backend_ip_emap == backend_ip_emap;
assert final_cht == cht;//redundant, should be immutable.
}