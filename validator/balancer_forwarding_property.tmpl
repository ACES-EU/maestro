
#define EXP_TIME 10
#define BACKEND_EXP_TIME 60

//Capture the final state.
assert map_vec_chain_coherent<lb_flowi>(?final_flow_map, ?final_flow_vec, ?final_flow_chain);
assert map_vec_chain_coherent<uint32_t>(?final_backend_ip_map, ?final_ip_veca, ?final_active_backends);
assert vectorp<uint32_t>(fidbid_veca_ptr, u_integer, ?final_fidbid_veca, _);
assert vectorp<uint32_t>(cht_ptr, u_integer, ?final_cht, _);
assert vectorp<lb_backendi>(backends_veca_ptr, lb_backendp, ?final_backends_veca, _);

//TODO: refine the predicate
#define UNRELEVANT_FIELDS_UNCHANGED(before,after)               \
    after.ether.ether_type     == before.ether.ether_type &&      \
    after.ipv4.version_ihl     == before.ipv4.version_ihl &&      \
    after.ipv4.type_of_service == before.ipv4.type_of_service &&  \
    after.ipv4.total_length    == before.ipv4.total_length &&     \
    after.ipv4.packet_id       == before.ipv4.packet_id &&        \
    after.ipv4.fragment_offset == before.ipv4.fragment_offset &&  \
    after.ipv4.time_to_live    == before.ipv4.time_to_live &&     \
    after.ipv4.next_proto_id   == before.ipv4.next_proto_id &&    \
    (before.ipv4.next_proto_id != 6 ||                             \
     (after.tcp.sent_seq         == before.tcp.sent_seq &&        \
      after.tcp.recv_ack         == before.tcp.recv_ack &&      \
      after.tcp.data_off         == before.tcp.data_off &&      \
      after.tcp.tcp_flags        == before.tcp.tcp_flags &&     \
      after.tcp.rx_win           == before.tcp.rx_win &&        \
      after.tcp.tcp_urp          == before.tcp.tcp_urp))

emap<lb_flowi> flow_emap = emap(flow_map, flow_vec, flow_chain);
emap<uint32_t> backend_ip_emap = emap(backend_ip_map, ip_veca, active_backends);
vector<uint32_t> fidbid_vec = vector(fidbid_veca);
vector<lb_backendi> backends_vec = vector(backends_veca);

emap<lb_flowi> final_flow_emap = emap(final_flow_map, final_flow_vec, final_flow_chain);
emap<uint32_t> final_backend_ip_emap = emap(final_backend_ip_map, final_ip_veca, final_active_backends);
vector<uint32_t> final_fidbid_vec = vector(final_fidbid_veca);
vector<lb_backendi> final_backends_vec = vector(final_backends_veca);

// Consider only normal moments, remote from the start of the epoch
if (EXP_TIME < now && BACKEND_EXP_TIME < now) {

  if (a_packet_received) {

    flow_emap = emap_expire_all(flow_emap, now - EXP_TIME);
    backend_ip_emap = emap_expire_all(backend_ip_emap, now - BACKEND_EXP_TIME);

    // 0x10 -> IPv4
    if ((received_packet_type & 0x10) == 0x10) {

      // 6/17 -> TCP/UDP
      if (pkt_recv.ipv4.next_proto_id == 6 ||
          pkt_recv.ipv4.next_proto_id == 17) {

        // 0 -> Packet received from the external network
        if (received_on_port == 0) {

          lb_flowi packet_flow = lb_flowc(pkt_recv.ipv4.src_addr,
                                          pkt_recv.ipv4.dst_addr,
                                          pkt_recv.tcp.src_port,
                                          pkt_recv.tcp.dst_port,
                                          pkt_recv.ipv4.next_proto_id);

          bool alloc_flow_and_process_packet = false;
          if (emap_has(flow_emap, packet_flow)) {
            int flow_id = emap_get(flow_emap, packet_flow);
            int backend_id = vector_get(fidbid_veca, flow_id);
            if (emap_has_idx(backend_ip_emap, backend_id)) {
              flow_emap = emap_refresh_idx(flow_emap, emap_get(flow_emap, packet_flow), now);
              lb_backendi backend = vector_get(backends_vec, backend_id);
              switch(backend) { case lb_backendc(nic, mac, ip):
                assert sent_on_port == nic;
                assert ether_addrp(&pkt_sent.ether.d_addr, mac);
                assert pkt_sent.ipv4.dst_addr == ip;
              }
              assert UNRELEVANT_FIELDS_UNCHANGED(pkt_recv,pkt_sent);
            } else {
              flow_emap = emap_erase(flow_emap, packet_flow);
              alloc_flow_and_process_packet = true;
            }
          } else {
            alloc_flow_and_process_packet = true;
          }
          //flow_map, fwd_flow, out_dev = pp_with_flow_alloc(paket_flow, flow_map, backend_ip_map, now);
          if (alloc_flow_and_process_packet) {
            if (emap_exists_with_cht(backend_ip_emap, cht, lb_flow_hash_2(packet_flow))) {
              int bknd = emap_choose_with_cht(backend_ip_emap, cht, lb_flow_hash_2(packet_flow));
              if (emap_full(flow_emap)) {
                // do not change the state
              } else {
                int idx = the_index_allocated;
                flow_emap = emap_add(flow_emap, packet_flow, idx, now);
                fidbid_vec = vector_set(fidbid_vec, idx, bknd);
              }
              lb_backendi backend = vector_get(backends_vec, bknd);
              assert true == a_packet_sent;
              switch(backend) { case lb_backendc(nic, mac, ip):
                assert sent_on_port == nic;
                assert ether_addrp(&pkt_sent.ether.d_addr, mac);
                assert pkt_sent.ipv4.dst_addr == ip;
              }
              assert UNRELEVANT_FIELDS_UNCHANGED(pkt_recv,pkt_sent);
            } else {
              assert false == a_packet_sent;
            }
          }
        } else { // A heartbeat packet from a backend
          {
            if (emap_has(backend_ip_emap, pkt_recv.ipv4.src_addr)) {
              backend_ip_emap = emap_refresh_idx(backend_ip_emap,
                                                 emap_get(backend_ip_emap,
                                                          pkt_recv.ipv4.src_addr),
                                                 now);
            } else {
              if (emap_full(backend_ip_emap)) {
                // What you gonna do? (nothing, the question is rhetorical)
              } else {
                int idx = the_index_allocated;
                backend_ip_emap = emap_add(backend_ip_emap, pkt_recv.ipv4.src_addr, idx, now);
                assert ether_addrp(&pkt_recv.ether.s_addr, ?source_mac);
                backends_vec = vector_set(backends_vec, idx,
                                          lb_backendc(received_on_port, source_mac, pkt_recv.ipv4.src_addr));
              }
            }
          }
          assert false == a_packet_sent;
        }
      } else {
        // Non-TCP/UDP packet
        assert false == a_packet_sent;
      }
    } else {
      // Non-IPv4 packet
      assert false == a_packet_sent;
    }

  }//a packet received

assert final_flow_emap == flow_emap;
assert final_fidbid_vec == fidbid_vec;
assert final_backends_vec == backends_vec;
assert final_backend_ip_emap == backend_ip_emap;
assert final_cht == cht;//redundant, should be immutable.
}