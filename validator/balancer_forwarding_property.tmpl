
#define EXP_TIME 10
#define BACKEND_EXP_TIME 60

//Capture the final state.
assert map_vec_chain_coherent<LoadBalancedFlowi>(?final_flow_map, ?final_flow_vec, ?final_flow_chain);
assert map_vec_chain_coherent<ip_addri>(?final_backend_ip_map, ?final_ip_veca, ?final_active_backends);
assert vectorp<uint32_t>(flow_id_to_backend_id_ptr, u_integer, ?final_fidbid_veca, _);
assert vectorp<uint32_t>(cht_ptr, u_integer, ?final_cht, _);
assert vectorp<LoadBalancedBackendi>(backends_ptr, LoadBalancedBackendp, ?final_backends_veca, _);

#define DEFAULT_DROP(hd1, hd2, hd3) \
     case hd1(x): assert nil == sent_on_ports; \
     case hd2(x): assert nil == sent_on_ports; \
     case hd3(x): assert nil == sent_on_ports
#define NIL_DROP case nil: assert nil == sent_on_ports

emap<LoadBalancedFlowi> flow_emap = emap(initial_flow_to_flow_id, initial_flow_heap, initial_flow_chain);
emap<ip_addri> backend_ip_emap = emap(initial_ip_to_backend_id, initial_backend_ips, initial_active_backends);
vector<uint32_t> fidbid_vec = vector(initial_flow_id_to_backend_id);
vector<LoadBalancedBackendi> backends_vec = vector(initial_backends);

emap<LoadBalancedFlowi> final_flow_emap = emap(final_flow_map, final_flow_vec, final_flow_chain);
emap<ip_addri> final_backend_ip_emap = emap(final_backend_ip_map, final_ip_veca, final_active_backends);
vector<uint32_t> final_fidbid_vec = vector(final_fidbid_veca);
vector<LoadBalancedBackendi> final_backends_vec = vector(final_backends_veca);
list<pair<uint32_t, real> > cht = initial_cht;

// Consider only normal moments, remote from the start of the epoch
if (EXP_TIME < now && BACKEND_EXP_TIME < now) {

  if (a_packet_received) {

    flow_emap = emap_expire_all(flow_emap, now - EXP_TIME);
    backend_ip_emap = emap_expire_all(backend_ip_emap, now - BACKEND_EXP_TIME);

    switch(recv_headers) { case cons(h1,t1): switch(h1) { case tcpudp_hdr(hdr1):
      switch(hdr1) { case tcpudp_hdrc(isrc_port, idst_port):
        switch(t1) { case cons(h2,t2): switch(h2) { case ip_hdr(hdr2):
          switch(hdr2) { case ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                        ittl, inpid, icksum, isaddr, idaddr):
            switch(t2) { case cons(h3,t3): switch(h3) { case ether_hdr(hdr3):
              switch(hdr3) { case ether_hdrc(iesaddr, iedaddr, ietype):

    //0x10 - IPv4
    if ((ietype & 0x10) == 0x10) {
      // 6/17 -> TCP/UDP
      if (inpid == 6 || inpid == 17) {

        // 0 -> Packet received from the external network
        if (received_on_port == 0) {

          LoadBalancedFlowi packet_flow = LoadBalancedFlowc(isaddr, idaddr, isrc_port, idst_port, inpid);

          bool alloc_flow_and_process_packet = false;
          if (emap_has(flow_emap, packet_flow)) {
            int flow_id = emap_get(flow_emap, packet_flow);
            int backend_id = vector_get(fidbid_vec, flow_id);
            if (emap_has_idx(backend_ip_emap, backend_id)) {
              flow_emap = emap_refresh_idx(flow_emap, emap_get(flow_emap, packet_flow), now);
              LoadBalancedBackendi backend = vector_get(backends_vec, backend_id);
              switch(backend) { case LoadBalancedBackendc(nic, mac, ip):
                assert sent_on_ports == cons(nic, nil);
                assert sent_headers ==
                       cons(ether_hdr(ether_hdrc(_, mac, ietype)),
                       cons(ip_hdr(ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                   ittl, inpid, _, isaddr, ip)),
                       cons(tcpudp_hdr(tcpudp_hdrc(isrc_port, idst_port)), nil)));
              }
            } else {
              flow_emap = emap_erase(flow_emap, packet_flow);
              alloc_flow_and_process_packet = true;
            }
          } else {
            alloc_flow_and_process_packet = true;
          }
          //flow_map, fwd_flow, out_dev = pp_with_flow_alloc(paket_flow, flow_map, backend_ip_map, now);
          if (alloc_flow_and_process_packet) {
            if (emap_exists_with_cht(backend_ip_emap, cht, _LoadBalancedFlow_hash(packet_flow))) {
              int bknd = emap_choose_with_cht(backend_ip_emap, cht, _LoadBalancedFlow_hash(packet_flow));
              if (emap_full(flow_emap)) {
                // do not change the state
              } else {
                int idx = the_index_allocated;
                flow_emap = emap_add(flow_emap, packet_flow, idx, now);
                fidbid_vec = vector_set(fidbid_vec, idx, bknd);
              }
              LoadBalancedBackendi backend = vector_get(backends_vec, bknd);
              switch(backend) { case LoadBalancedBackendc(nic, mac, ip):
                assert sent_on_ports == cons(nic, nil);
                assert sent_headers ==
                       cons(ether_hdr(ether_hdrc(_, mac, ietype)),
                       cons(ip_hdr(ipv4_hdrc(ivihl, itos, ilen, ipid, ifoff,
                                   ittl, inpid, _, isaddr, ip)),
                       cons(tcpudp_hdr(tcpudp_hdrc(isrc_port, idst_port)), nil)));
              }
            } else {
              assert nil == sent_on_ports;
            }
          }
        } else { // A heartbeat packet from a backend
          {
            if (emap_has(backend_ip_emap, ip_addrc(isaddr))) {
              backend_ip_emap = emap_refresh_idx(backend_ip_emap,
                                                 emap_get(backend_ip_emap, ip_addrc(isaddr)),
                                                 now);
            } else {
              if (emap_full(backend_ip_emap)) {
                // What you gonna do? (nothing, the question is rhetorical)
              } else {
                int idx = the_index_allocated;
                backend_ip_emap = emap_add(backend_ip_emap, ip_addrc(isaddr), idx, now);
                backends_vec = vector_set(backends_vec, idx,
                                          LoadBalancedBackendc(received_on_port, iesaddr, isaddr));
              }
            }
          }
          assert nil == sent_on_ports;
        }
      } else {
        // Non-TCP/UDP packet
        assert nil == sent_on_ports;
      }
    } else {
      // Non-IPv4 packet
      assert nil == sent_on_ports;
    }
              }
              DEFAULT_DROP(tcp_hdr, ip_hdr, tcpudp_hdr); } NIL_DROP; }
          }
          DEFAULT_DROP(tcp_hdr, ether_hdr, tcpudp_hdr); } NIL_DROP; }
      }
      DEFAULT_DROP(tcp_hdr, ip_hdr, ether_hdr); } NIL_DROP; }
  }//a packet received

assert final_flow_emap == flow_emap;
assert final_fidbid_vec == fidbid_vec;
assert final_backends_vec == backends_vec;
assert final_backend_ip_emap == backend_ip_emap;
assert final_cht == cht;//redundant, should be immutable.
}