#include <stdint.h>
#include "rte_config.h"
#include "lib/expirator.h"
#include "lib/nf_time.h"
#include "lib/stubs/my-time-stub-control.h"
#include "lib/containers/double-map.h"
#include "lib/containers/double-chain.h"
#include "lib/stubs/containers/double-map-stub-control.h"
#include "vignat/loop.h"

//@ #include "lib/abstract-state.h"

// DPDK driver stub - copy/pasted here because VeriFast's C parser is awful so #ifdefs are painful
//                    (it seems it even parses stuff inside an #ifdef that it won't use...)
struct stub_mbuf_content {
	struct ether_hdr ether;
	struct ipv4_hdr ipv4;
	struct tcp_hdr tcp;
};
struct stub_queue {
	struct rte_mempool* mb_pool;
	uint16_t port_id;
};
struct stub_device {
	struct stub_queue rx_queues[RTE_MAX_QUEUES_PER_PORT];
	struct stub_queue tx_queues[RTE_MAX_QUEUES_PER_PORT];
};
// DPDK stuff - but since this is used by VeriFast, we can't include rte_ things (VeriFast's preprocessor is lacking)
// TODO check if can just struct rte_mempool;
struct rte_ring {
	char name[32];
	int flags;
	uint32_t watermark;
	uint32_t sp_enqueue;
	uint32_t size1;
	uint32_t mask1;
	volatile uint32_t head1;
	volatile uint32_t tail1;
	uint32_t sc_dequeue;
	uint32_t size2;
	uint32_t mask2;
	volatile uint32_t head2;
	volatile uint32_t tail2;
	void** ring;
};
struct rte_mempool {
	char name[32];
	struct rte_ring* ring;
	uint64_t phys_addr;
	int flags;
	uint32_t size;
	uint32_t cache_size;
	uint32_t cache_flushthresh;
	uint32_t elt_size;
	uint32_t header_size;
	uint32_t trailer_size;
	unsigned private_data_size;
	uint32_t    pg_num;
	uint32_t    pg_shift;
	uintptr_t   pg_mask;
	uintptr_t   elt_va_start;
	uintptr_t   elt_va_end;
	uint64_t elt_pa[1];
};
struct rte_mbuf {
	struct stub_mbuf_content* buf_addr; // <- WARNING this has changed from void* to struct stub_mbuf_content* !!!
	uint64_t buf_physaddr;
	uint16_t buf_len;
	uint16_t data_off;
	uint16_t refcnt;
	uint8_t nb_segs;
	uint8_t port;
	uint64_t ol_flags;
	uint32_t packet_type;
	uint32_t pkt_len;
	uint16_t data_len;
	uint16_t vlan_tci;
	uint32_t hash;
	uint32_t seqn;
	uint16_t vlan_tci_outer;
	uint64_t udata64;
	struct rte_mempool* pool;
	struct rte_mbuf *next;
	uint64_t tx_offload;
	uint16_t priv_size;
	uint16_t timesync;
	void* offload_ops;
};
struct ether_addr {
        uint8_t a;
        uint8_t b;
        uint8_t c;
        uint8_t d;
        uint8_t e;
        uint8_t f;
};
struct ether_hdr {
	struct ether_addr d_addr;
	struct ether_addr s_addr;
	uint16_t ether_type;
};
struct ipv4_hdr {
	uint8_t  version_ihl;
	uint8_t  type_of_service;
	uint16_t total_length;
	uint16_t packet_id;
	uint16_t fragment_offset;
	uint8_t  time_to_live;
	uint8_t  next_proto_id;
	uint16_t hdr_checksum;
	uint32_t src_addr;
	uint32_t dst_addr;
};
struct tcp_hdr {
	uint16_t src_port;
	uint16_t dst_port;
	uint32_t sent_seq;
	uint32_t recv_ack;
	uint8_t  data_off;
	uint8_t  tcp_flags;
	uint16_t rx_win;
	uint16_t cksum;
	uint16_t tcp_urp;
};

int flow_consistency(void* key_a, void* key_b, int index, void* value)
/*@ requires true; @*/
/*@ ensures true; @*/
{
   return 0;
}

/*@
    inductive ether_addri = eaddrc(int, int, int, int, int, int);
    inductive ether_hdri = ether_hdrc(ether_addri, ether_addri, int);

    predicate ether_addrp(struct ether_addr* ptr; ether_addri addr) =
      struct_ether_addr_padding(ptr) &*&
      ptr->a |-> ?a &*&
      ptr->b |-> ?b &*&
      ptr->c |-> ?c &*&
      ptr->d |-> ?d &*&
      ptr->e |-> ?e &*&
      ptr->f |-> ?f &*&
      addr == eaddrc(a, b, c, d, e, f);

    predicate ether_hdrp(struct ether_hdr *ether; ether_hdri hdr) =
        ether_addrp(&ether->d_addr, ?daddr) &*&
        ether_addrp(&ether->s_addr, ?saddr) &*&
        ether->ether_type |-> ?et &*&
        hdr == ether_hdrc(saddr, daddr, et);

    inductive ipv4_hdri =
      ipv4_hdrc(int, int, int, int, int, int, int, int, int);

    predicate ipv4_hdrp(struct ipv4_hdr* hdr; ipv4_hdri val) =
      hdr->version_ihl |-> ?vihl &*&
      hdr->type_of_service |-> ?tos &*&
      hdr->total_length |-> ?len &*&
      hdr->packet_id |-> ?pid &*&
      hdr->fragment_offset |-> ?foff &*&
      hdr->time_to_live |-> ?ttl &*&
      hdr->next_proto_id |-> ?npid &*&
      // no checksum
      hdr->src_addr |-> ?saddr &*&
      hdr->dst_addr |-> ?daddr &*&
      val == ipv4_hdrc(vihl, tos, len, pid, foff, ttl, npid, saddr, daddr) &*&
      len == 10240;
      //FIXME: ^^ generalize for all values

    inductive tcp_hdri =
      tcp_hdrc(int, int, int, int, int, int, int, int);

    predicate tcp_hdrp(struct tcp_hdr* hdr; tcp_hdri val) =
      hdr->src_port |-> ?srcp &*&
      hdr->dst_port |-> ?dstp &*&
      hdr->sent_seq |-> ?seq &*&
      hdr->recv_ack |-> ?ack &*&
      hdr->data_off |-> ?doff &*&
      hdr->tcp_flags |-> ?flags &*&
      hdr->rx_win |-> ?win &*&
      // no checksum
      hdr->tcp_urp |-> ?urp &*&
      val == tcp_hdrc(srcp, dstp, seq, ack, doff, flags, win, urp);

    inductive user_bufi = user_bufc(ether_hdri, ipv4_hdri, tcp_hdri);

    predicate user_bufferp(struct stub_mbuf_content *buf; user_bufi ub) =
      ether_hdrp(&buf->ether, ?hdr) &*&
      ipv4_hdrp(&buf->ipv4, ?ipv4) &*&
      tcp_hdrp(&buf->tcp, ?tcp) &*&
      ub == user_bufc(hdr, ipv4, tcp);

    inductive rte_mbufi = rte_mbufc(user_bufi, int, int, int);

    predicate mbufp(struct rte_mbuf *mbuf; rte_mbufi val) =
      mbuf->buf_addr |-> ?ba &*&
      mbuf->buf_physaddr |-> ?bfa &*&
      mbuf->buf_len |-> ?bl &*&
      mbuf->data_off |-> ?doff &*&
      mbuf->refcnt |-> ?rcnt &*&
      mbuf->nb_segs |-> ?nbsegs &*&
      mbuf->port |-> ?port &*&
      mbuf->ol_flags |-> ?olflags &*&
      mbuf->packet_type |-> ?ptype &*&
      mbuf->pkt_len |-> ?pktlen &*&
      mbuf->data_len |-> ?dlen &*&
      mbuf->vlan_tci |-> ?vlantci &*&
      mbuf->hash |-> ?hash &*&
      mbuf->seqn |-> ?seqn &*&
      mbuf->vlan_tci_outer |-> ?vtcio &*&
      mbuf->udata64 |-> ?udata64 &*&
      mbuf->pool |-> ?pool &*&
      mbuf->next |-> ?next &*&
      mbuf->tx_offload |-> ?txoff &*&
      mbuf->priv_size |-> ?psize &*&
      mbuf->timesync |-> ?ts &*&
      user_bufferp(ba, ?ub) &*&
      val == rte_mbufc(ub, port, ptype, doff) &*&
      doff == 0;
      //TODO: ^^^ is it really always so?

   // This is pretty and useful, but annoying since mbufp doesn't auto-open in that case
   // TODO use this!
   predicate packets(struct rte_mbuf** bufs, uint16_t start, uint16_t end; list<rte_mbufi> vals) =
     start == end ? vals == nil : (pointer(bufs + start, ?buf) &*& mbufp(buf, ?head) &*& packets(bufs, start + 1, end, ?tail) &*& vals == cons(head, tail));
@*/

// TODO a lot of assumptions about only sending 1 packet here :(

uint16_t stub_rx(void* q, struct rte_mbuf** bufs, uint16_t nb_bufs);
//@ requires nb_bufs == 1 &*& *bufs |-> _;
//@ ensures result <= nb_bufs &*& *bufs |-> ?mb &*& (result == 0 ? true : mbufp(mb, _));

// HACK we pretend that free is called after tx when in fact tx calls free, this is not great
// also we pretend that TX always succeeds since the validated property would be weird otherwise
// TODO maybe trace some "tx was successful" variable, so we can put that in the property
uint16_t stub_tx(void* q, struct rte_mbuf** bufs, uint16_t nb_bufs);
//@ requires nb_bufs == 1 &*& *bufs |-> ?mb &*& mbufp(mb, _);
//@ ensures result <= nb_bufs &*& *bufs |-> mb &*& mbufp(mb, _);

void stub_free(struct rte_mbuf* mbuf);
//@ requires mbufp(mbuf,_);
//@ ensures true;

void flood(struct rte_mbuf *m, uint8_t skip_device,
           uint8_t nb_devices);
//@ requires mbufp(m,_);
//@ ensures true;

/*@
lemma void bit_and_zero(int x)
requires true;
ensures 0 == (0&x);
{
  assume(false);//TODO
}
@*/

/*@ predicate hide_is_map_keys_equality<t>(map_keys_equality* fun,
                                           predicate (void*;t) keyp) =
      is_map_keys_equality<t>(fun, keyp);
 @*/

/*@ predicate hide_is_map_key_hash<t>(map_key_hash* fun,
                                      predicate (void*;t) keyp,
                                      fixpoint (t,int) hsh) =
      is_map_key_hash<t>(fun, keyp, hsh);
 @*/

/*@ predicate hide_mapp<t>(struct Map* p,
                           predicate (void*;t) kp,
                           fixpoint (t,int) hsh,
                           fixpoint (t,int,bool) recp,
                           mapi<t> m) = mapp<t>(p, kp, hsh, recp, m); @*/

/*@ predicate hide_vector<t>(struct Vector* p) = vectorp<t>(p, _, _); @*/
