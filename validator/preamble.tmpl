#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "lib/stubs/core_stub.h"
#include "lib/containers/emap.h"
#include "lib/packet-io.h"
#include "lib/packet-headers.h"

// VeriFast can't deal with bitwise AND, so we hardcode known cases.
/*@
lemma void bit_and_hack()
requires true;
ensures 0x00 == (0x00 & 0x10) 
    &*& 0x00 == (0x01 & 0x10)
    &*& 0x10 == (0x11 & 0x10)
    &*& 0x00 == (0x41 & 0x10)
    &*& 0x10 == (0x111 & 0x10)
    &*& 0x10 == (0x211 & 0x10)
    &*& 0x00 == (0x241 & 0x10);
{
  assume(false);
}

lemma_auto void bit_and_equiv(unsigned int i)
requires i < 65536;
ensures i == (i & 65535);
{
  assume(false);
}

// VeriFast can't reason about modulo either, let's help it a bit...
lemma void modulo_hack()
requires true;
ensures forall_(int i; i < 0 || i % 2 == 0 || i % 2 == 1);
{
  assume(false);
}
@*/

void umemcpy(void *array, void *array0, size_t count);
    //@ requires uchars(array, count, ?cs) &*& [?f]uchars(array0, count, ?cs0);
    //@ ensures uchars(array, count, cs0) &*& [f]uchars(array0, count, cs0);
 
/*@
lemma void list_of_six<t>(list<t> l)
requires length(l) == 6;
ensures length(l) == 6 &*& l == cons(_, cons(_, cons(_, cons(_, cons(_, cons(_, nil))))));
{
  assume(false);//TODO
  switch(l) { case cons(h0,t0): switch(t0) { case cons(h1,t1):
  switch(t1) { case cons(h2,t2): switch(t2) { case cons(h3,t3):
  switch(t3) { case cons(h4,t4): switch(t4) { case cons(h5,t5):
  case nil:} case nil:} case nil:}
  case nil:} case nil:} case nil:}
}
@*/
