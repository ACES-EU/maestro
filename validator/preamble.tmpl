#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "lib/stubs/core_stub.h"

int flow_consistency(void* key_a, void* key_b, int index, void* value)
/*@ requires true; @*/
/*@ ensures true; @*/
{
   return 0;
}

void flood(struct rte_mbuf *m, uint8_t skip_device,
           uint8_t nb_devices);
//@ requires mbufp(m,_);
//@ ensures true;

// VeriFast can't deal with bitwise AND, so we hardcode known cases.
/*@
lemma void bit_and_hack()
requires true;
ensures 0x00 == (0x00 & 0x10) 
    &*& 0x00 == (0x01 & 0x10)
    &*& 0x10 == (0x11 & 0x10)
    &*& 0x00 == (0x41 & 0x10)
    &*& 0x10 == (0x111 & 0x10)
    &*& 0x10 == (0x211 & 0x10)
    &*& 0x00 == (0x241 & 0x10);
{
  assume(false);
}

lemma_auto void bit_and_equiv(unsigned int i)
requires i < 65536;
ensures i == (i & 65535);
{
  assume(false);
}

// VeriFast can't reason about modulo either, let's help it a bit...
lemma void modulo_hack()
requires true;
ensures forall_(int i; i < 0 || i % 2 == 0 || i % 2 == 1);
{
  assume(false);
}
@*/

void umemcpy(void *array, void *array0, size_t count);
    //@ requires uchars(array, count, ?cs) &*& [?f]uchars(array0, count, ?cs0);
    //@ ensures uchars(array, count, cs0) &*& [f]uchars(array0, count, cs0);

