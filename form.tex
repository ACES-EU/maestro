\documentclass{article}
\usepackage{dsfont}
\usepackage{amsmath}
\usepackage[margin=1.5cm]{geometry}
\renewcommand{\o}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\p}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\s}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\nintset}{\ensuremath{\mathds{Z}_{\ge 0}}}
\newcommand{\moreset}[1]{\ensuremath{\mathds{Z}_{\ge #1}}}

\begin{document}

An ``expiring map'' $m \in M[K,V]$ is an abstraction that maps keys $k \in K$ to values $v \in V$ and allows individual mappings to expire at an indicated time.

\paragraph{Abstract state $S(m\in M)$}
\begin{itemize}
   \item $m$.\s{mapping}: a set of entries $[k,v,t]$, with each entry mapping key $k$ to value $v$ until time $t$, after which the mapping expires
   \item $m$.\s{size}: the number of unexpired keys in $m$.\s{mapping} (for now, we assume at most one entry per key)
   \item $m$.\s{maxSize}: the maximum number of keys that this map $m$ can accommodate
\end{itemize}

\paragraph{Abstract operations}
\begin{itemize}
\item $m \gets \o{constructor}(s \in \nintset$) constructs a map $m\in M$ that holds at most $s$ entries
\item $p\gets \o{has}(m \in M, k \in K)$ indicates whether key $k$ exists in $m$ or not
\item $(v\in V, e\in \nintset)\gets \o{get}(m \in M, k \in K)$ returns the pair of value $v$ to which $k$ is mapped and time $e$ until this mapping is kept in $m$. If the key $k$ is not present, can return $fail$.
\item $x\gets \o{put}(m \in M, k \in K, v \in V, e \in \nintset)$ adds to $m$ a mapping from $k$ to $v$ that is valid until time $e$. Returns boolean $x$ - whether the operation was successfull.
\item $x\gets \o{erase}(m\in M, k \in K)$ removes the entry from $m$ that maps $k$ to a value. Returns boolean $x$ - whether the operation was successfull.
  %\item $\o{nop}(m\in M)$ does nothing, returns nothing.
\end{itemize}

Consider a map $m\in M$.  We model the use of $m$ as a finite sequence
$\tau = <o_0, o_1, ..., o_n>$
of operations $o_t$ on $m$ indexed by time $t \in \nintset$.
In our model, an operation completes fully before the next one commences (i.e., there is no concurrency).
%A continuous subsequence $<o_a, o_{a+1}, ..., o_{b-1}, o_b> (0\le a\le b\le n)$ of $\tau$ is designated as $\tau_a^b$
For simplicity, we assume that each operation takes exactly one unit of time.
We use the shorthand $\o{operation}_t(...)$ to indicate the operation that occurs at time $t$.

An execution is an interleaving of operations and ``snapshots'' of the abstract state
$\epsilon = <o_0, S_0, o_1, S_1, ..., o_n, S_n>$, with
each subsequence $<S_{i-1}, o_i, S_i>$ indicating that operation $o_i$ transforms abstract state $S_{i-1}$ into $S_i$.
An accessor does not mutate state, so it leaves the abstract state unchanged.
We use the shorthand $\s{component}_t$ to indicate the value of $S.$\s{component} immediately after $o_t$ completes and before $o_{t+1}$ commences.

{\it Note:} Symbol $\simeq$ in the following context: $o_t\simeq ...$ means that lefthand {\it operation} ($o_t$) can be equal to the righthand operation. E.g. $\forall k \in K, m \in M o_t\simeq \o{has}_t(m, k) \Leftrightarrow \p{const}_t(m)$ means, that the operation number t ($o_t$) may be $\o{has}(m, k)$ (not the result of such function call) if and only if holds $\p{const}_t(m)$.

By default, if symbols $m, e, k, v, t$ are used in a formula, and not mentioned before in that formula, the universal quantifier $\forall$ is implied: $\forall m\in M, k \in K, v\in V, e\in \nintset, t\in \nintset$.

\paragraph{Helper predicates}
\begin{itemize}
\item An ``empty'' map is one without any keys \\
  $\p{empty}_t(m\in M) \Leftrightarrow [k, v, e] \not\in m.\s{mapping}_t$
\item A ``const'' operation does not modify nonexpired mappings:\\
  $\p{const}_t(m\in M) ~\Leftrightarrow~\\ \Big([k, v, e] \in m.\s{mapping}_{t-1} \wedge e>t \Rightarrow [k, v, e] \in m.\s{mapping}_t\Big)\wedge\\ \Big([k, v, e] \not\in m.\s{mapping}_{t-1} \Rightarrow [k, v, e] \not\in m.\s{mapping}_t\Big)\wedge m.\s{size}_{t-1} \ge m.\s{size}_t$
\item An ``isolated'' operation does not modify nonexpired mappings, except for a single one:\\
  $\p{isolated}_t(m\in M, k'\in K) ~\Leftrightarrow~\\ \Big(k\neq k' \wedge [k, v, e] \in m.\s{mapping}_{t-1} \wedge e>t \Rightarrow [k, v, e] \in m.\s{mapping}_t\Big)\wedge\\ \Big(k\neq k' \wedge [k, v, e] \not\in m.\s{mapping}_{t-1} \Rightarrow [k, v, e] \not\in m.\s{mapping}_t\Big)$
\end{itemize}

\paragraph{Invariants}
These predicates allways hold:
\begin{itemize}
\item Map does not keep expired items: $\forall [k, v, e] \in m.\s{mapping}_t \Rightarrow e > t$
\item No operation except for $\o{constructor}_0$ can change map capacity:
  \begin{gather*}
    \forall t\in \nintset: t > 0 \Rightarrow m.\s{maxSize}_t=m.\s{maxSize}_0
  \end{gather*}
\end{itemize}

\paragraph{Semantics for accessors (may mutate $S$, do not change the nonexpired mappings)}
\begin{itemize}
\item[has]
  \begin{itemize}
  \item $\o{has}_t(m \in M, k \in K) ~\Leftrightarrow~ \exists [k,v,e] \in m.\s{mapping}_t \wedge o_t=\o{has}_t(m, k)$\\
  \item It does not change mappings:
    \begin{gather*}
      o_t \simeq \o{has}_t(m, k) ~\Leftrightarrow~ \p{const}_t(m)
    \end{gather*}
  \end{itemize}
\item[get]
  \begin{itemize}
  \item One can get a mapping only if it exists in the map:
      \begin{gather}
        \o{get}_t(m \in M, k \in K) \rightarrow fail ~\Leftrightarrow~ [k,v,e] \not\in m.\s{mapping}_t \wedge o_t=\o{get}_t(m, k)\label{eq:get1}\\
        (v\in V,e\in \nintset)\gets \o{get}_t(m \in M, k \in K) ~\Leftrightarrow~ \exists [k,v,e] \in m.\s{mapping}_t \wedge o_t=\o{get}_t(m, k) \label{eq:get2}
      \end{gather}
  \item In anyway, it does not change existing unexpired mappings:
    \begin{gather*}
      o_t \simeq \o{get}_t(m, k) ~\Leftrightarrow~ \p{const}_t(m)
    \end{gather*}
  \end{itemize}
\end{itemize}


\paragraph{Semantics for operations that mutate state}
\begin{itemize}
\item[constructor]
  \begin{itemize}
  \item The constructor forms a new empty map
    \begin{gather*}
      m \gets \o{constructor}_0(s \in \nintset) \Leftrightarrow \p{empty}_0(m) \wedge \big(\forall t \in \nintset \Rightarrow m.\s{maxSize}_t=s\big)
    \end{gather*}
  \item The constructor must be called once and only once, at the very beginning of $\tau$ (i.e., $\tau$ contains no other constructor call after the first one)
    \begin{gather*}
      o_0 \equiv \o{constructor}_0 \wedge \big(\forall t\in \moreset{1} \Rightarrow o_t \neq \o{constructor}_t\big)
    \end{gather*}
  \end{itemize}
\item[erase]
  \begin{itemize}
  \item ``Erase'' deletes an entry with a given key. If the entry does not exist in the \p{mapping}, it fails. It does not change other mappings if they are not expired.
    \begin{gather*}
      \Big(o_t \simeq \o{erase}_t(m\in M, k\in K) ~\Leftrightarrow~ \p{isolated}_t(m, k)\Big) \wedge
    \end{gather*}
  \item If there was a such mapping for $k$, ``erase'' will remove it.
    \begin{gather}
      \Big(x=\o{erase}_t(m\in M, k\in K) \wedge \exists [k, v, e] \in m.\s{mapping}_{t-1} ~\Leftrightarrow~\nonumber\\
      x=success \wedge \big(\forall v'\in V, e'\in \nintset \Rightarrow [k, v', e'] \not\in m.\s{mapping}_t\big) \wedge m.\s{size}_t \le m.\s{size}_{t-1}-1 \Big) \wedge
      \label{eq:erase1}
    \end{gather}
  \item If there was not --- it will fail.
    \begin{gather}
      \Big( x=\o{erase}_t(m\in M, k\in K) \wedge [k,v,e]\not\in m.\s{mapping}_{t-1} ~\Leftrightarrow~ \nonumber\\
      x=fail \wedge \p{const}_t(m)\Big)
      \label{eq:erase2}
    \end{gather}
  \end{itemize}
\item[put]
  \begin{itemize}
  \item ``Put'' inserts a new mapping, if the number of unexpired elements is less than \s{maxSize} and there is no unexpired entry with the same key.
    This function does not touch any unexpired entry with key other than $k$.
    \begin{gather*}
      \Big(o_t \simeq \o{put}_t(m\in M, k\in K, v\in V, e\in \moreset{t}) ~\Leftrightarrow~ \p{isolated}_t(m, k)\Big) \wedge
    \end{gather*}
  \item If there was no such mupping before, and there is enough room, it will succeed.
    \begin{gather}
      \Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} < m.\s{maxSize}_{t-1} \wedge \big(\forall v'\in V, e'\in \nintset \Rightarrow [k, v', e'] \not\in m.\s{mapping}_{t-1}\big) \Leftrightarrow \nonumber\\
      x=success \wedge m.\s{size}_t \le m.\s{size}_{t-1}+1 \wedge [k, v, e] \in m.\s{mapping}_t\Big)\wedge
      \label{eq:put1}
    \end{gather}
  \item If a mapping with key $k$ allready exists, and it does not expires on $t$, put will fail.
    \begin{gather}
      \Big(x=\o{put}_t(m, k, v, e) \wedge \big(\exists v'\in V, e'\in \nintset: [k, v', e']\in m.\s{mapping}_{t-1} \wedge e > t \big) \Leftrightarrow\nonumber\\
      x=fail \wedge \p{const}_t(m)\Big)\wedge
      \label{eq:put2}
    \end{gather}
  \item If a mapping with key $k$ expires on $t$, put will replace it:
    \begin{gather}
      \Big(x=\o{put}_t(m, k, v, e) \wedge \big(\exists v'\in V: [k, v', t]\in m.\s{mapping}_{t-1}\big) \Leftrightarrow\nonumber\\
      x=success \wedge m.\s{size}_t \le m.\s{size}_{t-1} \wedge [k, v, e] \in m.\s{mapping}_t\Big)\wedge
      \label{eq:put3}
    \end{gather}
  \item If there is no room, but some mappings expire on $t$, put will succeed:
    \begin{gather}
      \Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \wedge [k, v, e] \not\in m.\s{mapping}_{t-1} \wedge \nonumber\\
      \big(\exists k'\in K, v'\in V: [k', v', t] \in m.\s{mapping}_{t-1}\big) \Leftrightarrow\nonumber\\
      x=success \wedge m.\s{state}_t \le m.\s{state}_{t-1} \wedge [k, v, t] \in m.\s{mapping}_t\Big)\wedge
      \label{eq:put4}
    \end{gather}
  \item If there is no room, and no mappings expire on $t$, put will fail:
    \begin{gather}
      \Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \wedge \nonumber\\
      \big(\forall k'\in K, v'\in V, e' \in \nintset: [k', v', e'] \in m.\s{mapping}_{t-1} \Rightarrow e' > t \big) \Leftrightarrow\nonumber\\
      x=fail \wedge \p{const}_t(m)\Big)
      \label{eq:put5}
    \end{gather}
  \end{itemize}

\end{itemize}

\paragraph{Properties to be proven}
\begin{itemize}
\item $\p{empty}_t(m) \Leftrightarrow m.\s{size}_t=0$
\item If the map is empty, there no keys in it:
  \begin{gather*}
    \p{empty}_t(m) \Leftrightarrow \o{has}_t(m, k) = false
  \end{gather*}
\item Equivalent helper predicate \p{isolated} definition
  \begin{gather*}
    \p{isolated}_t(m\in M, k'\in K) ~\Leftrightarrow~\nonumber\\
    \Big(k\neq k' \wedge \o{has}_{t-1}(m, k) \wedge (v,e)=\o{get}_{t-1}(m, k) \wedge e>t \Rightarrow \o{has}_t(m, k) \wedge \o{get}_t(m, k)=(v,e)\Big)\wedge\nonumber\\
    \Big(k\neq k' \wedge \neg \o{has}_{t-1}(m, k) \Rightarrow \neg\o{has}_t(m, k)\Big)
  \end{gather*}
\item Equivalent helper predicate \p{const} definition
  \begin{gather*}
    \p{const}_t(m\in M) ~\Leftrightarrow~\nonumber\\
    \Big(\o{has}_{t-1}(m, k) \wedge (v,e)=\o{get}_{t-1}(m, k) \wedge e>t \Rightarrow \o{has}_t(m, k) \wedge \o{get}_t(m, k)=(v,e)\Big)\wedge\nonumber\\
    \Big(\forall k\in K: \neg \o{has}_{t-1}(m, k) \Rightarrow \neg\o{has}_t(m, k)\Big)
  \end{gather*}

\item Equivalent of \eqref{eq:get1}:
  \[
  \o{has}_t(m, k) \Leftrightarrow \o{get}_t(m, k) \not\rightarrow fail
  \]
\item If there was a mapping for $k$, ``erase'' removes it. Equivalent of \eqref{eq:erase1}:
  \begin{gather*}
    \Big(x=\o{erase}_t(m\in M, k\in K) \wedge \o{has}_{t-1}(m, k) ~\Leftrightarrow~ x=success \wedge \neg\o{has}_t(m, k) \wedge m.\s{size}_t \le m.\s{size}_{t-1}-1 \Big)
  \end{gather*}
\item If there were not --- ``erase'' will fail. Equivalent of \eqref{eq:erase2}:
  \begin{gather*}
    \Big(x=\o{erase}_t(m\in M, k\in K) \wedge \neg\o{has}_{t-1}(m, k) ~\Leftrightarrow~ x=fail\wedge \p{const}_t(m)\Big)
  \end{gather*}

\item Equivalent of \eqref{eq:put1}
  \begin{gather*}
    \Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} < m.\s{maxSize}_{t-1} \wedge \neg\o{has}_{t-1}(m, k) \Leftrightarrow \nonumber\\
    x=success \wedge m.\s{size}_t \le m.\s{size}_{t-1}+1 \wedge \o{has}_t(m, k)\wedge\o{get}_t(m, k) = (v, e)\Big)
  \end{gather*}

\item If there is an unexpired mapping with the same key, put will fail. Equivalent of \eqref{eq:put2}
  \begin{gather*}
    \Big(x=\o{put}_t(m, k, v, e) \wedge \o{has}_{t-1}(m, k) \wedge \exists e'\in \nintset: (\cdot, e')=\o{get}_{t-1}(m, k) \wedge e' > t \Leftrightarrow\\
    x=fail \wedge \p{const}_t(m)\Big)
  \end{gather*}

\item Equivalent of \eqref{eq:put3}. Expired mapping replaced:
  \begin{gather*}
    \Big(x=\o{put}_t(m, k, v, e) \wedge \o{has}_{t-1}(m, k) \wedge (\cdot, t)=\o{get}_{t-1}(m, k) \Leftrightarrow\\
    x=success \wedge m.\s{size}_t \le m.\s{size}_{t-1} \wedge \o{has}_t(m, k)\wedge\o{get}_t(m, k) = (v, e)\Big)
  \end{gather*}

\item Equivalent of \eqref{eq:put4}. If there is no room, but some mappings have expired, one still can put.
  \begin{gather*}
    \Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \wedge \neg\o{has}_{t-1}(m, k) \wedge\\
    \big(\exists k'\in K: \o{has}_{t-1}(m,k')\wedge (\cdot,t)=\o{get}_{t-1}(m, k) \big) \Leftrightarrow\\
    x=success \wedge \o{has}_t(m, k)\wedge\o{get}_t(m, k) = (v, e) \wedge m.\s{size}_t \le m.\s{size}_{t-1}\Big)
\end{gather*}

\item Into full map, one can not put any more keys. Equivalent of \eqref{eq:put5}:
  \begin{gather*}
    \Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \wedge  \\
    \big(\forall k'\in K,e'\in \nintset :\o{has}_{t-1}(m, k')\wedge(\cdot,e')=\o{get}_{t-1}(m,k') \Rightarrow e' > t \big) \Leftrightarrow\\
    x=fail \wedge m.size_t = m.size_{t-1} \wedge \p{const}_t(m, k)\Big)
  \end{gather*}

\item The size of the map is always properly bounded
  \begin{gather*}
    \forall t\in \nintset: t>0  \wedge m=\o{constructor}_0(s \in \nintset) \Rightarrow 0 \le m.\s{size}_t \le m.\s{maxSize}
  \end{gather*}

\item For any subsequence of operations other than \o{put}, size of the map may only decrease:
  \begin{gather*}
    \forall a\in \nintset,b\in \nintset: a<b \wedge \big(\forall t\in \nintset:a<t<b \Rightarrow o_t \neq \o{put}_t \big) \Rightarrow \s{size}_a \ge \s{size}_b
  \end{gather*}

\item If a subsequence of operations does not include \o{erase} for key $k\in K$, and there is a mapping, it will be kept until the end of the subsequence, or until expired:
  \begin{gather*}
    \forall a\in \nintset,b, k\in K, m\in M, v\in V, e\in \moreset{b}: a < b \wedge \o{has}_a(m, k) \wedge (v, e)=\o{get}_a{m, k} \wedge e > b ~ \wedge\nonumber\\
    \big(\forall t\in \nintset: a<t<b \Rightarrow o_t\neq \o{erase}_t(m, k)\big) \Rightarrow\nonumber\\
    \o{has}_b(m, k) \wedge \o{get}_b(m, k) = (v,e)
  \end{gather*}

\end{itemize}


\end{document}
