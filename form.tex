\documentclass{article}
\usepackage{dsfont}
\usepackage[margin=1.5cm]{geometry}
\renewcommand{\o}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\p}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\s}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\nintset}{\ensuremath{\mathds{Z}_{\ge 0}}}
\newcommand{\moreset}[1]{\ensuremath{\mathds{Z}_{\ge #1}}}

\begin{document}

An ``expiring map'' $m \in M[K,V]$ is an abstraction that maps keys $k \in K$ to values $v \in V$ and allows individual mappings to expire at an indicated time.

\paragraph{Abstract state $S(m\in M)$}
\begin{itemize}
   \item $m$.\s{mapping}: a set of entries $[k,v,t]$, with each entry mapping key $k$ to value $v$ until time $t$, after which the mapping expires
   \item $m$.\s{size}: the number of unexpired keys in $m$.\s{mapping} (for now, we assume at most one entry per key)
   \item $m$.\s{maxSize}: the maximum number of keys that this map $m$ can accommodate
\end{itemize}

\paragraph{Abstract operations}
\begin{itemize}
   \item $m \gets \o{constructor}(s \in \nintset$) constructs a map $m\in M$ that holds at most $s$ entries
   \item $p\gets \o{has}(m \in M, k \in K)$ indicates whether key $k$ exists in $m$ or not
   \item $(v\in V, e\in \nintset)\gets \o{get}(m \in M, k \in K)$ returns the pair of value $v$ to which $k$ is mapped and time $e$ until this mapping is kept in $m$. If the key $k$ is not present, can return $fail$.
   \item $x\gets \o{put}(m \in M, k \in K, v \in V, e \in \nintset)$ adds to $m$ a mapping from $k$ to $v$ that is valid until time $e$. Returns boolean $x$ - whether the operation was successfull.
   \item $x\gets \o{erase}(m\in M, k \in K)$ removes the entry from $m$ that maps $k$ to a value. Returns boolean $x$ - whether the operation was successfull.
   %\item $\o{nop}(m\in M)$ does nothing, returns nothing.
\end{itemize}

Consider a map $m\in M$.  We model the use of $m$ as a finite sequence 
$\tau = <o_0, o_1, ..., o_n>$
of operations $o_t$ on $m$ indexed by time $t \in \nintset$. 
In our model, an operation completes fully before the next one commences (i.e., there is no concurrency).
%A continuous subsequence $<o_a, o_{a+1}, ..., o_{b-1}, o_b> (0\le a\le b\le n)$ of $\tau$ is designated as $\tau_a^b$
For simplicity, we assume that each operation takes exactly one unit of time.
We use the shorthand $\o{operation}_t(...)$ to indicate the operation that occurs at time $t$.  

An execution is an interleaving of operations and ``snapshots'' of the abstract state
$\epsilon = <o_0, S_0, o_1, S_1, ..., o_n, S_n>$, with
each subsequence $<S_{i-1}, o_i, S_i>$ indicating that operation $o_i$ transforms abstract state $S_{i-1}$ into $S_i$.
An accessor does not mutate state, so it leaves the abstract state unchanged.
We use the shorthand $\s{component}_t$ to indicate the value of $S.$\s{component} immediately after $o_t$ completes and before $o_{t+1}$ commences.

{\it Note:} Symbol $\simeq$ in the following context: $o_t\simeq ...$ means that lefthand {\it operation} ($o_t$) can be equal to the righthand operation. E.g. $\forall k \in K, m \in M o_t\simeq \o{has}_t(m, k) \Leftrightarrow \p{const}_t(m)$ means, that the operation number t ($o_t$) may be $\o{has}(m, k)$ (not the result of such function call) if and only if holds $\p{const}_t(m)$.

By default, if symbols $m, e, k, v$ are used in a formula, and not mentioned before in that formula, the universal quantifier $\forall$ is implied: $\forall m\in M, k \in K, v\in V, e\in \nintset$.

\paragraph{Helper predicates}
\begin{itemize}
   \item An ``empty'' map is one without any keys \\
            $\p{empty}_t(m\in M) \Leftrightarrow [k, v, e] \not\in m.\s{mapping}_t$
   \item A ``const'' operation does not modify nonexpired mappings:\\
     $\p{const}_t(m\in M) ~\Leftrightarrow~\\ \Big([k, v, e] \in m.\s{mapping}_{t-1} \wedge e>t \Rightarrow [k, v, e] \in m.\s{mapping}_t\Big)\wedge\\ \Big([k, v, e] \not\in m.\s{mapping}_{t-1} \Rightarrow [k, v, e] \not\in m.\s{mapping}_t\Big)\wedge m.\s{size}_{t-1} \ge m.\s{size}_t$
   \item An ``isolated'' operation does not modify nonexpired mappings, except for a single one:\\
     $\p{isolated}_t(m\in M, k'\in K) ~\Leftrightarrow~\\ \Big(k\neq k' \wedge [k, v, e] \in m.\s{mapping}_{t-1} \wedge e>t \Rightarrow [k, v, e] \in m.\s{mapping}_t\Big)\wedge\\ \Big(k\neq k' \wedge [k, v, e] \not\in m.\s{mapping}_{t-1} \Rightarrow [k, v, e] \not\in m.\s{mapping}_t\Big)$
   
\end{itemize}

\paragraph{Semantics for accessors (may mutate $S$, do not change the nonexpired mappings)}
\begin{itemize}
   \item[has]
     \begin{itemize}
       \item $\o{has}_t(m \in M, k \in K) ~\Leftrightarrow~ \exists [k,v,e] \in m.\s{mapping}_t \wedge o_t=\o{has}_t(m, k)$\\
       \item It does not change nonexpired mappings:
         \begin{equation}
           o_t \simeq \o{has}_t(m, k) ~\Leftrightarrow~ \p{const}_t(m)
         \end{equation}
     \end{itemize}
     \item[get]
       \begin{itemize}
         \item One can get a mapping only if it exists in the map:
           $$\o{get}_t(m \in M, k \in K) \rightarrow fail ~\Leftrightarrow~ [k,v,e] \not\in m.\s{mapping}_t \wedge o_t=\o{get}_t(m, k)$$
           $$(v\in V,e\in \nintset)\gets \o{get}_t(m \in M, k \in K) ~\Leftrightarrow~ \exists [k,v,e] \in m.\s{mapping}_t \wedge o_t=\o{get}_t(m, k)$$
         \item In anyway, it does not change existing unexpired mappings:
           $$o_t \simeq \o{get}_t(m, k) ~\Leftrightarrow~ \p{const}_t(m)$$
       \end{itemize}
\end{itemize}


\paragraph{Semantics for operations that mutate state}
\begin{itemize}
  \item[constructor]
    \begin{itemize}
      \item The constructor forms a new empty map \\
        $m \gets \o{constructor}_0(s \in \nintset) \Leftrightarrow \p{empty}_0(m) \wedge \forall t \in \nintset m.\s{maxSize}_t=s$
      \item The constructor must be called once and only once, at the very beginning of $\tau$ (i.e., $\tau$ contains no other constructor call after the first one) \\
        $o_0 \equiv \o{constructor}_0 \wedge (\forall t\in \moreset{1} \Rightarrow o_t \neq \o{constructor}_t)$ 
    \end{itemize}
  \item[erase]
    \begin{itemize}
      \item ``Erase'' deletes an entry with a given key. If the entry does not exist in the \p{mapping}, it fails. It does not change other mappings if they are not expired.
        $$\Big(o_t \simeq \o{erase}_t(m\in M, k\in K) ~\Leftrightarrow~ \p{isolated}_t(m, k)\Big) \wedge$$
      \item If there was a such mapping for $k$, ``erase'' will remove it.
        $$\Big(x=\o{erase}_t(m\in M, k\in K) \wedge \exists [k, v, e] \in m.\s{mapping}_{t-1} ~\Leftrightarrow~$$
        $$x=success \wedge \big(\forall v'\in V, e'\in \nintset \Rightarrow [k, v', e'] \not\in m.\s{mapping}_t\big) \wedge m.\s{size}_t \le m.\s{size}_{t-1}-1 \Big) \wedge$$
      \item If there was not --- it will fail. 
        $$\Big(x=\o{erase}_t(m\in M, k\in K) \wedge [k,v,e]\not\in m.\s{mapping}_{t-1} ~\Leftrightarrow~$$
        $$x=fail \wedge \p{const}_t(m)\Big)$$
    \end{itemize}
    \item[put]
      \begin{itemize}
        \item ``Put'' inserts a new mapping, if the number of unexpired elements is less than \s{maxSize} and there is no unexpired entry with the same key.
          This function does not touch any unexpired entry with key other than $k$.
          $$\Big(o_t \simeq \o{put}_t(m\in M, k\in K, v\in V, e\in \moreset{t}) ~\Leftrightarrow~ \p{isolated}_t(m, k)\Big) \wedge$$
        \item If there was no such mupping before, and there is enough room, it will succeed.
          $$\Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} < m.\s{maxSize}_{t-1} \wedge \big(\forall v'\in V, e'\in \nintset \Rightarrow [k, v', e'] \not\in m.\s{mapping}_{t-1}\big) \Leftrightarrow $$
          $$ x=success \wedge m.\s{size}_t \le m.\s{size}_{t-1}+1 \wedge [k, v, e] \in m.\s{mapping}_t\Big)\wedge$$
        \item If a mapping with key $k$ allready exists, and it does not expires on $t$, put will fail.
          $$\Big(x=\o{put}_t(m, k, v, e) \wedge \big(\exists v'\in V, e'\in \nintset: [k, v', e']\in m.\s{mapping}_{t-1} \wedge e > t \big) \Leftrightarrow$$
          $$x=fail \wedge \p{const}_t(m)\Big)\wedge$$
        \item If a mapping with key $k$ expires on $t$, put will replace it:
          $$\Big(x=\o{put}_t(m, k, v, e) \wedge \big(\exists v'\in V: [k, v', t]\in m.\s{mapping}_{t-1}\big) \Leftrightarrow$$
          $$ x=success \wedge m.\s{size}_t \le m.\s{size}_{t-1} \wedge [k, v, e] \in m.\s{mapping}_t\Big)\wedge$$
        \item If there is no room, but some mappings expire on $t$, put will succeed:
          $$\Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \wedge [k, v, e] \not\in m.\s{mapping}_{t-1} \wedge $$
          $$\big(\exists k'\in K, v'\in V: [k', v', t] \in m.\s{mapping}_{t-1}\big) \Leftrightarrow$$
          $$x=success \wedge m.\s{state}_t \le m.\s{state}_{t-1} \wedge [k, v, t] \in m.\s{mapping}_t\Big)\wedge$$
        \item If there is no room, and no mappings expire on $t$, put will fail:
          $$\Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \wedge $$
          $$\big(\forall k'\in K, v'\in V, e' \in \nintset: [k', v', e'] \in m.\s{mapping}_{t-1} \Rightarrow e' > t \big) \Leftrightarrow$$
          $$x=fail \wedge \p{const}_t(m)\Big)$$
      \end{itemize}
     
\end{itemize}

\paragraph{Properties to be proven}
\begin{itemize}
  \item $\p{empty}_t(m) \Leftrightarrow m.\s{size}_t=0$
  \item If the map is empty, there no keys in it:
    $$m.\s{size}_t=0 \Leftrightarrow \forall k\in K \o{has}_t(m, k) = false $$
  \item $\o{has}_t(m, k) \Leftrightarrow \o{get}_t(m, k) \not\rightarrow fail$

      \item If there was a such mapping for $k$, ``erase'' will remove it.
        $$\Big(x=\o{erase}_t(m\in M, k\in K) \wedge \o{has}_{t-1}(m, k) ~\Leftrightarrow~ x=success \wedge \neg\o{has}_t(m, k) \wedge m.\s{size}_t \le m.\s{size}_{t-1}-1 \Big) \wedge$$
      \item If there were not --- it will fail. 
        $$\Big(x=\o{erase}_t(m\in M, k\in K) \wedge \neg\o{has}_{t-1}(m, k) ~\Leftrightarrow~ x=fail\wedge m.\s{size}_t \le m.\s{size}_{t-1}\Big)$$

      \item 
          $$\Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} < m.\s{maxSize}_{t-1} \wedge \neg\o{has}_{t-1}(m, k) \Leftrightarrow $$
          $$ x=success \wedge m.\s{size}_t \le m.\s{size}_{t-1}+1 \wedge \o{has}_t(m, k)\wedge\o{get}_t(m, k) = (v, e)\Big)\wedge$$

%        \item If there is no room, but some mappings have expired, one still can put.
%          $$\Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \wedge \neg\o{has}_{t-1}(m, k) \wedge$$
%          $$\big(\exists k'\in K, e'\in \nintset: \o{has}_{t-1}(m,k')\wedge (\cdot,e')=\o{get}_{t-1}(m, k) \wedge e'<t \big) \Leftrightarrow$$
%          $$x=success \wedge \o{has}_t(m, k)\wedge\o{get}_t(m, k) = (v, e)\Big)\wedge$$


%          $$\Big(x=\o{put}_t(m, k, v, e) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \wedge \neg\o{has}_{t-1}(m, k) \wedge$$
%          $$\big(\exists k'\in K, e'\in \nintset: \o{has}_{t-1}(m,k')\wedge (\cdot,e')=\o{get}_{t-1}(m, k) \wedge e'<t \big) \Leftrightarrow$$
%          $$x=success \wedge \o{has}_t(m, k)\wedge\o{get}_t(m, k) = (v, e)\Big)\wedge$$
%        \item If there is an unexpired mapping with the same key, put will fail.
%          $$\Big(x=\o{put}_t(m, k, v, e) \wedge \o{has}_{t-1}(m, k) \wedge (v, e)=\o{get}_{t-1}(m, k) \wedge e \ge t \Leftrightarrow$$
%          $$x=fail \wedge m.\s{size}_t \le m.\s{size}_{t-1} \wedge \o{has}_t(m, k) \wedge \o{get}_t(m, k) = (v, e)\Big)\wedge$$
%        \item Into full map, one can not put any more keys.
%          $$\Big(x=\o{put}_t(m, k, v, e) \wedge$$
%          $$\big(\forall k'\in K,e'\in \nintset :\o{has}_{t-1}(m, k')\wedge(\cdot,e')=\o{get}_{t-1}(m,k') \Rightarrow e' \ge t \big) \wedge m.\s{size}_{t-1} = m.\s{maxSize}_{t-1} \Leftrightarrow$$
%          $$x=fail \wedge m.\s{size}_t = m.\s{size}_{t-1} \wedge \p{const}_t(m, k)\Big)\wedge$$

  \item The size of the map is always properly bounded 
   $$\forall t\in \nintset: t>0  \wedge m=\o{constructor}_0(s \in \nintset) \Rightarrow 0 \le m.\s{size}_t \le m.\s{maxSize}$$
  \item No operation except for $\o{constructor}_0$ can change map capacity:
   $$\forall t\in \nintset: t > 0 \Rightarrow m.\s{maxSize}_t=m.\s{maxSize}_0$$
  \item For any subsequence of operations other than \o{put}, size of the map may only decrease:
   $$\forall a\in \nintset,b\in \nintset: a<b \wedge \big(\forall t\in \nintset:a<t<b \Rightarrow o_t \neq \o{put}_t \big) \Rightarrow \s{size}_a \ge \s{size}_b$$
  \item If a subsequence of operations does not include \o{erase} for key $k\in K$, and there is a mapping, it will be kept until the end of the subsequence, if not expired:
   $$\forall a\in \nintset,b, k\in K, m\in M, v\in V, e\in \moreset{b}: a < b \wedge \o{has}_a(m, k) \wedge (v, e)=\o{get}_a{m, k} \wedge e \ge b ~ \wedge$$
   $$\big(\forall t\in \nintset: a<t<b \Rightarrow o_t\neq \o{erase}_t(m, k)\big) \Rightarrow$$
   $$\o{has}_b(m, k) \wedge \o{get}_b(m, k) = (v,e)$$
  \item $$\p{isolated}_t(m\in M, k'\in K) ~\Leftrightarrow~$$
     $$\Big(\forall k\in K,v \in V, e\in \nintset : k\neq k' \wedge \o{has}_{t-1}(m, k) \wedge (v,e)=\o{get}_{t-1}(m, k) \wedge e>t \Rightarrow \o{has}_t(m, k) \wedge \o{get}_t(m, k)=(v,e)\Big)\wedge$$
     $$\Big(\forall k\in K:k\neq k' \wedge \neg \o{has}_{t-1}(m, k) \Rightarrow \neg\o{has}_t(m, k)\Big)$$
  \item $$\p{const}_t(m\in M) ~\Leftrightarrow~$$
     $$\Big(\forall k\in K,v \in V, e\in \nintset : \o{has}_{t-1}(m, k) \wedge (v,e)=\o{get}_{t-1}(m, k) \wedge e>t \Rightarrow \o{has}_t(m, k) \wedge \o{get}_t(m, k)=(v,e)\Big)\wedge$$
     $$\Big(\forall k\in K: \neg \o{has}_{t-1}(m, k) \Rightarrow \neg\o{has}_t(m, k)\Big)$$

\end{itemize}


\end{document}
