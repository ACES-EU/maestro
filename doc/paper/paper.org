* Abstract
* Introduction
- Note taken on [2016-08-08 Mon 15:44] \\
  Another possible running example: array
- Note taken on [2016-08-02 Die 10:14] \\
  Running example: batcher.
** Problem Statement
Software network applications lack dependability (why, how?).
** Solution Overview
*Optimistic* symbolic execution.
Run symbolic execution with data structures approximated by specially crafted
models, and loops reduced to a single iteration. This addresses infinite
execution paths and symbolic pointer access problems.
We offer a new approach to verify network applications. Specifically
the applications that meet the following requirements:
- no deep recursion
- clear loops (limited repetition model)
- clean state encapsulation into a set of well defined data structures
- OS interaction strictly thourgh a well defined interface
- Event processing model:
  infinite loop, with short iterations dedicated to process a single event each
  with short and simple data-structure and OS interaction patterns.
- ...???
** Contributions
- Verification methodology
- Crash-free, performant but basic software NAPT (anything else?)
- Verification tool (validator)
** Roadmap
* Solution
TODO functoin call overhead vs. load from a memory
TODO dynamic memory allocatoin vs. static memory allocation
Proposed methodology:
1. Encapsulate all state (specifically: large or variable-length arrays; dynamic
   index accessed memory (e.g. a port configuration stored into a single table,
   and accessed during port enumeration)
2. Implement and formally (very labour intensive) verify the data-structure
   specifications
3. Provide symbolic models, suitable for the use-case. Symbolic model is a
   partial implementation that:
   - exhibits at least as general behaviour as specified for a bounded sequence
     of API calls
   - utilizes a small statically defined amount of state
4. Provide loop invariants for long loops (i.e. event loop and port-enumerating
   loop). Invariants should be mostly a conjunction of the corresponding
   invariants for the symbolic models.
5. Run symbolic execution on the resulting application. Make sure it does not
   report any bugs. False positives here may be caused by excess generality of
   the models.
6. Collect API call traces and validate with the help of the formal verification
   engine. This step ensures the claim in the step #3 (the model is
   general enough).
Shortcoming: extra indirections, introduced for generality, may hurt
performance. May be eliminated by static inlining, but C is a difficult language
for that.
** Assumptions
- Currently we trust the application developer to put loop invariant assumptions
and assertions in correct order and into the right places; link the application
correctly; use only verified components and interpret the verification result.
- We trust the component developer to properly mark the interface functions.
- We assume overapproximation of the symbolic environment model. Unfortunately,
  we have no formal specificaiton, so we can not validate this assumption.
- We assume correct hardware which does not crash on its own by a software
  unrelated cause
- We assume correct compiler that implements the same language semantics used by
  VeriFast and Klee(LLVM).
*** TCB:
- Klee (+patches);
- VeriFast (+patches);
- Solvers (metaSMT, STP, Z3, etc.)
- Home-made validator, based on VeriFast
- Verification driver
- DPDK
- OS
* Prototype
Patched Klee:
- loop invariant support
- API call trace prefix dump
Patched VeriFast:
- accumulated conditions dump
Home-made validator: 
1. Parse the Klee dumps
2. Transform them into VeriFast tasks
   - Narrow down the behaviour by searching the assignment for unbounded symbolic
   variables.
   - Insert helper lemmas to help formal verification.
3. Run VeriFast to try out the spec in the place of the model, and verify the
   behaviour.
Shortcoming: TCB includes Klee + SMT solver + VeriFast + all our patches + our
home-made Validator. The last two items are hardly tested.
However, *TODO Note on the orthogonality of bugs*
* Evaluation
Consider different working areas:
- empty table,
- saturated table,
- saturated hash,
- overflow.
** Throughput:
*** uni-flow
*** multi-flow
** Latency:
*** existing flow
*** new flow

* Related Work
- Dobrescu stateles Click modules verification
- Something about replication-based reliability
* Conclusion
* Acknolegements
