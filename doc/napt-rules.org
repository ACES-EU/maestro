* parameters
This are external configuration parameters of the NAPT box
- ~CAPACITY~ - the maximum number of simultaneously active flows in the table
- ~Texp~ - the expiration time. If the last packet in the flow was less than ~Texp~ ago, the flow must be kept, otherwise it must be removed.

* NAPT abstract state
This defines the abstract representation of the NAPT dynamic state, that determines its behavior. Later we will connect real implementation state that is just a structured physical memory array with this abstract state using abstraction function.
Our NAPT abstraction refers to an internal host that is an endpoint on the internal (private) network connecting through the NAT box to an external host that is on the external (public) network.
We focus here only on the TCP and UDP, leaving out ICMP for simplicity.
#+BEGIN_SRC 
End_point := tuple<addr, port> -- IP address of a host and TCP/UDP port number

Flow_entry := tuple<int_src_ep : End_point, -- internal host end point (addr + port)
                    ext_src_ep : End_point, -- source end point for the packets as seen externally
                    dst_ep     : End_point, -- external host end point (addr + port)
                    protocol   : TCP/UDP>   -- protocol: TCP or UDP

Ext_flow_id := tuple<ext_src_ep,
                     dst_ep,
                     protocol>
Int_flow_id := tuple<int_src_ep,
                     dst_ep,
                     protocol>

flow_table := set of<Flow entry, Timestamp>
              unique in each Ext_flow_id and Int_flow_id projections
#+END_SRC

* definitions
This section defines necessary terminology for specifying essential NAPT behavior cases.
** preconditions
These are the things that determine NAPT's behavior on every event (on every packet that comes in).
  - =Ext_flow_id F exists=: (projection ~Ext_flow_Id~ over ~flow_table~) contains ~F~
  - =Int_flow_id F exists=: (projection ~Int_flow_Id~ over ~flow_table~) contains ~F~
  - =the flow table not full=: length(~flow_table~) < ~CAPACITY~
  - =packet P comes=: A new packet ~P~ comes through one of the interfaces to the NAPT for processing
  - =P is internal=: packet ~P~ is attributed to the internal interface
  - =P is external=: packet ~P~ is attributed to the external interface

** postconditions
This section defines possible transformation of the generalized state (NAPT abstract state + packets in the network) that NAPT may perform.
We divide all the postconditions into three domains:
1. Time related: handle flow expiration
2. Flow management: add new flows to the table, find existing ones
3. Packet forwarding: transmit or drop packets.

*** time related
#+BEGIN_SRC
Expire(flow_table, time) -> filter flow_table, keep only (flow, timestamp) where time < timestamp + Texp
#+END_SRC
- /some flows are expired/: ~flow_table~' = Expire(~flow_table~, ~now~)
- /flow F is refreshed/: ~flow_table~' = replace(~F~ with ~rejuvenated_flow~ in ~flow_table~), where ~rejuvenated_flow~ has the same flow entry with ~timestamp~ = ~now~
*** flow management
- /flow allocated for P/: ~flow_table~' = ~flow_table~ ++ ~new_flow~, where not(=~Ext_flow_id~ (~new_flow~) flow exists=), and it corresponds to packet P. ~timestamp~ (~new_flow~) = ~now~
*** packet forwarding
- /P is forwarded/: NAPT injects to the network packet ~P~ with the same payload and header rewritten according to ~F(P)~ as specified in RFC3022 and the network interface changed to the opposite one
- /packet is dropped/: do nothing, added for clarity

* rules
The rules are split into two parts: "precondition" -> "postcondition".
"Precondition" is an event and all the conditions that determine the next NAPT generalized state change.
"Postcondition" is the NAPT's response to that even. It describes the abstract state transformation (i.e. new flow in the table) and the reaction visible from the outside (i.e. outgoing packets)
** preconditions
This section describes the all the conditions that may trigger a NAPT action (i.e. generalized state change). No other event may change the abstract state or cause the NAPT to performa an action (i.e. emit a packet). It also can not happen spontaneously.
#+BEGIN_SRC 
Packet P comes  -> P is internal -> F(P) exists      -> (1)
                                 -> not(F(P) exists) -> flow table is not full -> (2)
                                                     -> otherwise              -> (3)
                -> P is external -> F(P) exists      -> (1)
                                 -> not(F(P) exists) -> (3)
#+END_SRC

** postconditions
The postconditions chain the 3 groups of transformations described above. The transformations of different groups are separated by '|'. They allways follow as time-related|flow-management|packet-forwarding. Some of the groups may be abscent.

#+BEGIN_SRC 
1. /some flows are expired/,
   /flow ~F(P)~ is refreshed/ |                          | /~P~ is forwarded/
2. /some flows are expired/   | /flow allocated for ~P~/ | /~P~ is forwarded/
3. /some flows are expired/   |                          | /packet is dropped/
#+END_SRC

* implementation specific state
Our NAPT keeps its dynamic state in two datastructures: Double map and Allocator. VeriFast proof lifts their physical representation into the following logical form:
#+BEGIN_SRC 
allocator = list of <allocated_index, timestamp>
            allocated_index'es are unique
double_map = list of <Ext_flow_id, Int_flow_id, Flow_entry, index>
             each flow_entry <=> (ext_flow_id + int_flow_id)
             each index is present in the allocator
#+END_SRC

* abstraction function
This section is implementation specific. It defines an abstraction function that transforms the implementation state into the abstract state.
#+BEGIN_SRC 
Abstraction(double_map, allocator, time) ->
  forall (allocated_index, timestamp) in Allocator
    such thet (time < timestamp + Texp) 
    find (ext_flow_id, int_flow_id, flow_entry, allocated_index) in double_map
    collect (flow_entry, timestamp)
#+END_SRC
