* parameters
- ~CAPACITY~ - the maximum number of simultaniously active flows in the table
- ~Tmin~ - the minimum expiration time. If the last packet in the flow was less than ~Tmin~ ago, the flow must be present in the flow table
- ~Tmax~ - the maximum expiration time. If the last packet in the flow was more than ~Tmax~ ago, the flow must be expired.

* NAPT abstract state
#+BEGIN_SRC 
Flow entry := 7-tuple:<in src_addr,  -- IP address of the external host
                       in src_port,  -- TCP/UDP port of the internal host
                       ex src_addr,  -- source IP address of the packets as seen externally
                       ex src_port,  -- source TCP/UDP port of the packets as seen externally
                       dst_ip,       -- IP address of the external host
                       dst_port,     -- TCP/UDP port of the external host
                       protocol>     -- protocol: TCP or UDP (ICMP is under development)

External flow ID := 5-tuple<ex src_addr,
                            ex src_port,
                            dst_ip,
                            dst_port,
                            protocol>
Internal flow ID := 5-tuple<in src_addr,
                            in src_port,
                            dst_ip,
                            dst_port,
                            protocol>
Flow table := set of<Flow entry, Timestamp>

Expire(table, time) -> filter table: for every (flow entry, timestamp):
    time - Tmin < timestamp -> keep
    timestamp < time - Tmax -> discard
    otherwise -> keep or discard
#+END_SRC

* definitions
** preconditions
  - =ext flow F exists=: (map ~External Flow ID~ over ~Flow table~) contains ~F~
  - =int flow F exists=: (map ~Internal Flow ID~ over ~Flow table~) contains ~F~
  - =the flow table not full=: length(~Flow table~) < ~CAPACITY~
  - =internal packet P comes=: `dpdk_receive` returns packet ~P~ attributed to the internal interface
  - =external packet P comes=: `dpdk_receive` returns packet ~P~ attributed to the external interface
** results
  - /packet P is forwarded/: `dpdk_transmit` is called with packet P with the same payload and header rewritten correspondingly to the flow table entry as specified in RFC3022 and the interface changed to the opposite one
  - /new flow allocated for packet P/: ~Flow table~' = ~Flow table~ ++ ~New flow~, where ~New flow~ features an ~External flow ID~ such that not(=ext flow exists=), and fields corresponding to packet P. ~New flow~ timestamp = ~now~
  - /packet is dropped/: no call for `dpdk_transmit` in this round
  - /flow F expiration timer is reset/: ~Flow table~' = replace(~F~ with ~Rejuvenated flow~ in ~Flow table~), where ~Rejuvenated flow~ has the same flow entry with ~timestamp~ = ~now~
  - /only flow F may be altered/: ~Flow table~' = X(~Flow table~), where X is either "add flow ~F~", "replace ~F~ with a flow of the same ~External flow ID~" or "noop"
  - /some flows expired/: ~Flow table~'=Expire(~Flow table~, ~now~)

* rules
#+BEGIN_SRC 
# Triggers:
 =Packet P comes=  -> P is internal -> F(P) exists       -> (1)
                                     -> not(F(P) exists) -> flow table is not full -> (2)
                                                         -> otherwise              -> (3)
                   -> P is external -> F(P) exists       -> (4)
                                     -> not(F(P) exists) -> (5)
 No packet comes   -> (6)
1. /flow ~F(P)~ expiration timer is reset/, /some flows expired/, /packet ~P~ is forwarded/
2. /new flow allocated for packet ~P~/, /packet ~P~ is forwarded/
3. /some flows expired/, may-be /new flow allocated for packet ~P~/, /packet ~P~ is forwarded/
4. /flow ~F(P)~ expiration timer is reset/, /some flows expired/, /packet ~P~ is forwarded/
5. /some flows expired/, /packet is dropped/
6. /some flows expired/

#+END_SRC

* abstraction function
Our NAPT keeps its dynamic state in two datastructures:
#+BEGIN_SRC 

Double map = list of <ext-flow-id, int-flow-id, flow-entry, index>
Allocator = list of <allocated index, timestamp>

# Abstraction function:

Flow table (time) <-
   forall (allocated index, timestamp) in Allocator
     such that (time < timestamp + Tmax)
     find (ext-flow-id, int-flow-id, flow-entry) in Double map
     collect (Flow entry(ext-flow-id + int-flow-id), timestamp)

#+END_SRC
