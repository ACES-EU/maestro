* parameters
This are external configuration parameters of the NAPT box
- ~CAPACITY~ - the maximum number of simultaneously active flows in the table
- ~Texp~ - the expiration time. If the last packet in the flow was less than ~Texp~ ago, the flow must be kept, otherwise it must be removed.

* NAPT abstract state
This defines the abstract representation of the NAPT dynamic state, that determines its behavior. Later we will connect real implementation state that is just a structured physical memory array with this abstract state using abstraction function.
Our NAPT abstraction refers to an internal host that is an endpoint on the internal (private) network connecting through the NAT box to an external host that is on the external (public) network.
We focus here only on the TCP and UDP, leaving out ICMP for simplicity.
#+BEGIN_SRC 
End_point := tuple<addr, port> -- IP address of a host and TCP/UDP port number

Flow_entry := tuple<int_src_ep : End_point, -- internal host end point (addr + port)
                    ext_src_ep : End_point, -- source end point for the packets as seen externally
                    dst_ep     : End_point, -- external host end point (addr + port)
                    protocol   : TCP/UDP>   -- protocol: TCP or UDP

Ext_flow_id := tuple<ext_src_ep,
                     dst_ep,
                     protocol>
Int_flow_id := tuple<int_src_ep,
                     dst_ep,
                     protocol>

flow_table := set of<Flow entry, Timestamp>
              unique in Ext_flow_id and Int_flow_id projections
#+END_SRC

* definitions
This section defines necessary terminology for specifying essential NAPT behavior cases.
** preconditions
These are the things that determine NAPT's behavior on every event (on every packet that comes in).
  - =Ext_flow_id F exists=: (projection ~Ext_flow_Id~ over ~flow_table~) contains ~F~
  - =Int_flow_id F exists=: (projection ~Int_flow_Id~ over ~flow_table~) contains ~F~
  - =the flow table not full=: length(~flow_table~) < ~CAPACITY~
  - =packet P comes=: `dpdk_receive` returns packet ~P~
  - =P is internal=: packet ~P~ is attributed to the internal interface
  - =P is external=: packet ~P~ is attributed to the external interface

** postconditions
This section defines possible transformation of the generalized state (NAPT abstract state + packets in the network) that NAPT may perform.
We divide all the postconditions into three domains:
1. Time related: handle flow expiration
2. Flow management: add new flows to the table, find existing ones
3. Packet forwarding: transmit or drop packets.

*** time related
#+BEGIN_SRC
Expire(flow_table, time) -> filter flow_table, keep only (flow, timestamp) where time < timestamp + Texp
#+END_SRC
- /some flows expired/: ~flow_table~' = Expire(~flow_table~, ~now~)
- /flow F expiration timer is reset/: ~flow_table~' = replace(~F~ with ~rejuvenated_flow~ in ~flow_table~), where ~rejuvenated_flow~ has the same flow entry with ~timestamp~ = ~now~
*** flow management
- /new flow allocated for packet P/: ~flow_table~' = ~flow_table~ ++ ~new_flow~, where not(=~Ext_flow_id~ (~new_flow~) flow exists=), if corresponds to packet P. ~timestamp~ (~new_flow~) = ~now~
*** packet forwarding
- /packet P is forwarded/: `dpdk_transmit` is called with packet ~P~ with the same payload and header rewritten according to ~F(P)~ as specified in RFC3022 and the network interface changed to the opposite one
- /packet is dropped/: no call for `dpdk_transmit` in this round

* rules
The rules are split into two parts: "precondition" -> "postcondition".
"Precondition" is an event and all the conditions that determine the next NAPT generalized state change.
"Postcondition" is the NAPT's response to that even. It describes the abstract state transformation (i.e. new flow in the table) and the reaction visible from the outside (i.e. outgoing packets)
** preconditions
This section describes the all the conditions that may trigger a NAPT action (i.e. generalized state change).
#+BEGIN_SRC 
Packet P comes  -> P is internal -> F(P) exists      -> (1)
                                 -> not(F(P) exists) -> flow table is not full -> (2)
                                                     -> otherwise              -> (3)
                -> P is external -> F(P) exists      -> (1)
                                 -> not(F(P) exists) -> (3)
No packet comes -> (6)
#+END_SRC

** postconditions
The postconditions chain the 3 groups of transformations described above. The transformations of different groups are separated by '|'. They allways follow as time-related|flow-management|packet-forwarding. Some of the groups may be abscent.

#+BEGIN_SRC 
1. /some flows expired/,
   /flow ~F(P)~ expiration timer is reset/ |                                     | /packet ~P~ is forwarded/
2. /some flows expired/                    | /new flow allocated for packet ~P~/ | /packet ~P~ is forwarded/
3. /some flows expired/                    |                                     | /packet is dropped/
#+END_SRC

* implementation specific state
Our NAPT keeps its dynamic state in two datastructures: Double map and Allocator. VeriFast proof lifts their physical representation into the following logical form:
#+BEGIN_SRC 
Double map = list of <ext-flow-id, int-flow-id, flow-entry, index>
Allocator = list of <allocated index, timestamp>
#+END_SRC

* abstraction function
This section is implementation specific, and defines an abstract function that transforms the implementation state into the defined above.
#+BEGIN_SRC 
Flow table (time) <-
   forall (allocated index, timestamp) in Allocator
     such that (time < timestamp + Tmax)
     find (ext-flow-id, int-flow-id, flow-entry) in Double map
     collect (Flow entry(ext-flow-id + int-flow-id), timestamp)

#+END_SRC
