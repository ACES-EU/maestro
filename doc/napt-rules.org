* parameters
These are external configuration parameters of the NAPT box
- ~CAPACITY~ -- maximum number of flows that a NAPT can forward simultaneously (keeping flow-specific information for each of them).
- ~T_EXP~ -- expiration time. Iff an active flow does not receive a new packet for ~T_EXP~ contiguous time units, the flow becomes inactive.
- ~EXT_ADDR~ â€“ the externally visible address of the NAPT box. All the connections going through NAPT will be seen from the external network as originating from this address.
* NAPT abstract state
This defines the abstract representation of the NAPT state. 
Our NAPT abstraction refers to an /internal host/ that is an endpoint on the internal (private) network connecting through the NAPT box to an /external host/ that is on the external (public) network.
We focus here only on TCP and UDP, leaving out ICMP for simplicity.
#+BEGIN_SRC haskell
End_point := tuple<addr, port> -- IP address of a host and TCP/UDP port number

-- The key identifying a Flow_entry for an externally-sourced packet.
Ext_flow_id := tuple<int_pub_ep : End_point, -- internal host end point as seen externally
                     ext_ep     : End_point, -- external host end point (addr + port)
                     protocol   : TCP/UDP>

-- The key identifying a Flow_entry for an internally-sourced packet.
Int_flow_id := tuple<int_priv_ep : End_point, -- internal host true end point (addr + port)
                     ext_ep      : End_point, -- external host end point (addr + port)
                     protocol    : TCP/UDP>

Flow_entry := tuple<int_flow_id : Int_flow_id, -- flow id, as seen in the public network
                    ext_flow_id : Ext_flow_id> -- flow id, as seen in the private network
              with invariant:
                   int_flow_id.ext_ep == ext_flow_id.int_ep and
                   int_flow_id.protocol == ext_flow_id.protocol

flow_table := set of<flow_entry : Flow_entry,
                     timestamp>
              such that flow_entry.int_flow_id and
                        flow_entry.ext_flow_id
              are unique across the whole set
#+END_SRC

* rules
The rules are split into two parts: "precondition" -> "postcondition".
"Precondition" is an event and all the conditions that determine the next NAPT generalized state change.
"Postcondition" is the NAPT's response to that event. It describes the abstract state transformation (i.e. new flow in the table) and the reaction visible from the outside (i.e. outgoing packets)
First we define the building blocks for both preconditions and postconditions, and then define the rules themselves.
** definitions
This section defines necessary terminology for specifying essential NAPT behavior cases.
*** precondition elements
These are the things that determine NAPT's behavior on every event (on every packet that comes in).
  - =Ext_flow_id F exists=: exists ~Flow_entry X~ in ~flow_table~ such that ~f.ext_flow_id~ == F
  - =Int_flow_id F exists=: exists ~Flow_entry X~ in ~flow_table~ such that ~f.int_flow_id~ == F
  - =the flow table not full=: size(~flow_table~) < ~CAPACITY~
  - =packet P arrives=: ~P~ arrives at one of the interfaces to the NAPT
  - =packet P is internal=: ~P~ arrives at the internal interface
  - =packet P is external=: ~P~ arrives at the external interface

*** postcondition elements
This section defines possible transformation of the generalized state (NAPT abstract state + packets in the network) that NAPT may perform.
We divide the postconditions into three categories:

**** time related (handle flow expiration)
#+BEGIN_SRC haskell
Expire(flow_table, time) -> maximum subset of flow_table, with time < timestamp + T_EXP
#+END_SRC
- /some flows are expired/: ~flow_table~' = Expire(~flow_table~, ~now~)
- /flow F is refreshed/: ~flow_table~' = replace(~F~ with ~rejuvenated_flow~ in ~flow_table~), where ~rejuvenated_flow~ has the same flow entry with ~timestamp~ = ~now~
**** flow management (add new flows to the table)
- /flow allocated for P/:
#+BEGIN_SRC haskell
 flow_table' = flow_table ++ new_flow, where
    new_flow.int_flow_id = P.flow_id, and
    not(Ext_flow_id new_flow.ext_flow_id exists), and
    new_flow.timestamp = now

#+END_SRC

**** packet forwarding (transmit or drop packets)
- /P is forwarded/: NAPT injects to the network packet ~P~ with the same payload and header rewritten according to ~F(P)~ as specified in RFC3022 and the network interface changed to the opposite one
- /packet is dropped/: do nothing, added for clarity

** preconditions
This section describes all the conditions that may trigger a NAPT reaction (i.e. generalized state change). The NAT will change abstract state and/or emit packets only if a precondition listed below holds.
#+BEGIN_SRC haskell 
Packet P arrives -> P is internal -> F(P) exists      -> (1)
                                  -> not(F(P) exists) -> flow table is not full -> (2)
                                                      -> otherwise              -> (3)
                 -> P is external -> F(P) exists      -> (1)
                                  -> not(F(P) exists) -> (3)
#+END_SRC

** postconditions
The postconditions chain the 3 groups of transformations described above. The transformations of different groups are separated by '|'. They are always in the same order: =time-related | flow-management | packet-forwarding=. Some of the groups may be absent.

#+BEGIN_SRC haskell 
1. /some flows are expired/,
   /flow F(P) is refreshed/ |                        | /P is forwarded/
2. /some flows are expired/ | /flow allocated for P/ | /P is forwarded/
3. /some flows are expired/ |                        | /packet is dropped/
#+END_SRC

* implementation specific state
Our NAPT keeps its dynamic state in two data-structures: Double Map and Allocator. We use Double Map to keep ~Flow_entry~'s accessible by both ~Ext_flow_id~ and ~Int_flow_id~. VeriFast proof lifts their physical representation into the following logical (intermediate) abstraction:
#+BEGIN_SRC haskell 
allocator = list of <allocated_index, timestamp>
            allocated_index'es are unique
double_map = list of <Ext_flow_id, Int_flow_id, Flow_entry, index>
             each flow_entry <=> (ext_flow_id + int_flow_id)
             each index is present in the allocator
#+END_SRC

* abstraction function
This section defines an abstraction function that transforms the implementation state into the abstract state.
#+BEGIN_SRC haskell 
Abstraction(double_map, allocator, time) ->
  forall (allocated_index, timestamp) in Allocator
    such that (time < timestamp + T_EXP) 
    find (ext_flow_id, int_flow_id, flow_entry, allocated_index) in double_map
    collect (flow_entry, timestamp)
#+END_SRC
