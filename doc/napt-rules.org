* parameters
These are external configuration parameters of the NAPT box
- ~CAPACITY~ -- maximum number of flows that a NAPT can forward simultaneously (keeping flow-specific information for each of them).
- ~T_EXP~ -- expiration time. Iff an active flow does not receive a new packet for ~T_EXP~ contiguous time units, the flow becomes inactive.
- ~EXT_ADDR~ â€“ the externally visible address of the NAPT box. All the connections going through NAPT will be seen from the external network as originating from this address.
* NAPT abstract state
This defines the abstract representation of the NAPT state. 
Our NAPT abstraction refers to an /internal host/ that is an endpoint on the internal (private) network connecting through the NAPT box to an /external host/ that is on the external (public) network.
We focus here only on TCP and UDP, leaving out ICMP for simplicity.
#+BEGIN_SRC haskell
End_point := tuple<addr, port> -- IP address of a host and TCP/UDP port number

-- The key identifying a Flow_entry for an externally-sourced packet.
Ext_flow_id := tuple<int_pub_ep : End_point, -- internal host end point as seen externally
                     ext_ep     : End_point, -- external host end point (addr + port)
                     protocol   : TCP/UDP>

-- The key identifying a Flow_entry for an internally-sourced packet.
Int_flow_id := tuple<int_priv_ep : End_point, -- internal host true end point (addr + port)
                     ext_ep      : End_point, -- external host end point (addr + port)
                     protocol    : TCP/UDP>

Flow_entry := tuple<int_flow_id : Int_flow_id, -- flow id, as seen in the public network
                    ext_flow_id : Ext_flow_id> -- flow id, as seen in the private network
              with invariant:
                   int_flow_id.ext_ep == ext_flow_id.int_ep and
                   int_flow_id.protocol == ext_flow_id.protocol

Flow_table := set of<flow_entry : Flow_entry,
                     timestamp>
              such that flow_entry.int_flow_id and
                        flow_entry.ext_flow_id
              are unique across the whole set

Network_interface := tuple<incast_packet, -- represents a new packet that arrives at the NAPT
                           outcast_packet> -- represent a just forwarded packet, that NAPT injects

state := tuple<flow_entry : Flow_entry,
               network    : Network_interface>
#+END_SRC

* rules
The rules are split into two parts: "precondition" -> "postcondition".
"Precondition" is an event and all the conditions that determine the next NAPT state change.
"Postcondition" is the NAPT's response to that event. It describes the abstract state transformation (i.e. new flow in the table) and the reaction visible from the outside (i.e. outgoing packets)
First we define the building blocks for both preconditions and postconditions, and then define the rules themselves.
** definitions
This section defines necessary terminology for specifying essential NAPT behavior cases.
*** precondition elements
These are the things that determine NAPT's behavior on every event (on every packet that comes in).
  - =Ext_flow_id F exists=: exists ~Flow_entry X~ in ~flow_table~ such that ~f.ext_flow_id~ == F
  - =Int_flow_id F exists=: exists ~Flow_entry X~ in ~flow_table~ such that ~f.int_flow_id~ == F
  - =the flow table not full=: size(~flow_table~) < ~CAPACITY~
  - =packet P arrives=: ~network.incast_packet~ contains ~P~
  - =packet P is internal=: ~P~.interface = external
  - =packet P is external=: ~P~.interface = internal

*** postcondition elements
This section defines possible transformation of the state that NAPT may perform.
We divide the postconditions into three categories:

**** expiration
#+BEGIN_SRC haskell
Expire(flow_table, time) -> maximum subset of flow_table, with time < timestamp + T_EXP
#+END_SRC
- /some flows are expired/: ~flow_table~' = Expire(~flow_table~, ~now~)

**** flow management (add new flows to the table)
- /flow F is refreshed/: ~flow_table~' = replace(~F~ with ~rejuvenated_flow~ in ~flow_table~), where ~rejuvenated_flow~ has the same flow entry with ~timestamp~ = ~now~
- /flow allocated for P/:
#+BEGIN_SRC haskell
 flow_table' = flow_table ++ new_flow, where
    new_flow.int_flow_id = P.flow_id, and
    not(Ext_flow_id new_flow.ext_flow_id exists), and
    new_flow.timestamp = now
#+END_SRC

**** packet forwarding (transmit or drop packets)
- /P is forwarded/: ~network.outcast_packet~ = ~P~
- /P is accepted/: ~network.incast_packet~ = nil

** rules
#+BEGIN_SRC haskell
-- All NAPT scenarios follow the same general script:
Packet P arrives ->
  P is accepted ->
  some flows are expired ->
  {flow-management} ->
  {forwarding}

{flow-management}:
P is internal -> F(P) exists      -> flow F(P) is refreshed
                 not(F(P) exists) -> flow table is not full -> flow allocated for P
P is external -> F(P) exists      -> flow F(P) is refreshed

{forwarding}:
P is internal -> F(P) exists -> /packet P is forwarded/
P is external -> F(P) exists -> /packet P is forwarded/
#+END_SRC

* implementation specific state
Our NAPT keeps its dynamic state in two data-structures: Double Map and Allocator. We use Double Map to keep ~Flow_entry~'s accessible by both ~Ext_flow_id~ and ~Int_flow_id~. VeriFast proof lifts their physical representation into the following logical (intermediate) abstraction:
#+BEGIN_SRC haskell 
allocator = list of <allocated_index, timestamp>
            allocated_index'es are unique
double_map = list of <Ext_flow_id, Int_flow_id, Flow_entry, index>
             each flow_entry <=> (ext_flow_id + int_flow_id)
             each index is present in the allocator
#+END_SRC

* abstraction function
This section defines an abstraction function that transforms the implementation state into the abstract state.
#+BEGIN_SRC haskell 
Abstraction(double_map, allocator, time) ->
  forall (allocated_index, timestamp) in Allocator
    such that (time < timestamp + T_EXP) 
    find (ext_flow_id, int_flow_id, flow_entry, allocated_index) in double_map
    collect (flow_entry, timestamp)
#+END_SRC
