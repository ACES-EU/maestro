#ifndef STDEX_GH
#define STDEX_GH

#include <nat.gh>
#include <listex.gh>
#include "listexex.gh"
#include "set.gh"
#include "multiset.gh"
#include "multisubset.gh"


fixpoint t get_some<t>(option<t> x) {
  switch(x) {
    case none: return default_value<t>();
    case some(v): return v;
  }
}

lemma void some_get_some<t>(option<t> x)
requires x != none;
ensures some(get_some(x)) == x;
{
  switch(x) {
    case none: break;
    case some(v): break;
  }
}

fixpoint bool no_dups<t>(list<t> l) {
  switch(l) {
    case nil: return true;
    case cons(h,t):
      return (!mem(h,t)) &&
      no_dups(t);
  }
}


fixpoint bool ge(int x, int y) { return x <= y; }

fixpoint bool lt(int x, int y) { return y < x; }

lemma void ge_le_ge(list<int> l, int i, int x)
requires x <= i &*& true == forall(l, (ge)(i));
ensures true == forall(l, (ge)(x));
{
  switch(l) {
    case nil:
    case cons(h,t):
      ge_le_ge(t, i, x);
  }
}

fixpoint bool opt_no_dups<t>(list<option<t> > l) {
  switch(l) {
    case nil: return true;
    case cons(h,t):
      return opt_no_dups(t) && (h == none || !(mem(h, t)));
  }
}

lemma void less_and_not_eq_lesser(nat x, nat lim)
requires int_of_nat(x) < int_of_nat(succ(lim)) &*&
         x != lim;
ensures int_of_nat(x) < int_of_nat(lim);
{
  switch(x) {
    case zero:
      switch(lim) {
        case zero:
        case succ(ln):
      }
    case succ(xn):
      switch(lim) {
        case zero:
        case succ(ln):
          less_and_not_eq_lesser(xn,ln);
      }
  }
}

fixpoint bool nat_ge(int x, nat y) { return x <= int_of_nat(y); }

fixpoint bool nat_lt(int x, nat y) { return int_of_nat(y) < x; }

fixpoint t3 sup<t1,t2,t3>(fixpoint (t2,t3) f1, fixpoint (t1,t2) f2, t1 x) {
  return f1(f2(x));
}

lemma void forall_sup_map<t1,t2>(list<t1> l,
                                 fixpoint (t2,bool) f1,
                                 fixpoint (t1,t2) f2)
requires true;
ensures forall(l, (sup)(f1, f2)) == forall(map(f2, l), f1);
{
  switch(l) {
    case nil:
    case cons(h,t):
      forall_sup_map(t, f1, f2);
  }
}

// Workaround for unmindful Redux solver.
// See https://github.com/verifast/verifast/issues/19
lemma void note(bool b)
requires b;
ensures b;
{}

#endif//STDEX_GH
