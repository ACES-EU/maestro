#ifndef MULTISET_GH
#define MULTISET_GH

#include "set.gh"

fixpoint bool multiset_eq<t>(list<t> l1, list<t> l2) {
  switch(l1) {
    case nil:
      return l2 == nil;
    case cons(h,t):
      return true == mem(h, l2) && multiset_eq(t, remove(h, l2));
  }
}

lemma void multiset_eq_unremove<t>(list<t> l1, list<t> l2, t x)
requires true == mem(x, l1) &*& 
         true == multiset_eq(remove(x, l1), l2);
ensures true == multiset_eq(l1, cons(x, l2));
{
  switch(l1) {
    case nil:
    case cons(h,t):
      if (x != h) multiset_eq_unremove(t, remove(h, l2), x);
  }
}

lemma void multiset_eq_comm<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures true == multiset_eq(l2, l1);
{
  switch(l1) {
    case nil:
    case cons(h,t):
      multiset_eq_comm(t, remove(h, l2));
      assert true == multiset_eq(remove(h, l2), t);
      multiset_eq_unremove(l2, t, h);
      assert true == multiset_eq(l2, l1);
  }
}

lemma void subset_unremove_outer<t>(list<t> xs, list<t> ys, t el)
requires true == subset(xs, remove(el, ys));
ensures true == subset(xs, ys);
{
  switch(xs) {
    case nil:
    case cons(h,t):
      if (h!=el)
      neq_mem_remove(h, el, t);
      subset_unremove_outer(t, ys, el);
      mem_remove_mem(h, el, ys);
  }
}

lemma void multiset_eq_subset<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures true == subset(l1, l2);
{
  switch(l1) {
    case nil:
    case cons(h,t):
      multiset_eq_subset(t, remove(h, l2));
      assert true == subset(t, remove(h, l2));
      subset_unremove_outer(t, l2, h);
      assert true == subset(l1, l2);
  }
}

lemma void multiset_eq_set_eq<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures true == set_eq(l1, l2);
{
  multiset_eq_subset(l1, l2);
  multiset_eq_comm(l1, l2);
  multiset_eq_subset(l2, l1);
}

lemma void distinct_set_eq_multiset_eq<t>(list<t> l1, list<t> l2)
requires true == set_eq(l1, l2) &*&
         true == distinct(l1) &*&
         true == distinct(l2);
ensures true == multiset_eq(l1, l2);
{
  switch(l1) {
    case nil:
      subset_nil_nil(l2);
    case cons(h,t):
      remove_still_distinct(l2, h);
      set_eq_remove_both(l1, l2, h);
      distinct_set_eq_multiset_eq(t, remove(h, l2));
      true == multiset_eq(t, remove(h, l2));
      assert true == mem(h, l2);
  }
}

lemma void multiset_eq_refl<t>(list<t> l)
requires true;
ensures true == multiset_eq(l, l);
{
  switch(l) {
    case nil:
    case cons(h,t):
      multiset_eq_refl(t);
  }
}

lemma void cons_in_the_middle_multiset_eq<t>(list<t> l1, list<t> l2, t x)
requires true;
ensures true == multiset_eq(append(l1, cons(x, l2)), cons(x, append(l1, l2)));
{
  switch(l1) {
    case nil:
      multiset_eq_refl(cons(x, l2));
    case cons(h,t):
      cons_in_the_middle_multiset_eq(t, l2, x);
  }
}

lemma void multiset_eq_same_len<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures length(l1) == length(l2);
{
  switch(l1) {
    case nil:
    case cons(h,t):
      length_remove(h, l2);
      multiset_eq_same_len(t, remove(h, l2));
  }
}

lemma void multiset_eq_append_both<t>(list<t> l1, list<t> l2, list<t> l3)
requires true == multiset_eq(l1, l2);
ensures true == multiset_eq(append(l1, l3), append(l2, l3));
{
  switch(l1) {
    case nil:
      multiset_eq_refl(l3);
    case cons(h,t):
      multiset_eq_append_both(t, remove(h, l2), l3);
      assert true == mem(h, append(l2, l3));
      append_remove_first(l2, l3, h);
      assert remove(h, append(l2, l3)) == append(remove(h, l2), l3);
  }
}

#endif//MULTISET_GH
