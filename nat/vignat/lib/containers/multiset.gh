#ifndef MULTISET_GH
#define MULTISET_GH

#include "set.gh"

fixpoint bool multiset_eq<t>(list<t> l1, list<t> l2) {
  switch(l1) {
    case nil:
      return l2 == nil;
    case cons(h,t):
      return true == mem(h, l2) && multiset_eq(t, remove(h, l2));
  }
}

lemma void multiset_eq_unremove<t>(list<t> l1, list<t> l2, t x)
requires true == mem(x, l1) &*& 
         true == multiset_eq(remove(x, l1), l2);
ensures true == multiset_eq(l1, cons(x, l2));
{
  switch(l1) {
    case nil:
    case cons(h,t):
      if (x != h) multiset_eq_unremove(t, remove(h, l2), x);
  }
}

lemma void multiset_eq_comm<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures true == multiset_eq(l2, l1);
{
  switch(l1) {
    case nil:
    case cons(h,t):
      multiset_eq_comm(t, remove(h, l2));
      assert true == multiset_eq(remove(h, l2), t);
      multiset_eq_unremove(l2, t, h);
      assert true == multiset_eq(l2, l1);
  }
}

lemma void subset_unremove_outer<t>(list<t> xs, list<t> ys, t el)
requires true == subset(xs, remove(el, ys));
ensures true == subset(xs, ys);
{
  switch(xs) {
    case nil:
    case cons(h,t):
      if (h!=el)
      neq_mem_remove(h, el, t);
      subset_unremove_outer(t, ys, el);
      mem_remove_mem(h, el, ys);
  }
}

lemma void multiset_eq_subset<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures true == subset(l1, l2);
{
  switch(l1) {
    case nil:
    case cons(h,t):
      multiset_eq_subset(t, remove(h, l2));
      assert true == subset(t, remove(h, l2));
      subset_unremove_outer(t, l2, h);
      assert true == subset(l1, l2);
  }
}

lemma void multiset_eq_set_eq<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures true == set_eq(l1, l2);
{
  multiset_eq_subset(l1, l2);
  multiset_eq_comm(l1, l2);
  multiset_eq_subset(l2, l1);
}

lemma void distinct_set_eq_multiset_eq<t>(list<t> l1, list<t> l2)
requires true == set_eq(l1, l2) &*&
         true == distinct(l1) &*&
         true == distinct(l2);
ensures true == multiset_eq(l1, l2);
{
  switch(l1) {
    case nil:
      subset_nil_nil(l2);
    case cons(h,t):
      remove_still_distinct(l2, h);
      set_eq_remove_both(l1, l2, h);
      distinct_set_eq_multiset_eq(t, remove(h, l2));
      true == multiset_eq(t, remove(h, l2));
      assert true == mem(h, l2);
  }
}

lemma void multiset_eq_refl<t>(list<t> l)
requires true;
ensures true == multiset_eq(l, l);
{
  switch(l) {
    case nil:
    case cons(h,t):
      multiset_eq_refl(t);
  }
}

lemma void cons_in_the_middle_multiset_eq<t>(list<t> l1, list<t> l2, t x)
requires true;
ensures true == multiset_eq(append(l1, cons(x, l2)), cons(x, append(l1, l2)));
{
  switch(l1) {
    case nil:
      multiset_eq_refl(cons(x, l2));
    case cons(h,t):
      cons_in_the_middle_multiset_eq(t, l2, x);
  }
}

lemma void multiset_eq_same_len<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures length(l1) == length(l2);
{
  switch(l1) {
    case nil:
    case cons(h,t):
      length_remove(h, l2);
      multiset_eq_same_len(t, remove(h, l2));
  }
}

lemma void multiset_eq_append_both<t>(list<t> l1, list<t> l2, list<t> l3)
requires true == multiset_eq(l1, l2);
ensures true == multiset_eq(append(l1, l3), append(l2, l3));
{
  switch(l1) {
    case nil:
      multiset_eq_refl(l3);
    case cons(h,t):
      multiset_eq_append_both(t, remove(h, l2), l3);
      assert true == mem(h, append(l2, l3));
      append_remove_first(l2, l3, h);
      assert remove(h, append(l2, l3)) == append(remove(h, l2), l3);
  }
}

lemma void multiset_eq_map<t1,t2>(fixpoint (t1,t2) f,
                                  list<t1> l1,
                                  list<t1> l2)
requires true == multiset_eq(l1, l2);
ensures true == multiset_eq(map(f, l1), map(f, l2));
{
  assume(false);//TODO 
}

lemma void multiset_eq_distinct<t>(list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures distinct(l1) == distinct(l2);
{
  assume(false);//TODO 
}



lemma void multiset_eq_forall<t>(list<t> l1, list<t> l2, fixpoint (t,bool) f)
requires true == multiset_eq(l1, l2);
ensures forall(l1, f) == forall(l2, f);
{
  assume(false);//TODO 
}




lemma void multiset_eq_append_assoc<t>(list<t> l1, list<t> l2, list<t> l3)
requires true;
ensures true == multiset_eq(append(append(l1, l2), l3),
                            append(l1, append(l2, l3)));
{
  assume(false);//TODO 
}




lemma void multiset_eq_append<t>(list<t> l1, list<t> l2,
                                 list<t> l3, list<t> l4)
requires true == multiset_eq(l1, l2) &*&
         true == multiset_eq(l3, l4);
ensures true == multiset_eq(append(l1, l3), append(l2, l4));
{
  assume(false);//TODO 
}




lemma void multiset_eq_append_comm<t>(list<t> l1, list<t> l2)
requires true;
ensures true == multiset_eq(append(l1, l2), append(l2, l1));
{
  assume(false);//TODO 
}




lemma void multiset_eq_trans<t>(list<t> l1, list<t> l2, list<t> l3)
requires true == multiset_eq(l1, l2) &*&
         true == multiset_eq(l2, l3);
ensures true == multiset_eq(l1, l3);
{
  assume(false);//TODO 
}

lemma void multiset_eq_map_cons_remove<t1,t2>(fixpoint (t1,t2) f,
                                              list<t1> l,
                                              t1 x, t1 y)
requires true == mem(x, l) &*& f(x) == f(y);
ensures true == multiset_eq(map(f, l),
                            map(f, cons(y, remove(x, l))));
{
  switch(l) {
    case nil:
    case cons(h,t):
      if (h == x) {
        multiset_eq_refl(map(f, l));
      }
      else {
        multiset_eq_map_cons_remove(f, t, x, y);
      }
  }
}

lemma void map_remove_swap<t1,t2>(fixpoint (t1,t2) f,
                                  t1 x, list<t1> l)
requires true == mem(x, l);
ensures true == multiset_eq(remove(f(x), map(f, l)),
                            map(f, remove(x, l)));
{
  switch(l) {
    case nil:
    case cons(h,t):
      if (h == x) {
        multiset_eq_refl(map(f, remove(x, l)));
      } else {
        if (f(h) == f(x)) {
          multiset_eq_map_cons_remove(f, t, x, h);
        } else {
          map_remove_swap(f, x, t);
        }
      }
  }
}//took 40m


lemma void multiset_eq_mem<t>(t x, list<t> l1, list<t> l2)
requires true == multiset_eq(l1, l2);
ensures mem(x, l1) == mem(x, l2);
{
  assume(false);//TODO 5m
}


#endif//MULTISET_GH
