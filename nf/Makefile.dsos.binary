### Use this to build an executable DSOS image

SHELL := /bin/bash -O extglob -c
export RTE_TARGET = x86_64-native-linuxapp-gcc

CC = x86_64-elf-gcc
NASM = nasm
QEMU = qemu-system-x86_64

ARCH = x86_64
BINARY = dsos-$(ARCH).bin
ISO = dsos-$(ARCH).iso

LINKER_SCRIPT = linker.ld
GRUB_CFG = grub.cfg
LIBC = libc.a

NF_DIR = .
CONTAINERS_DIR = lib/containers
STUBS_DIR = lib/stubs
KERNEL_DIR = lib/kernel
NAT_DIR = vignat
BRIDGE_DIR = vigbridge
NOP_DIR = unverified-nop

# NAT
NAT_SOURCES := $(NAT_DIR)/nat_main.c \
	$(NAT_DIR)/nat_config.c \
	$(NAT_DIR)/flow.h.gen.c \
	$(NAT_DIR)/nat_state.c \
	$(NAT_DIR)/nat_flowmanager.c

# Bridge
BRIDGE_SOURCES := $(BRIDGE_DIR)/bridge_main.c \
	$(BRIDGE_DIR)/bridge_config.c \
	$(BRIDGE_DIR)/bridge_state.c \
	$(BRIDGE_DIR)/dyn_value.h.gen.c \
	$(BRIDGE_DIR)/stat_key.h.gen.c

#NOP
NOP_SOURCES = $(NOP_DIR)/nop_main.c
NOP_SOURCES += $(NOP_DIR)/nat_config.c

NF_DEFS := -D_GNU_SOURCE
# Distinguish this build from verify-hardware run
NF_DEFS += -DDSOS

# NF
NF_INCLUDES = -I $(NF_DIR)
NF_INCLUDES += -I src
NF_INCLUDES += -I $(RTE_SDK)/lib/librte_cmdline
NF_INCLUDES += -I /usr/lib/gcc/x86_64-linux-gnu/5/include
NF_INCLUDES += -I /usr/local/include
NF_INCLUDES += -I /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed
NF_INCLUDES += -I /usr/include/x86_64-linux-gnu
NF_INCLUDES += -I /usr/include

# NF_ARGUMENTS=-DNF_ARGUMENTS='"vignat", "--no-shconf", "--", "--lan-dev", "0", "--wan", "1", "--expire", "60000000000", "--starting-port", "0", "--max-flows", "65536", "--extip", "0.0.0.0", "--eth-dest", "0,01:23:45:67:89:00", "--eth-dest", "1,01:23:45:67:89:01"'

NF_ARGUMENTS=-DNF_ARGUMENTS='"vigbridge", "--no-shconf", "--", "--expire", "60000000000", "--capacity", "65536"'


NF_DEFS += $(NF_ARGUMENTS)

NF_SOURCES := $(NF_DIR)/nf_main.c \
	$(NF_DIR)/lib/nf_util.c \
	$(NF_DIR)/lib/nf_time.c \
	$(NF_DIR)/lib/packet-io.c \
	$(wildcard $(RTE_SDK)/lib/librte_cmdline/*.c) \
	$(CONTAINERS_DIR)/map.c \
	$(CONTAINERS_DIR)/map-impl.c \
	$(CONTAINERS_DIR)/double-map.c \
	$(CONTAINERS_DIR)/double-chain.c \
	$(CONTAINERS_DIR)/double-chain-impl.c \
	$(CONTAINERS_DIR)/vector.c \
	$(NF_DIR)/lib/expirator.c

# For NAT debug output
# NF_DEFS += -DENABLE_LOG


# DPDK
DPDK_INCLUDES = -I $(RTE_SDK)/include/dpdk
DPDK_INCLUDES += -I $(RTE_SDK)/lib/librte_eal/common
DPDK_INCLUDES += -I $(RTE_SDK)/drivers/bus/vdev
DPDK_INCLUDES += -I $(RTE_SDK)/drivers/bus/pci
DPDK_INCLUDES += -I $(RTE_SDK)/drivers/net/ixgbe
DPDK_INCLUDES += -I $(RTE_SDK)/lib/librte_kni
DPDK_INCLUDES += --include=$(STUBS_DIR)/builtin_stub.h --include=rte_config.h
# DPDK_INCLUDES += --include=rte_config.h

DPDK_DEFS := -D__linux__ -U_FORTIFY_SOURCE
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_SSE
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_SSE2
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_SSE3
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_SSSE3
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_SSE4_1
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_SSE4_2
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_AES
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_PCLMULQDQ
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_AVX
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_RDRAND
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_FSGSBASE
DPDK_DEFS += -DRTE_MACHINE_CPUFLAG_F16C
DPDK_DEFS += -DRTE_COMPILE_TIME_CPUFLAGS=RTE_CPUFLAG_SSE,RTE_CPUFLAG_SSE2,RTE_CPUFLAG_SSE3,RTE_CPUFLAG_SSSE3,RTE_CPUFLAG_SSE4_1,RTE_CPUFLAG_SSE4_2,RTE_CPUFLAG_AES,RTE_CPUFLAG_PCLMULQDQ,RTE_CPUFLAG_AVX,RTE_CPUFLAG_RDRAND,RTE_CPUFLAG_FSGSBASE,RTE_CPUFLAG_F16C

DPDK_SRCS += $(wildcard $(RTE_SDK)/lib/librte_eal/common/*.c)
DPDK_SRCS += $(RTE_SDK)/lib/librte_eal/common/arch/x86/rte_cycles.c
DPDK_SRCS += $(RTE_SDK)/lib/librte_eal/common/arch/x86/rte_cpuflags.c
DPDK_SRCS += $(wildcard $(RTE_SDK)/lib/librte_eal/linuxapp/eal/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/lib/librte_ether/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/lib/librte_hash/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/lib/librte_mempool/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/lib/librte_mbuf/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/lib/librte_pci/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/lib/librte_ring/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/drivers/mempool/ring/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/drivers/bus/pci/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/drivers/bus/pci/linux/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/drivers/net/ixgbe/*.c)
DPDK_SRCS += $(wildcard $(RTE_SDK)/drivers/net/ixgbe/base/*.c)
DPDK_SRCS := $(filter-out $(RTE_SDK)/drivers/net/ixgbe/ixgbe_82599_bypass.c, $(DPDK_SRCS))
DPDK_SRCS := $(filter-out $(RTE_SDK)/drivers/net/ixgbe/ixgbe_rxtx_vec_sse.c, $(DPDK_SRCS))
DPDK_SRCS := $(filter-out $(RTE_SDK)/drivers/net/ixgbe/ixgbe_bypass.c, $(DPDK_SRCS))
DPDK_SRCS := $(filter-out $(RTE_SDK)/drivers/net/ixgbe/ixgbe_rxtx_vec_neon.c, $(DPDK_SRCS))

# Stubs
STUBS_SRCS := $(wildcard $(STUBS_DIR)/*.c)
STUBS_SRCS += $(wildcard $(STUBS_DIR)/externals/*.c)
STUBS_SRCS := $(filter-out $(STUBS_DIR)/packet-io-stub.c, $(STUBS_SRCS))
STUBS_SRCS := $(filter-out $(STUBS_DIR)/time_stub.c, $(STUBS_SRCS))
STUBS_SRCS := $(filter-out $(STUBS_DIR)/hardware_stub.c, $(STUBS_SRCS))
STUBS_SRCS := $(filter-out $(STUBS_DIR)/driver_stub.c, $(STUBS_SRCS))
STUBS_SRCS := $(filter-out $(STUBS_DIR)/dpdk_low_level_stub.c, $(STUBS_SRCS))
STUBS_SRCS := $(filter-out $(STUBS_DIR)/dpdk_mempool_singleton.c, $(STUBS_SRCS))

KERNEL_SRCS := $(wildcard $(KERNEL_DIR)/*.c)

KERNEL_INCLUDES := -I $(KERNEL_DIR)

# For DSOS debug output on the VGA buffer
KERNEL_DEFS := -DDSOS_DEBUG

# OTHER_INCLUDES := -I include --include include/misc_defs.h
OTHER_INCLUDES := -I lib/stubs -I lib --include $(NF_DIR)/lib/misc_defs.h

C_SRCS = $(BRIDGE_SOURCES) $(NF_SOURCES) $(DPDK_SRCS) $(STUBS_SRCS) $(KERNEL_SRCS)
C_OBJS := $(patsubst %.c, %.o, $(C_SRCS))

BOOT_SRCS = $(KERNEL_DIR)/asm/multiboot_header.asm $(KERNEL_DIR)/asm/boot.asm
BOOT_OBJS := $(patsubst %.asm, %.o, $(BOOT_SRCS))

CFLAGS := -march=native -ffreestanding -flto -O3

CRTI_SRC = $(KERNEL_DIR)/asm/crti.asm
CRTI_OBJ := $(patsubst %.asm, %.o, $(CRTI_SRC))
CRTBEGIN_OBJ := $(shell $(CC) $(CFLAGS) -print-file-name=crtbegin.o)
CRTEND_OBJ := $(shell $(CC) $(CFLAGS) -print-file-name=crtend.o)
CRTN_SRC = $(KERNEL_DIR)/asm/crtn.asm
CRTN_OBJ := $(patsubst %.asm, %.o, $(CRTN_SRC))


# The order is important
OBJS = $(BOOT_OBJS) $(CRTI_OBJ) $(CRTBEGIN_OBJ) $(C_OBJS) $(CRTEND_OBJ) $(CRTN_OBJ)

DEFS = $(NF_DEFS) $(DPDK_DEFS) $(KERNEL_DEFS)
INCLUDES = $(NF_INCLUDES) $(DPDK_INCLUDES) $(OTHER_INCLUDES) $(KERNEL_INCLUDES)

NASMFLAGS = -felf64
LDFLAGS = -T $(LINKER_SCRIPT) -nostdlib -Wl,--nmagic
LIBS = -lgcc

QEMUFLAGS = -enable-kvm -cdrom $(ISO) -cpu host -m 1G
#QEMUFLAGS += -curses
QEMUFLAGS += -nographic
QEMUFLAGS += -device vfio-pci,host=06:00.0
QEMUFLAGS += -device vfio-pci,host=06:00.1
# QEMUFLAGS += -no-hpet -nodefaults -no-acpi -vga std
# QEMUFLAGS += -object memory-backend-file,id=mem,prealloc=on,size=1G,mem-path=/mnt/huge1GB

.PHONY: all clean run iso kernel

all: $(BINARY)

# We can't remove CRT{BEGIN,END}_OBJ because they're system-provided
clean:
	@rm -f $(C_OBJS) $(BOOT_OBJS) $(CRTI_OBJ) $(CRTN_OBJ)

# Launch QEMU
run: $(ISO)
	@sudo $(QEMU) $(QEMUFLAGS)

# Launch QEMU and attach debugger
debug: $(ISO)
	@sudo $(QEMU) -s -S $(QEMUFLAGS) > /dev/null 2>&1 &
	@sudo gdb -ex "set arch i386:x86-64:intel" \
		-ex "target remote localhost:1234" \
		-ex "symbol-file $(BINARY)" \
		-ex "hb main" \
		-ex "c" \
		-ex "d 1" \
		-ex "disconnect" \
		-ex "set arch i386:x86-64" \
		-ex "target remote localhost:1234" \
		-ex "b exit" \
		-ex "b abort" \
		-ex "b __assert_fail"

	@sudo kill `pidof qemu-system-x86_64`

iso: $(ISO)

# Make bootable iso image
$(ISO): $(BINARY) $(GRUB_CFG)
	@mkdir -p build/isofiles/boot/grub
	@cp $(BINARY) build/isofiles/boot/kernel.bin
	@cp $(GRUB_CFG) build/isofiles/boot/grub
	@grub-mkrescue -o $(ISO) build/isofiles 2> /dev/null
	@rm -r build/isofiles

# Link final executable
$(BINARY): $(OBJS) $(LIBC)
	$(CC) -o $@ $(CFLAGS) $(LDFLAGS) $(OBJS) $(LIBC) $(LIBS)

# Assembly files
%.o: %.asm
	$(NASM) $(NASMFLAGS) $< -o $@

# C files
%.o: %.c
	$(CC) -c $(CFLAGS) $(DEFS) $(INCLUDES) $< -o $@
