//@ #include <bitops.gh>
/*@
	inductive lpm_key = key(list<int>, int);
	inductive lpm_rule_24 = next_hop(int, int) | index_long(int, int) | empty;
	inductive lpm_rule_long = next_hop(int, int) | empty;

	//next_hop(int, int) and index_long(int, int) -> ....(prefixlen, value)

	inductive dir_24_8 = tables(list<list<lpm_rule_24> >, list<list<lpm_rule_long> >);


	fixpoint key init_key(list<int> ipv4, int prefixlen){
		return key(ipv4, prefixlen);
	}

	fixpoint list<int> key_ipv4(lpm_key key){
		switch(key){
			case key(ipv4, prefixlen): return ipv4;
		}
	}

	fixpoint int key_prefixlen(lpm_key key){
		switch(key){
			case key(ipv4, prefixlen): return prefixlen;
		}
	}
// LOOKUP FUNCTIONS
	fixpoint lpm_rule_24 lookup_tbl_24(int index, dir_24_8 dir){
		switch(dir){
		    case(tables(tbl_24, tbl_long)): return nth(0,nth(index, tbl_24));
		}
	}

	fixpoint lpm_rule_long lookup_tbl_long(int index, dir_24_8 dir){
		switch(dir){
		    case(tables(tbl_24, tbl_long)): return nth(0, nth(index, tbl_long));
		}
	}

	fixpoint option<int> lpm_dir_24_8_lookup(dir_24_8 dir, list<int> ipv4){
		switch(dir){
			case tables(tbl_24, tbl_long): 
				switch(lookup_tbl_24(index24_from_ipv4(ipv4), dir)){
					case next_hop(_, next_24): return some(next_24);
					case index_long(_, index):
						switch(lookup_tlb_long(indexlong_from_ipv4(ipv4, index))){
							case next_hop(_, next_long): return some(next_long);
							case empty: return none;
						}
					case empty: return none;
				}
		}
	}

	fixpoint int index24_from_ipv4(list<int> ipv4){
		switch(ipv4){
			case nil: return 0;
			case cons(v, cs0): return (v << length(cs0)) | index24_from_ipv4(cs0);
		}
	}

	fixpoint int indexlong_from_ipv4

// ADD ROUTE FUNCTIONS
@*/
