#include "lib/stubs/hardware_stub.h"

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "rte_cycles.h" // to include the next one cleanly
#include "generic/rte_cycles.h" // for rte_delay_us_callback_register

#include <klee/klee.h>


typedef uint32_t (*stub_register_read)(struct stub_device* dev, uint32_t current_value);
typedef uint32_t (*stub_register_write)(struct stub_device* dev, uint32_t current_value, uint32_t new_value);

struct stub_register {
	bool present; // to distinguish registers we model from others
	uint32_t initial_value;
	bool readable;
	uint32_t writable_mask; // 0 = readonly, 1 = writeable
	stub_register_read read; // possibly NULL
	stub_register_write write; // possibly NULL
};

static struct stub_register REGISTERS[0x20000]; // index == address

// Incremented at each delay; in nanoseconds.
static uint64_t TIME;


// Helper bit macros
#define GET_BIT(n, k) (((n) >> (k)) & 1)
#define SET_BIT(n, k, v) if (v == 0) { n = (n & ~(1 << (k))); } else { n = (n | (1 << (k))); }

// Helper register macros
#define DEV_MEM(dev, offset, type) *((type*) (dev->mem_shadow + (offset)))
#define DEV_REG(dev, offset) DEV_MEM(dev, offset, uint32_t)


// Unless otherwise stated, all citations here refer to
// https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/82599-10-gbe-controller-datasheet.pdf


static void
stub_delay_us(unsigned int us)
{
klee_print_expr("DELAY", us);
	TIME += us * 1000 ; // TIME is in ns
}


static void
stub_device_reset(struct stub_device* dev)
{
	for (int n = 0; n < sizeof(REGISTERS)/sizeof(REGISTERS[0]); n++) {
		DEV_REG(dev, n) = REGISTERS[n].initial_value;
	}

	dev->current_mdi_address = -1;
}


// RW1C means a register can be read, and bits can be cleared by writing 1
static uint32_t
stub_register_rw1c_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	for (int n = 0; n <= 31; n++) {
		if (GET_BIT(new_value, n) == 1) {
			SET_BIT(new_value, n, 0);
		} else {
			// Cannot flip a bit from 1 to 0
			klee_assert(current_value == 0);
		}
	}
	return 0;
}


static uint32_t
stub_register_i2cctl_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	// I2C citations here are from https://www.nxp.com/docs/en/user-guide/UM10204.pdf
	// SFP citations here are from https://ta.snia.org/higherlogic/ws/public/download/268/SFF-8431.PDF
	// and https://ta.snia.org/higherlogic/ws/public/download/294/SFF-8472.PDF

	// Table 10, "Characteristics of the SDA and SCL bus lines for Standard [...] I2C devices"
	// NOTE: START setup and STOP setup are both >= TIME_LOW so we just ignore them
	const int TIME_START_HOLD = 4000; // SDA must keep its value for this long after a start
	const int TIME_BETWEEN_STOP_START = 4700;
	const int TIME_LOW = 4700; // minimum time for the clock to be in LOW
	const int TIME_HIGH = 4000; // minimum time for the clock to be in HIGH

	// I2C/SFP States
	// -1 is default
	const int I2C_STARTING = 0;
	const int I2C_STARTED = 1;
	const int I2C_STOPPED = 2;
	const int SFP_READING = 3;
	const int SFP_ADDRESSING = 4;
	const int SFP_WRITING = 5;
	const int SFP_END = 6;

	uint8_t scl_old = (current_value >> 1) & 1;
	uint8_t sda_old = (current_value >> 3) & 1;

	uint8_t scl_new = (new_value >> 1) & 1;
	uint8_t sda_new = (new_value >> 3) & 1;

	// Clone the out bits to the in bits - clock (1/0) and data (3/2)
	// NOTE: We model the out bits as writable because the driver has to write to them;
	//       otherwise, it would need to read I2CCTL every time before writing, which would be inefficient;
	//       so instead it just writes whatever to them and the value is ignored.
	SET_BIT(new_value, 0, GET_BIT(new_value, 1));
	SET_BIT(new_value, 2, GET_BIT(new_value, 3));

	if (scl_old != scl_new) {
		if (scl_new == 0) {
			klee_assert(TIME - dev->i2c_clock_time >= TIME_HIGH);
		} else {
			klee_assert(TIME - dev->i2c_clock_time >= TIME_LOW);
		}

		dev->i2c_clock_time = TIME;
	}

	// "A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition"
	if (sda_old == 1 && sda_new == 0 && scl_old == 1 && scl_new == 1) {
		if (dev->i2c_state == I2C_STOPPED) {
			klee_assert(dev->i2c_stop_time + TIME_BETWEEN_STOP_START <= TIME);
		}

		dev->i2c_state = I2C_STARTING;
		dev->i2c_start_time = TIME;
		dev->i2c_counter = 0;
		dev->i2c_address = 0;

		return new_value;
	}

	// "A data transfer is always terminated by a STOP condition generated by the master."
	// "A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition"
	if (sda_old == 0 && sda_new == 1 && scl_old == 1 && scl_new == 1) {
		// "A START condition immediately followed by a STOP condition (void message) is an illegal format."
		klee_assert(dev->i2c_counter > 0);

		// also, let's make sure the message didn't stop at some random place
		klee_assert(dev->i2c_counter % 9 == 0);

		dev->i2c_state = I2C_STOPPED;
		dev->i2c_counter = 0;
		dev->i2c_address = 0;
		dev->i2c_stop_time = TIME;

		return new_value;
	}

	if (dev->i2c_state == I2C_STARTING) {
		if (sda_old != sda_new) {
			klee_assert(TIME - dev->i2c_start_time >= TIME_START_HOLD);

			dev->i2c_state = I2C_STARTED;
		} else {
			return new_value;
		}

		// Fall through
	}

	if (!(scl_old == 0 && scl_new == 1)) {
		// Not a rising edge - we don't care
		return new_value;
	}

	if (dev->i2c_state == I2C_STARTED) {
		// "After the START condition, a slave address is sent.
		//  This address is seven bits long followed by an eight bit which is a data direction bit (R/W) -
		//  a 'zero' indicates a transmission (WRITE), a 'one' indicates a request for data (READ)

		if (dev->i2c_counter % 9 < 8) {
			// Part of the address or the RW bit - read a bit
			dev->i2c_address = dev->i2c_address << 1;
			dev->i2c_address = dev->i2c_address | sda_new;
		} else {
			// "Each byte is followed by an acknowledgement bit"
			// "The Acknowledge signal is defined as follows: the transmitter releases the SDA line
			//  during the acknowledge clock pulse so the receiver can pull the SDA line LOW
			//  and it remains stable LOW suring the HIGH period of this clock pulse."

			SET_BIT(new_value, 2, 0); // bit 2 is "data in"

			// Set the state since we sent an ACK
			// If it's an I2C write, the SFP address follows
			dev->i2c_state = (dev->i2c_address & 1) == 0 ? SFP_ADDRESSING : SFP_READING;

			// Reset SFP address if we're about to address (otherwise, don't! reads use the last one)
			if (dev->i2c_state == SFP_ADDRESSING) {
				dev->sfp_address = 0;
			}

			// Also remove the RW bit from the address
			dev->i2c_address = dev->i2c_address >> 1;

			// "The 10-bit slave address is formed from the first two bytes following a START condition"
			// "The first seven bits of the first byte are the combination 1111 0XX"
			// "Although there are eight possible combinations of the reserved address bits 1111 xxx,
			//  only the four combinations 1111 0XX are used for 10-bit addressing.
			//  The remaining four combinations 1111 1XX are reserved for future I2C-bus enhancements."
			// we don't support 10-bit mode, nor the reserved stuff
			klee_assert(dev->i2c_address >> 3 != 0b1111);

			// "Each SFP+ is hard-wired at the device addresses A0h and A2h"
			// except that by "A0h" they mean "the 7-bit address 50h padded with a 0 at the end to make it 8 bit"
			// we only suport A0 (for now?)
			klee_assert(dev->i2c_address == 80);
		}

		dev->i2c_counter++;

		return new_value;
	}

	if (dev->i2c_state == SFP_ADDRESSING) {
klee_print_expr("sfp_addressing, counter=",dev->i2c_counter % 9);
		if (dev->i2c_counter % 9 < 8) {
			dev->sfp_address = dev->sfp_address << 1;
			dev->sfp_address = dev->sfp_address | sda_new;
		} else {
			// We have a full SFP address, ACK it
			SET_BIT(new_value, 2, 0);

			// Put in write mode, which may be canceled by the master if it wants to read by restarting
			dev->i2c_state = SFP_WRITING;
		}

		dev->i2c_counter++;
		return new_value;
	}

	if (dev->i2c_state == SFP_READING) {
		// The master wants data - send it, bit by bit
		// Registers are found in table 4-1

		int cursor = dev->i2c_counter % 9;
klee_print_expr("sfp_reading, cursor = ", cursor);
		dev->i2c_counter++;

		if (cursor == 8) {
			// "To specify a sequential read, the host responds with an acknowledge"
			// "The sequence is terminated when the host responds with a NACK and a STOP"
			if (sda_new == 0) { // remember, 0 is ACK because it's a pull-up
klee_print_expr("GOT ACK", sda_new);
				dev->sfp_address++;
			} else {
klee_print_expr("GOT NACK", sda_new);
				dev->i2c_state = SFP_END;
			}

			return new_value;
		}

		cursor = 7 - cursor; // "Data is transferred with the most significant bit (MSB) first"

		int sfp_registers[] = {
			// 0: Identifier
			0x03, // SFP/SFP+

			// 1: Extended identifier
			0x00, // nothing TODO

			// 2: Connector Type
			//    Table 4-3 from https://doc.xdevs.com/doc/Seagate/SFF-8024.PDF
			0x00, // unknown/unspecified TODO

			// 3-10: Transciever
			// https://www.intel.com/content/www/us/en/support/articles/000005528/network-and-i-o/ethernet-products.html
			// says that SR and LR are supported
			// table 5-3 says those are byte 3 bit 4 and byte 3 bit 5 respectively
			// let's do SR for now TODO
			0x10, // 3
			0x00, // 4
			0x00, // 5
			0x00, // 6
			0x00, // 7
			0x00, // 8
			0x00, // 9
			0x00, // 10

			// 11: Encoding
			//     table 4-2 from SFF-8024
			0x00, // unknown/unspecified TODO

			// 12: Nominal signaling rate, units of 100 Mb/s
			100, // 10 Gb/s

			// 13: Rate identifier (table 5-6)
			0x00, // unknown TODO

			// 14: Length, unit of kilometers
			0x00, // not that long... TODO?

			// 15: Length, unit of 100 meters
			0x01, // total length 100 meters

			// 16: Length for 50um OM2 fiber, unit of 10 meters
			0x01, // TODO?

			// 17: Length for 62.5um OM2 fiber, unit of 10 meters
			0x01, // TODO?

			// 18: Length for 50um OM4 fiber, unit of 10m; or copper cable, unit of 1m
			0x01, // TODO?

			// 19: Length for 50um OM3 fiber, unit of 10m
			0x01, // TODO?

			// 20-35: SFP Vendor Name, ASCII "padded on the right with ASCII spaces"
			'S', 'T', 'U', 'B',
			' ', ' ', ' ', ' ',
			' ', ' ', ' ', ' ',
			' ', ' ', ' ', ' ',

			// 36: Transciever extended code (table 4-4 from SFF-8024)
			0x00, // unknown/unspecified TODO

			// 37-39: IEEE company ID (OUI)
			//     http://standards-oui.ieee.org/oui.txt
			0x00, 0xA0, 0xC9, // Intel (picked one at random...)

			// 40-55: Vendor Part Number
			//        see bits 3-10 above for link with PNs
			'F', 'T', 'L', 'X', '8', '5', '7', '1', 'D', '3', 'B', 'C', 'V', 'I', 'T', '1',

			// 56-59: Vendor Revision
			0x00, 0x00, 0x00, 0x01, // TODO?

			// 60-61: Wavelength
			0x00, 0x00, // unknown TODO

			// 62: Unallocated
			-1,

			// 63: CC_BASE - check code
			0
		};

		// "The check code is a one byte code that can be used to verify that the first 64 bytes of two-wire interface information in the SFP is valid.
		//  The check code shall be the low order 8 bits of the sum of the contents of all the bytes from byte 0 to byte 62, inclusive."
		uint32_t cc_base = 0;
		for (int n = 0; n <= 62; n++) {
			cc_base += sfp_registers[n];
		}
		sfp_registers[63] = cc_base & 0xFF;

		// we don't support extended stuff for now
		klee_assert(dev->sfp_address <= 63);

		int value = sfp_registers[dev->sfp_address];
		int bit = GET_BIT(value, cursor);

		// Set the data out bit
		SET_BIT(new_value, 3, bit);

		return new_value;
	}

	if (dev->i2c_state == SFP_WRITING) {
//		klee_abort();
	}

//	klee_assert(dev->i2c_state != SFP_END); // should have gotten a STOP?

	return new_value; // TODO
}


static uint32_t
stub_register_ctrl_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	// Bit 2 is cleared once no master requests are pending, which we don't emulate anyway
	SET_BIT(new_value, 2, 0);

	// Bit 3 is self-clearing
	if (GET_BIT(new_value, 3) == 1) {
		SET_BIT(new_value, 3, 0);
		// TODO reset MAC, PCS and autonegotiation
	}

	// Bit 26 is self-clearing
	if (GET_BIT(new_value, 26) == 1) {
		SET_BIT(new_value, 26, 0);
		stub_device_reset(dev);
	}

	return new_value;
}


static uint32_t
stub_register_eerd_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	// Cannot set the done bit to 1, only clear it
	klee_assert(!(GET_BIT(current_value, 1) == 0 && GET_BIT(new_value, 1) == 1));
	// Same with the data
	for (int n = 16; n <= 31; n++) {
		klee_assert(!(GET_BIT(current_value, n) == 0 && GET_BIT(new_value, n) == 1));
	}

	bool read = GET_BIT(new_value, 0);
	uint16_t addr = (new_value >> 2) & 0b11111111111111;
klee_print_expr("EEPROM READ", read);
klee_print_expr("addr", addr);

	// Clear read bit
	SET_BIT(new_value, 0, 0);
	// Clear data bits
	for (int n = 16; n <= 31; n++) {
		SET_BIT(new_value, n, 0);
	}

	// Checksum word - sum of all words from 0x00 to 0x3F (including words pointed to if any) must be 0xBABA
	if (addr == 0x3F) {
		new_value |= (0xBABA << 16);
	}

	// Mark read as done
	// TODO some timeouts?
	SET_BIT(new_value, 1, 1);

	return new_value;
}


static uint32_t
stub_register_msca_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	// page 135
	// MDIO Direct Access

	// TODO figure out which addresses are which registers... where's the spec?

	// Bit 30 is "MDI Command", 1 means perform operation
	if (GET_BIT(new_value, 30) == 0) {
		// bit cleared, nothing to do
		return new_value;
	}

	// Bit 30 says there is a command; start by clearing it, since we execute everything instantaneously
	SET_BIT(new_value, 30, 0);

	// "start code [00b] that identifies clause 45 format"
	if (((new_value >> 28) & 0b11) == 0b00) {
		int opcode = (new_value >> 26) & 0b11;

		if (opcode == 0b00) { // address operation
			klee_assert(dev->current_mdi_address == -1);
			dev->current_mdi_address = new_value & 0xFF;
klee_print_expr("dev",*dev);
klee_print_expr("ADDR PHY", dev->current_mdi_address);
		} else if (opcode == 0b11) { // read operation
klee_print_expr("dev", *dev);
klee_print_expr("READ PHY", dev->current_mdi_address);
			klee_assert(dev->current_mdi_address != -1);

			int phy_addr = (new_value >> 21) & 0b11111;
			int addr = new_value & 0xFF;

			uint32_t result = 0;
			if (dev->current_mdi_address == 0) { // control byte
				result = 0x8000; // reset flag set
			} else if (dev->current_mdi_address == 2) { // ID high byte
				result = 1; // just needs to be nonzero
			}

klee_print_expr("phy addr", phy_addr);
klee_print_expr("addr", addr);
klee_print_expr("result", result);
			DEV_REG(dev, 0x04260) = result << 16; // register MSRWD holds the result in the upper 16 bits

			dev->current_mdi_address = -1;
		} else if (opcode == 0b01) { // write operation
klee_print_expr("WRITE PHY", dev->current_mdi_address);
klee_print_expr("dev", *dev);
			klee_assert(dev->current_mdi_address != -1);

			int phy_addr = (new_value >> 21) & 0b11111;
			int data = new_value & 0xFF;
klee_print_expr("phy addr", phy_addr);
klee_print_expr("data", data);

			// only support the reset register - we just pretend that it's been reset all the time
			klee_assert(dev->current_mdi_address == 0);

			dev->current_mdi_address = -1;
		} else {
			klee_abort(); // unsupported
		}
	} else {
		// clause 22 format
		klee_abort(); // unsupported
	}

	return new_value;
}


static uint32_t
stub_register_txdctl_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	// Bit 26 is self-clearing
	SET_BIT(new_value, 26, 0);

	return new_value;
}


static uint32_t
stub_register_swsm_read(struct stub_device* dev, uint32_t current_value)
{
	SET_BIT(current_value, 1, 1); // LSB is the semaphore bit - always set after a read
	return current_value;
}

static uint32_t
stub_register_swsm_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	// Cannot set the semaphore bit to 1, only clear it
	klee_assert(!(GET_BIT(current_value, 0) == 0 && GET_BIT(new_value, 0) == 1));

	// Can only take the software semaphore bit if the semaphore is taken
	if (GET_BIT(current_value, 1) == 0 && GET_BIT(new_value, 1) == 1) {
		klee_assert(GET_BIT(current_value, 0) == 1);
	}

	return new_value; // OK, we only check
}


static uint32_t
stub_register_swfwsync_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	// Cannot write to this register unless the software semaphore bit of SWSM is taken
	klee_assert(GET_BIT(DEV_REG(dev, 0x10140), 1) == 1);

	// Cannot write 1 to a bit in this register if the firmware set the corresponding bit
	for (int n = 0; n < 5; n++) {
		klee_assert(GET_BIT(new_value, n) + GET_BIT(current_value, n + 5) <= 1);
	}

	return new_value; // OK, we only check
}


static uint32_t
stub_register_autoc_write(struct stub_device* dev, uint32_t current_value, uint32_t new_value)
{
	// Cannot write to this register unless the software semaphore bit of SWSM is taken
	klee_assert(GET_BIT(DEV_REG(dev, 0x10140), 1) == 1);

	// Bit 12 is self-clearing
	SET_BIT(new_value, 12, 0);

	return new_value;
}


static void
stub_registers_init(void)
{
	#define REG(addr, val, mask) do {                      \
				struct stub_register reg = {   \
					.present = true,       \
					.initial_value = val,  \
					.readable = true,      \
					.writable_mask = mask, \
					.read = NULL,          \
					.write = NULL          \
				};                             \
				REGISTERS[addr] = reg;         \
			} while(0);

	// page 543
	// Device Control Register — CTRL (0x00000 / 0x00004; RW)
	// NOTE: "CTRL is also mapped to address 0x00004 to maintain compatibility with previous devices."

	// 0-1: Reserved (0)
	// 2: PCIe Master Disable (0 - not disabled)
	// 3: Link Reset (0 - not reset; self-clearing)
	// 4-25: Reserved (0)
	// 26: Device Reset (0 - not reset; self-clearing)
	// 27-31: Reserved (0)
	REG(0x00000, 0b00000000000000000000000000000000,
		     0b00000100000000000000000000001100);
	REGISTERS[0x00000].write = stub_register_ctrl_write;
	// TODO should we do the 0x00004 mapping?


	// page 544
	// Device Status Register — STATUS (0x00008; RO)

	// 0-1: Reserved (00)
	// 2-3: Lan ID (00 - Lan 0 / 01 - Lan 1)
	// 4-6: Reserved (00)
	// 7: Linkup Status Indication (0 - ???)
	// 8-9: Reserved (00)
	// 10-17: Num VFs (0 - no VFs; note: "Bit 17 is always 0b")
	// 18: IO Active (0 - not active; note: "reflects the value of the VF Enable (VFE) bit in the IOV Control/Status register")
	// 19: Status (0 - not issuing any master requests)
	// 20-31: Reserved (0x00)
	REG(0x00008, 0b00000000000000000000000000000000,
		     0b00000000000000000000000000000000);


	// page 549
	// I2C Control — I2CCTL (0x00028; RW)

	// 0: I2C Clock In (0 - default; read-only)
	// 1: I2C Clock Out (0 - default)
	// 2: I2C Data In (0 - default; read-only)
	// 3: I2C Data Out (0 - default)
	// 4-31: Reserved
	REG(0x00028, 0b00000000000000000000000000001111, // in a pull-up system like I2C, 1 is the default
		     0b00000000000000000000000000001111); // NOTE: 0 and 2 are RW, see i2cctl_write for an explanation
	REGISTERS[0x00028].write = stub_register_i2cctl_write;


	// page 549
	// LED Control — LEDCTL (0x00200; RW)

	// 0-3: LED0 Mode (0000 - LINK_UP)
	// 4: Reserved (0)
	// 5: GLOBAL Blink Mode (0 - blink for 200 ms on/200ms off)
	// 6: LED0 Invert (0 - LED output is active low)
	// 7: LED0 Blink (0 - do not blink)
	// 8-11: LED1 Mode (0001 - 10 Gb/s link)
	// 12-13: Reserved (00)
	// 14: LED1 Invert (0 - LED output is active low)
	// 15: LED1 Blink (0 - do not blink)
	// 16-19: LED2 Mode (0100 - LINK/ACTIVITY)
	// 20-21: Reserved (00)
	// 22: LED2 Invert (0 - LED output is active low)
	// 23: LED2 Blink (0 - do not blink)
	// 24-27: LED3 Mode (0101 - 1 Gb/s link)
	// 28-29: Reserved (00)
	// 30: LED3 Invert (0 - LED output is active low)
	// 31: LED3 Blink (0 - do not blink)
	REG(0x00200, 0b00000101000001000000000100000000,
		     0b00000000000000000000000000000000);


	// page 572
	// Extended Interrupt Cause Register- EICR (0x00800; RW1C)

	// 0-15: Receive/Transmit Queue Interrupts (0x0 - not enabled)
	// 16: Flow director (0 - no)
	// 17: Missed packet (0 - no)
	// 18 - PCI timeout (0 - no)
	// 19: VF to PF MailBox (0 - no)
	// 20: Link Status Change (0 - no) TODO use this
	// 21: TX LinkSec counter reached threshold requiring key exchange (0 - no)
	// 22: Manageability event detected (0 - no)
	// 23: Reserved (0)
	// 24: General Purpose Interrupt on SDP0 (0 - no)
	// 25: General Purpose Interrupt on SDP1 (0 - no)
	// 26: General Purpose Interrupt on SDP2 (0 - no)
	// 27: General Purpose Interrupt on SDP3 (0 - no)
	// 28: Unrecoverable ECC Error (0 - no) TODO try this, software must reset if this is set
	// 29: Reserved (0)
	// 30: TCP Timer Expired (0 - no)
	// 31: Other interrupt - from EICR (0 - no)
	REG(0x00800, 0b00000000000000000000000000000000,
		     0b00000000000000000000000000000001);
	REGISTERS[0x00800].write = stub_register_rw1c_write;

	// page 574
	// Extended Interrupt Mask Clear Register- EIMC (0x00888; WO)
	// TODO do we model interrupts?

	// 0-30: Interrupt Mask (0 - don't care, write-only register)
	// 31: Reserved
	REG(0x00888, 0b00000000000000000000000000000000,
		     0b01111111111111111111111111111111);
	REGISTERS[0x00888].readable = false;


	// page 597
	// Receive Descriptor Control — RXDCTL[n] (0x01028 + 0x40*n, n=0...63 and 0x0D028 + 0x40*(n-64), n=64...127; RW)
	for (int n = 0; n <= 127; n++) {
		int addr = n < 64 ? (0x01028 + 0x40*n) : (0x0D028 + 0x40*(n-64));

		// 0-13: Reserved (0)
		// 14: Reserved, but readable/writeable for compatibility
		// 15: Reserved (0)
		// 16-22: Reserved, but readable/writeable for compatibility
		// 23-24: Reserved (00)
		// 25: Receive Queue Enable (0 - not enabled)
		// 26: Reserved, but readable/writeable for compatibility
		// 27-29: Reserved
		// 30: VLAN Mode Enable
		// 31: Reserved
		REG(addr, 0b00000000000000000000000000000000,
			  0b00000110011111110100000000000000);
	}


	// page 600
	// Receive Control Register — RXCTRL (0x03000; RW)

	// 0: Receive Enable (0 - not yet enabled)
	// 1-31: Reserved
	REG(0x03000, 0b00000000000000000000000000000000,
		     0b00000000000000000000000000000001);


	// page 668
	// MDI Single Command and Address — MSCA (0x0425C; RW)

	// 0-15: MDI Address (0x0000 - default)
	// 16-20: DeviceType/Register Address (0x0 - default)
	// 21-25: PHY Address (0x0 - default)
	// 26-27: OP Code (00 - default; all 4 combinations are valid)
	// 28-29: ST Code (0 - New protocol, default; only 00 and 01 are valid)
	// 30: MDI Command (0 - ready)
	// 31: Reserved
	REG(0x0425C, 0b00000000000000000000000000000000,
		     0b01011111111111111111111111111111); // bit 29 is read-only since it cannot be 1
	REGISTERS[0x0425C].write = stub_register_msca_write;


	// page 669
	// MDI Single Read and Write Data — MSRWD (0x04260; RW)

	// 0-15: MDI Write Data (0 - default)
	// 16-31: MDI Read Data (0 - default; read-only)
	REG(0x04260, 0b00000000000000000000000000000000,
		     0b00000000000000001111111111111111);


	// page 680
	// MAC Manageability Control Register — MMNGC (0x042D0; Host-RO/MNG-RW)

	// 0: MNG_VETO (0 - no veto)
	// 1-31: Reserved (0)
	REG(0x042D0, 0b00000000000000000000000000000000,
		     0b00000000000000000000000000000000);


	// pages 674-676
	// Auto Negotiation Control Register — AUTOC (0x042A0; RW)
	// NOTE: "The 82599 Device Firmware may access AUTOC register in parallel
	//        to software driver and a synchronization between them is needed"

	// 0: Force Link Up (0 - normal mode)
	// 1: Auto-negotiation Acknowledge2 field (0 - ???)
	// 2-6: Auto-negotiation Selector field (00001 - default value according to 802.3ap-2007)
	// 7-8: "Define 10 GbE PMA/PMD over four differential pairs" (01 - KX4 PMA/PMD, default value)
	// 9: PMA/PMD used for 1GbE (1 - KX or BX PMA/PMD, default value)
	// 10: Disables 10GbE Parallel Detect On Dx without main power (0 - no specific action)
	// 11: Restarts auto-negotiation on transition to Dx (0 - does not restart)
	// 12: Applies new settings and restarts relative auto-negotiation process (self-clearing)
	// 13-15: Link Mode Select (100 - KX/KX4/KR backplane auto-negotiation enable, Clause 37 negotiation disabled, default value)
	// 16: Configures the A2 bit of the TAF in the auto-negotiation word... blah blah blah... (1 - default)
	// 17: FEC Requested (0 - not requested)
	// 18: FEC Ability; should be set to 1 only if bit 16 is 1 (1 - supported)
	// 19-22: Backplane Auto-Negotiation Rx Align Treshold (0011 - default value)
	// 23: Auto-Negotiation Rx Drift Mode (1 - enabled)
	// 24: Auto-Negotiation Rx Loose Mode (1 - enabled)
	// 25-26: Auto-Negotiation Parallel Detect Timer (00 - 1ms)
	// 27: RF (0 - default)
	// 28-29: Pause Bits (00 - default)
	// 30-31: ...i don't even know what this description means (11 - KX supported, KX4 supported)
	REG(0x042A0, 0b11000001100111011000001010000100,
		     0b00000000000000000001000000000000);
	REGISTERS[0x042A0].write = stub_register_autoc_write;


	// pages 676-678
	// Link Status Register — LINKS (0x042A4; RO)

	// 0: Signal Detect of 1 GbE and 100 Mb/s (1 - signal present, OK)
	// 1: Signal detect of FEC (1 - signal detected, good)
	// 2: 10 GbE serial PCS FEC block lock (0 - no lock)
	// 3: 10 GbE serial KR_PCS high error rate (0 - low)
	// 4: 10 GbE serial PCS block lock (0 - no lock)
	// 5: KX/KX4/KR AN Next Page Received (0 - not received; clears on read)
	// 6: KX/KX4/KR Backplane Auto Negotiation Page Received (0 - not receifed; clears on read)
	// 7: Link Status (1 - link up; self-set on read to proper value)
	// 8-11: Signal Detect of 10 GbE Parallel (1111 - signal present for lanes 0,1,2,3 respectively, good)
	// 12: Signal Detet of 10 GbE serial (1 - signal detected, good)
	// 13-16: 10G Parallel lane sync status (1111 - sync status OK for lanes 0,1,2,3 respectively, good)
	// 17: 10 GbE align_status (1 - good)
	// 18: 1G sync_status (1 - good)
	// 19: KX/KX4/KR Baclplane Auto Negotiation Rx Idle (0 - good)
	// 20: PCS_1 GbE auto-negotiation enabled, aka clause 37 (0 - not enabled, see AUTOC bits 13-15)
	// 21: 1 GbE PCS enabled for 1 GbE and SGMII operation (0 - not enabled)
	// 22: 10G link enabled (1 - enabled)
	// 23: Forward Error Correction status in 10 GbE serial link (0 - disabled)
	// 24: Status of 10 GbE serial PCS (0 - disabled)
	// 25: Status of SGMII operation (0 - disabled)
	// 26-27: MAC link mode status (11 - auto-negotiation)
	// 28-29: MAC link speec status (11 - 10 GbE)
	// 30: Link Up (1 - link is up)
	// 31: KX/KX4/KR backplane auto-negotiation completed (1 - completed)
	REG(0x042A4, 0b11111100010001111111111110000011,
		     0b00000000000000000001000000000000);

	// page 679
	// Auto Negotiation Control 2 Register — AUTOC2 (0x042A8; RW)

	// 0-15: Reserved (0)
	// 16-17: PMAPMD used for 10 GbE serial link operation (00 - KR; note that 01 and 11 are reserved)
	// 18: Disable DME Pages Transmit (0 - not disabled)
	// 19-27: Reserved (0)
	// 28: Force auto-negotiation arbitration state machine to idle (0 - no force)
	// 29: Reserved (0)
	// 30: Disable parallel detect in KX/KX4/KR (0 - not disabled)
	// 31: Reserved (0)
	REG(0x042A8, 0b00000000000000000000000000000000,
		     0b00000000000000000000000000000000);


	// page 606
	// Transmit Descriptor Control — TXDCTL[n] (0x06028+0x40*n, n=0...127; RW)
	for (int n = 0; n <= 127; n++) {
		// 0-6: Prefetch Threshold (0x0 - zero)
		// 7: Reserved (0)
		// 8-14: Host Threshold (0x0 - zero) TODO check that if PTHRESH is used HTHRESH is >0
		// 15: Reserved (0)
		// 16-22: Write-Back Threshold (0x0 - zero)
		// 23-24: Reserved (0)
		// 25: Transmit Queue Enable (0 - not enabled)
		// 26 - Transmit Software Flush (0 - not enabled; note: "This bit is self cleared by hardware")
		// 27-31: Reserved (0)
		REG(0x06028 + 0x40*n, 0b00000000000000000000000000000000,
				      0b00000110000000000000000000000000);
		REGISTERS[0x06028 + 0x40*n].write = stub_register_txdctl_write;
	}


	// page 587
	// Receive Address Low — RAL[n] (0x0A200 + 8*n, n=0...127; RW)
	// NOTE: "The first Receive Address register [...] RAR0 should always be used to store the individual Ethernet MAC address of the adapter."

	// 0-31: Receive Address Low, lower 32 bits of the MAC addr ("field is defined in big endian")
	REG(0x0A200, 0x45678900, // NOTE: see VigNAT makefile
		     0x00000000);

	// page 587-588
	// Receive Address High — RAH[n] (0x0A204 + 8*n, n=0...127; RW)
	// NOTE: see note for RAL

	// 0-15: Receive Address High, upper 16 bits of MAC addr ("field is defined in big endian)
	// 16-30: Reserved (0)
	// 31: Address Valid (0 - valid)
	REG(0x0A204, 0x00000123,
		     0x00000000);


	// page 552
	// EEPROM/Flash Control Register — EEC (0x10010; RW)

	// 0: Clock input (0 - not enabled)
	// 1: Chip select (0 - not enabled)
	// 2: Data input (0 - not enabled)
	// 3: Data output (X - don't care)
	// 4-5: Flash Write Enable Control (11 - not allowed)
	// 6: Request EEPROM Access (0 - not enabled)
	// 7: Grant EEPROM Access (0 - not enabled)
	// 8: EEPROM Present (1 - present, correct signature)
	// 9: EEPROM Auto-Read Done (1 - done, since we fake hardware...)
	// 10: Reserved (1 - Reserved)
	// 11-14: EEPROM Size (0100 - Default)
	// 15: PCIe Analog Done (0 - not done)
	// 16: PCIe Core Done (0 - not done)
	// 17: PCIe General Done (0 - not done)
	// 18: PCIe Function Done (0 - not done)
	// 19: Core Done (0 - not done)
	// 20: Core CSR Done (0 - not done)
	// 21: MAC Done (0 - not done)
	// 22-31: Reserved (0x0)
	REG(0x10010, 0b00000000000000000001011100110000,
		     0b00000000000000000000000000000000);


	// page 554
	// EEPROM Read Register — EERD (0x10014; RW)
	// "This register is used by software to cause the 82599 to read individual words in the EEPROM."

	// 0: Start (0 - not started)
	// 1: Done (0 - no read perfomed yet)
	// 2-15: Address (0x0 - no read performed yet)
	// 16-31: Data (0x0 - no read performed yet)
	REG(0x10014, 0b00000000000000000000000000000000,
		     0b11111111111111111111111111111111);
	REGISTERS[0x10014].write = stub_register_eerd_write;

	// page 567
	// Software Semaphore Register — SWSM (0x10140; RW)
	// "This register is shared for both LAN ports."
	// NOTE: Bit 0 is automatically set to 1 by the hardware after a read
	// NOTE: See SW_FW_SYNC dance described below

	// 0: Semaphore (0 - not accessing)
	// 1: Software Semaphore (0 - not set)
	// 2-31: Reserved (0x0)
	REG(0x10140, 0b00000000000000000000000000000000,
		     0b00000000000000000000000000000011);
	REGISTERS[0x10140].read = stub_register_swsm_read;
	REGISTERS[0x10140].write = stub_register_swsm_write;


	// pages 567-568
	// Firmware Semaphore Register — FWSM (0x10148; RW)
	// "This register should be written only by the manageability firmware.
	//  The device driver should only read this register."

	// 0: Firmware semaphore (0 - not accessing)
	// 1-3: Firmware mode (000 - none, manageability off)
	// 4-5: Reserved (00)
	// 6: EEPROM Reloaded Indication (1 - has been reloaded)
	// 7-14: Reserved (0x0)
	// 15: Firmware Valid Bit (1 - ready, boot has finished) TODO make it 0
	// 16-18: Reset Counter (000 - not reset)
	// 19-24: External Error Indication (0x00 - No error)
	// 25: PCIe Configuration Error Indication (0 - no error)
	// 26: PHY/SERDES0 Configuration Error Indication (0 - no error, LAN0 is fine)
	// 27: PHY/SERDES1 Configuration Error Indication (0 - no error, LAN1 is fine)
	// 28-31: Reserved (0000)
	REG(0x10148, 0b00000000000000001000000001000000,
		     0b00000000000000000000000000000000);


	// page 565
	// Function Active and Power State to Manageability — FACTPS (0x10150; RO)

	// 0-1: Power state indication of function 0 (00 - DR)
	// 2: Lan 0 Enable (1 - enabled)
	// 3: Function 0 Auxiliary Power PM Enable (0 - ???)
	// 4-5: Reserved (00)
	// 6-7: Power state indication of function 1 (00 - disabled)
	// 8: Lan 1 Enable (0 - disabled)
	// 9: Function 1 Auxiliary Power PM Enable (0 - disabled)
	// 10-28: Reserved (0x0)
	// 29: Manageability Clock Gated (0 - not gated)
	// 30: LAN Function Sel (0 - not inverted) TODO enable
	// 31: PM State Changed (0 - not changed)
	REG(0x10150, 0b00000000000000000000000000000100,
		     0b00000000000000000000000000000000);


	// page 569
	// Software–Firmware Synchronization — SW_FW_SYNC (0x10160; RW)
	// "This register is shared for both LAN ports."
	// NOTE: See 0x10140 and 0x10148
	// NOTE: Also known as "General Software Semaphore Register", or GSSR
	// NOTE: See Section 10.5.4 "Software and Firmware Synchronization"
	//       The SW_FW_SYNC dance's happy path is:
	//       - Software locks SWSM.SMBI by reading and getting 0 (hardware automatically sets it to 1)
	//       - Software locks SWSM.SWESMBI by writing 1 then reading 1
	//       - Software sets/clears the SW_FW_SYNC access bits it wants to by writing 1/0
	//         (locks only if firmware hasn't sets the counterpart bits)
	//       - Software clears SWSM.SWESMBI by writing 0
	//       - Software clears SWSM.SMBI by writing 0

	// 0: EEPROM software access
	// 1: PHY 0 software access
	// 2: PHY 1 software access
	// 3: Shared CSRs software access
	// 4: Flash software access
	// 5: EEPROM firmware access
	// 6: PHY 0 firmware access
	// 7: PHY 1 firmware access
	// 8: Shared CSRs firmware access
	// 9: Flash firmware access (note: "Currently the FW does not access the FLASH")
	// 10-31: Reserved
	REG(0x10160, 0b00000000000000000000000000000000,
		     0b00000000000000000000000000011111);
	REGISTERS[0x10160].write = stub_register_swfwsync_write;
}

static void
stub_device_init(struct stub_device* dev)
{
	// "Fake" memory, intercepted
	dev->mem = malloc(dev->mem_len);
	klee_intercept_reads(dev->mem, "stub_hardware_read");
	klee_intercept_writes(dev->mem, "stub_hardware_write");

	// Real backing store
	dev->mem_shadow = malloc(dev->mem_len);
	memset(dev->mem_shadow, 0, dev->mem_len);

	for (int n = 0; n < sizeof(REGISTERS)/sizeof(REGISTERS[0]); n++) {
		if (REGISTERS[n].present) {
			DEV_REG(dev, n) = REGISTERS[n].initial_value;
		}
	}

	// 1 bit diff between MAC addresses; see registers init and VigNAT makefile
	if (dev == &DEVICES[1]) {
		DEV_REG(dev, 0x0A200) |= 1;
	}
}

static struct stub_device*
stub_device_get(uint64_t addr)
{
	for (int n = 0; n < sizeof(DEVICES)/sizeof(DEVICES[0]); n++) {
		if (addr == (uint64_t) DEVICES[n].mem) {
			return &DEVICES[n];
		}
	}

	klee_abort();
}

uint64_t
stub_hardware_read(uint64_t addr, unsigned offset, unsigned size)
{
	struct stub_device* dev = stub_device_get(addr);

	if (size == 1) {
		return DEV_MEM(dev, offset, uint8_t);
	}
	if (size == 2) {
		return DEV_MEM(dev, offset, uint16_t);
	}
	if (size == 4) {
		uint32_t current_value = DEV_REG(dev, offset);

		struct stub_register reg = REGISTERS[offset];
		klee_assert(reg.present);
		klee_assert(reg.readable);

		if (reg.read != NULL) {
			DEV_REG(dev, offset) = reg.read(dev, current_value);
		}

		return current_value;
	}
	if (size == 8) {
		return DEV_MEM(dev, offset, uint64_t);
	}

	klee_abort();
}

void
stub_hardware_write(uint64_t addr, unsigned offset, unsigned size, uint64_t value)
{
	struct stub_device* dev = stub_device_get(addr);

	if (size == 1) {
		DEV_MEM(dev, offset, uint8_t) = (uint8_t) value;
	} else if (size == 2) {
		DEV_MEM(dev, offset, uint16_t) = (uint16_t) value;
	} else if (size == 4) {
		struct stub_register reg = REGISTERS[offset];
		klee_assert(reg.present);

		uint32_t current_value = DEV_REG(dev, offset);
		uint32_t new_value = (uint32_t) value;
		uint32_t changed = current_value ^ new_value;

		if ((changed & ~reg.writable_mask) != 0) {
			klee_print_expr("old", current_value);
			klee_print_expr("changed", changed);
			klee_abort();
		}

		if (reg.write != NULL) {
			new_value = reg.write(dev, current_value, new_value);
		}

		DEV_REG(dev, offset) = new_value;
	} else if (size == 8) {
		DEV_MEM(dev, offset, uint64_t) = (uint64_t) value;
	} else {
		klee_abort();
	}
}


__attribute__((constructor(101))) // Low prio, must execute before other stuff
static void
stub_hardware_init(void)
{
	// Helper method declarations
	char* stub_pci_name(int index);

	// Register models initializations
	stub_registers_init();

	// Device initialization
	for (int n = 0; n < sizeof(DEVICES)/sizeof(DEVICES[0]); n++) {
		struct stub_device stub_dev = {
			.name = stub_pci_name(n),
			.mem = NULL,
			.mem_len = 1 << 20, // 2^20 bytes
			.mem_shadow = NULL,
			.current_mdi_address = -1,
			.i2c_state = -1,
			.i2c_counter = 0,
			.i2c_address = 0,
			.i2c_start_time = 0,
			.i2c_clock_time = 0,
			.i2c_stop_time = 0,
			.sfp_address = 0
		};
		stub_device_init(&stub_dev);
		DEVICES[n] = stub_dev;

	}

	// DPDK "delay" method override
	rte_delay_us_callback_register(stub_delay_us);
}

// Helper methods - not part of the stubs

char*
stub_pci_name(int index)
{
	klee_assert(index >= 0 && index < 10); // simpler

	char buffer[1024];
	snprintf(buffer, sizeof(buffer), "0000:00:00.%d", index);
	return strdup(buffer);
}
