#ifndef _TRANSPOSE_GH_INCLUDED_
#define _TRANSPOSE_GH_INCLUDED_

#include <nat.gh>
#include "arith.gh"
#include "modulo.gh"
#include "listutils.gh"

// ------------- extract_row/column -------------

fixpoint int extract_row(int nb_cols, int n) {
    return n / nb_cols;
}

fixpoint int extract_column(int nb_cols, int n) {
    return n % nb_cols;
}

lemma void extract_works(int nb_cols, int n, int row, int col)
    requires    extract_row(nb_cols, n) == row &*& extract_column(nb_cols, n) == col &*& 0 < nb_cols &*& 0 <= n;
    ensures     n == row * nb_cols + col;
{
    div_rem_nonneg(n, nb_cols);
}

lemma void extract_unique_row(int nb_rows, int nb_cols, int i1, int i2, int j)
    requires 
        i1 != i2 &*& 0 < nb_rows &*& 0 < nb_cols &*&
        0 <= i1 &*& i1 < nb_rows &*&
        0 <= i2 &*& i2 < nb_rows &*&
        0 <= j &*& j < nb_cols;
    ensures
        i1 * nb_cols + j != i2 * nb_cols + j;
{
    if (i1 < i2) {
        mul_mono_strict(i1, i2, nb_cols);
    } else {
        mul_mono_strict(i2, i1, nb_cols);

    }
}

lemma void extract_unique(int nb_rows, int nb_cols, int i1, int i2, int j1, int j2)
    requires 
        i1 != i2 &*& j1 != j2 &*&
        0 < nb_rows &*& 0 < nb_cols &*&
        0 <= i1 &*& i1 < nb_rows &*&
        0 <= i2 &*& i2 < nb_rows &*&
        0 <= j1 &*& j1 < nb_cols &*&
        0 <= j2 &*& j2 < nb_cols;
    ensures
        i1 * nb_cols + j1 != i2 * nb_cols + j2;
{
    if (i1 < i2) {
        mul_mono(i1 + 1, i2, nb_cols);
    } else {
        mul_mono(i2 + 1, i1, nb_cols);
    }
}


lemma void extract_bounds(int nb_rows, int nb_cols, int n)
    requires    
        0 <= n &*& n < nb_rows * nb_cols &*&
        0 < nb_rows &*& 0 < nb_cols;
    ensures     
        0 <= extract_row(nb_cols, n) &*& extract_row(nb_cols, n) < nb_rows &*& 
        0 <= extract_column(nb_cols, n) &*& extract_column(nb_cols, n) < nb_cols;
{
    div_rem_nonneg(n, nb_cols);
    div_lt(n, nb_rows, nb_cols);
    div_exact(nb_rows, nb_cols);
    div_mod_gt_0(n % nb_cols, n, nb_cols);
}

lemma void extract_row_val(int nb_cols, int n, int i, int j)
    requires   
        n == i * nb_cols + j &*&
        0 <= n &*& 0 < nb_cols &*&
        0 <= i &*& 0 <= j &*& j < nb_cols;
    ensures    
        extract_row(nb_cols, n) == i;
{
    assume (extract_row(nb_cols, n) == i);
}

lemma void extract_column_val(int nb_cols, int n, int i, int j)
    requires   
        n == i * nb_cols + j &*&
        0 <= n &*& 0 < nb_cols &*&
        0 <= i &*& 0 <= j &*& j < nb_cols;
    ensures    
        extract_column(nb_cols, n) == j;
{
    assume (extract_column(nb_cols, n) == j);
}

lemma void extract_row_ge(int nb_cols, int val, list<int> xs)
    requires    true == forall(xs, (ge)(val + nb_cols)) &*& 0 <= val &*& 0 < nb_cols;
    ensures     true == forall(map( (extract_row)(nb_cols), xs ), (ge)(val/nb_cols + 1));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0):
            forall_nth(xs, (ge)(val + nb_cols), 0);
            div_incr(val, nb_cols);
            div_ge(val + nb_cols, x0, nb_cols);
            extract_row_ge(nb_cols, val, xs0);
    }
}

// ------------- transpose -------------

fixpoint list<t> transpose_rec_row<t>(list<t> xs, int nb_cols, int idx_col_cst, int idx_row, nat it_row) {
    switch(it_row) {
        case zero: return nil;
        case succ(it_row_pred): return cons( nth(idx_row * nb_cols + idx_col_cst, xs) , transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row + 1, it_row_pred) );
    }
}

fixpoint list<t> transpose_rec<t>(list<t> xs, int nb_rows, int nb_cols, int idx_col, nat it_col) {
    switch(it_col) {
        case zero: return nil;
        case succ(it_col_pred): return append( transpose_rec_row(xs, nb_cols, idx_col, 0, nat_of_int(nb_rows)) , transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred) );
    }
}

fixpoint list<t> transpose<t>(list<t> xs, int nb_rows, int nb_cols) {
    return transpose_rec(xs, nb_rows, nb_cols, 0, nat_of_int(nb_cols));
}

lemma_auto(length(transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, it_row))) void length_transpose_rec_row<t>(list<t> xs, int nb_cols, int idx_col_cst, int idx_row, nat it_row)
    requires    true;
    ensures     length(transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, it_row)) == int_of_nat(it_row);
{
    switch(it_row) {
        case zero:
        case succ(it_row_pred): length_transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row + 1, it_row_pred);
    }
}

lemma_auto(length(transpose_rec(xs, nb_rows, nb_cols, idx_col, it_col))) void length_transpose_rec<t>(list<t> xs, int nb_rows, int nb_cols, int idx_col, nat it_col)
    requires    0 <= nb_rows;
    ensures     length(transpose_rec(xs, nb_rows, nb_cols, idx_col, it_col)) == nb_rows * int_of_nat(it_col);
{
    switch(it_col) {
        case zero:
        case succ(it_col_pred): 
            length_transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred);
            mul_subst(int_of_nat(it_col), int_of_nat(it_col_pred) + 1, nb_rows);
    }
}

lemma_auto(length(transpose(xs, nb_rows, nb_cols))) void length_transpose<t>(list<t> xs, int nb_rows, int nb_cols)
    requires    0 <= nb_rows && 0 <= nb_cols;
    ensures     length(transpose(xs, nb_rows, nb_cols)) == nb_rows * nb_cols;
{
    length_transpose_rec(xs, nb_rows, nb_cols, 0, nat_of_int(nb_cols));
}

lemma void transpose_rec_row_to_src<t>(list<t> xs, int nb_rows, int nb_cols, int i, int idx_col_cst, int idx_row, nat it_row)
    requires
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= idx_col_cst &*& idx_col_cst < nb_cols &*&
        0 <= idx_row &*& idx_row <= i &*&
        int_of_nat(it_row) == nb_rows - idx_row;
    ensures
        nth(i * nb_cols + idx_col_cst, xs) == nth(i - idx_row, transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, it_row));
{
    switch(it_row) {
        case zero:
        case succ(it_row_pred): if (idx_row < i) transpose_rec_row_to_src(xs, nb_rows, nb_cols, i, idx_col_cst, idx_row + 1, it_row_pred);
    }
}

lemma void transpose_rec_to_src<t>(list<t> xs, list<t> xs_transpose, int nb_rows, int nb_cols, int i, int j, int idx_col, nat it_col)
    requires
        xs_transpose == transpose(xs, nb_rows, nb_cols) &*& 
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= j &*& j < nb_cols &*&
        0 <= idx_col &*& idx_col <= j &*&
        int_of_nat(it_col) == nb_cols - idx_col;
    ensures
        nth(i * nb_cols + j, xs) == nth((j - idx_col) * nb_rows + i, transpose_rec(xs, nb_rows, nb_cols, idx_col, it_col));
{
    switch(it_col) {
        case zero: 
        case succ(it_col_pred): 
            if (idx_col < j) {
                transpose_rec_to_src(xs, xs_transpose, nb_rows, nb_cols, i, j, idx_col + 1, it_col_pred);
                mul_bounds(0, j - (idx_col + 1), nb_rows, nb_rows);
                mul_bounds(j - (idx_col + 1), int_of_nat(it_col_pred) - 1, nb_rows, nb_rows);
                nth_append_r(transpose_rec_row(xs, nb_cols, idx_col, 0, nat_of_int(nb_rows)) , transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred), (j - (idx_col + 1)) * nb_rows + i);
            } else {
                assert (idx_col == j);
                assert ((j - idx_col) * nb_rows + i == i);
                transpose_rec_row_to_src(xs, nb_rows, nb_cols, i, idx_col, 0, nat_of_int(nb_rows));
                nth_append(transpose_rec_row(xs, nb_cols, idx_col, 0, nat_of_int(nb_rows)) , transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred), i);
            }
    }
}

lemma void transpose_to_src<t>(list<t> xs, int nb_rows, int nb_cols, int i, int j)
    requires
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= j &*& j < nb_cols;
    ensures
        nth(i * nb_cols + j, xs) == nth(j * nb_rows + i, transpose(xs, nb_rows, nb_cols));
{
    transpose_rec_to_src(xs, transpose(xs, nb_rows, nb_cols), nb_rows, nb_cols, i, j, 0, nat_of_int(nb_cols));
}

lemma void transpose_twice<t>(list<t> xs, int nb_rows, int nb_cols, int i, int j)
    requires
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= j &*& j < nb_cols;
    ensures
        nth(i * nb_cols + j, xs) == nth(i * nb_cols + j, transpose(transpose(xs, nb_rows, nb_cols), nb_cols, nb_rows));
{
    transpose_to_src(xs, nb_rows, nb_cols, i, j);
    transpose_to_src(transpose(xs, nb_rows, nb_cols), nb_cols, nb_rows, j, i);
}

// ------------- take_alt -------------

fixpoint list<t> take_alt_rec<t>(int n, int nb_rows, int nb_cols, list<t> xs, nat idx) {
    switch(idx) {
        case zero: return nil;
        case succ(idx_pred): return (nb_cols - int_of_nat(idx)) < n / nb_rows
            ?   append( transpose_rec_row(xs, nb_cols, nb_cols - int_of_nat(idx), 0, nat_of_int(nb_rows)) , take_alt_rec(n, nb_rows, nb_cols, drop(n, xs), idx_pred) )
            :   append( transpose_rec_row(xs, nb_cols, nb_cols - int_of_nat(idx), 0, nat_of_int(n % nb_rows)) , nil );
    }
}

fixpoint list<t> take_alt<t>(int n, int nb_rows, int nb_cols, list<t> xs) {
    return take_alt_rec(n, nb_rows, nb_cols, xs, nat_of_int(nb_cols));
}

lemma void take_alt_0_rec<t>(int nb_rows, int nb_cols, list<t> xs, nat idx)
    requires    int_of_nat(idx) <= nb_cols &*& 0 < nb_rows;
    ensures     take_alt_rec(0, nb_rows, nb_cols, xs, idx) == nil;
{
    switch(idx) {
        case zero:
        case succ(idx_pred):
            div_rem_nonneg(0, nb_rows);
            take_alt_0_rec(nb_rows, nb_cols, xs, idx_pred);
    }
}

lemma_auto void take_alt_0<t>(int nb_rows, int nb_cols, list<t> xs)
    requires    0 < nb_rows && 0 < nb_cols;
    ensures     take_alt(0, nb_rows, nb_cols, xs) == nil;
{
    take_alt_0_rec(nb_rows, nb_cols, xs, nat_of_int(nb_cols));
}

// ------------- lemmas on transpose -------------

fixpoint bool nth_list<t>(fixpoint(t, bool) fp, list<t> xs, int idx) { return fp(nth(idx, xs)); } 

lemma void transpose_filter_idx_transfer<t>(list<t> xs, int nb_rows, int nb_cols, int i, int j, fixpoint (t, bool) fp)
    requires    
        true == mem(i * nb_cols + j, filter_idx(xs, 0, fp)) &*&
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= j &*& j < nb_cols;
    ensures     
        true == mem(j * nb_rows + i, filter_idx(transpose(xs, nb_rows, nb_cols), 0, fp));
{
    mul_bounds(i, nb_rows - 1, nb_cols, nb_cols);
    filter_idx_mem_to_nth(xs, 0, fp, i * nb_cols + j);

    transpose_to_src(xs, nb_rows, nb_cols, i, j);

    mul_bounds(j, nb_cols - 1, nb_rows, nb_rows);
    filter_idx_nth_to_mem(transpose(xs, nb_rows, nb_cols), 0, fp, j * nb_rows + i);
}

lemma void transpose_row_col_idx_equiv<t>(list<t> xs, int nb_rows, int nb_cols, fixpoint (t, bool) fp)
    requires    length(xs) == nb_rows * nb_cols;
    ensures     map((extract_row)(nb_cols) , filter_idx(xs, 0, fp)) == map((extract_column)(nb_rows) , filter_idx(transpose(xs, nb_rows, nb_cols), 0, fp));
{
    assume ( map((extract_row)(nb_cols) , filter_idx(xs, 0, fp)) == map((extract_column)(nb_rows) , filter_idx(transpose(xs, nb_rows, nb_cols), 0, fp)) );
}

lemma void transpose_preserves_count<t>(list<t> xs, int nb_rows, int nb_cols, fixpoint (t, bool) fp)
    requires    length(xs) == nb_rows * nb_cols;
    ensures     count(transpose(xs, nb_rows, nb_cols), fp) == count(xs, fp);
{
    transpose_row_col_idx_equiv(xs, nb_rows, nb_cols, fp);
    map_preserves_length((extract_row)(nb_cols), filter_idx(xs, 0, fp));
    map_preserves_length((extract_column)(nb_rows) , filter_idx(transpose(xs, nb_rows, nb_cols), 0, fp));
    filter_idx_length_count_equiv(xs, 0, fp);
    filter_idx_length_count_equiv(transpose(xs, nb_rows, nb_cols), 0, fp);
}

lemma void transpose_preserves_integer_copies(list<int> xs, int nb_rows, int nb_cols, int nb_copies, nat val)
    requires    true == integer_copies(val, nb_copies, xs) &*& length(xs) == nb_rows * nb_cols;
    ensures     true == integer_copies(val, nb_copies, transpose(xs, nb_rows, nb_cols));
{
    switch(val) {
        case zero:  transpose_preserves_count(xs, nb_rows, nb_cols, (eq)(0));
        case succ(val_pred): 
            transpose_preserves_count(xs, nb_rows, nb_cols, (eq)(int_of_nat(val)));
            transpose_preserves_integer_copies(xs, nb_rows, nb_cols, nb_copies, val_pred);
    }
}

#endif //_LISTUTILS_GH_INCLUDED_
