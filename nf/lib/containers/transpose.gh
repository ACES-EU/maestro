#ifndef _TRANSPOSE_GH_INCLUDED_
#define _TRANSPOSE_GH_INCLUDED_

#include <nat.gh>
#include "arith.gh"


fixpoint list<t> transpose_rec_row<t>(list<t> xs, int nb_cols, int idx_col_cst, int idx_row, nat it_row) {
    switch(it_row) {
        case zero: return nil;
        case succ(it_row_pred): return cons( nth(idx_row * nb_cols + idx_col_cst, xs) , transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row + 1, it_row_pred) );
    }
}

fixpoint list<t> transpose_rec<t>(list<t> xs, int nb_rows, int nb_cols, int idx_col, nat it_col) {
    switch(it_col) {
        case zero: return nil;
        case succ(it_col_pred): return append( transpose_rec_row(xs, nb_cols, idx_col, 0, nat_of_int(nb_rows)) , transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred) );
    }
}

fixpoint list<t> transpose<t>(list<t> xs, int nb_rows, int nb_cols) {
    return transpose_rec(xs, nb_rows, nb_cols, 0, nat_of_int(nb_cols));
}

lemma_auto(length(transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, it_row))) void length_transpose_rec_row<t>(list<t> xs, int nb_cols, int idx_col_cst, int idx_row, nat it_row)
    requires    true;
    ensures     length(transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, it_row)) == int_of_nat(it_row);
{
    switch(it_row) {
        case zero:
        case succ(it_row_pred): length_transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row + 1, it_row_pred);
    }
}

lemma_auto(length(transpose_rec(xs, nb_rows, nb_cols, idx_col, it_col))) void length_transpose_rec<t>(list<t> xs, int nb_rows, int nb_cols, int idx_col, nat it_col)
    requires    0 <= nb_rows;
    ensures     length(transpose_rec(xs, nb_rows, nb_cols, idx_col, it_col)) == nb_rows * int_of_nat(it_col);
{
    switch(it_col) {
        case zero:
        case succ(it_col_pred): 
            length_transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred);
            mul_subst(int_of_nat(it_col), int_of_nat(it_col_pred) + 1, nb_rows);
    }
}

lemma void transpose_rec_row_to_src<t>(list<t> xs, int nb_rows, int nb_cols, int i, int idx_col_cst, int idx_row, nat it_row)
    requires
        length(xs) == nb_rows * nb_cols &*&
        0 <= idx_col_cst &*& idx_col_cst < nb_cols &*&
        0 <= idx_row &*& idx_row < nb_rows &*&
        int_of_nat(it_row) == nb_rows - idx_row;
    ensures
        nth(i * nb_cols + idx_col_cst, xs) == nth(i, transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, nat_of_int(nb_rows)));
{
    switch(it_row) {
        case zero:
        case succ(it_row_pred): transpose_rec_row_to_src(xs, nb_rows, nb_cols, i, idx_col_cst, idx_row + 1, it_row_pred);
    }
}

lemma void transpose_rec_to_src<t>(list<t> xs, list<t> xs_transpose, int nb_rows, int nb_cols, int i, int j, int idx_col, nat it_col)
    requires
        xs_transpose == transpose(xs, nb_rows, nb_cols) &*&
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= idx_col &*& idx_col < nb_cols &*&
        int_of_nat(it_col) = nb_cols - idx_col;
    ensures
        nth(i * nb_rows + int_of_nat(it_col), xs) == nth(int_of_nat(it_col) * nb_rows + i, xs_transpose);
{
    switch(it_col) {
        case zero: transpose_rec_row_to_src(xs, nb_rows, nb_cols, idx_col, 0, nat_of_int(i));
        case succ(it_col_pred): transpose_rec_to_src(xs, xs_transpose, nb_rows, nb_cols, i, j, idx_col + 1, it_col_pred);
    }
}

lemma void transpose_to_src<t>(list<t> xs, list<t> xs_transpose, int nb_rows, int nb_cols, int i, int j)
    requires
        xs_transpose == transpose(xs, nb_rows, nb_cols) &*&
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= j &*& j < nb_cols;
    ensures
        nth(i * nb_rows + int_of_nat(j), xs) == nth(int_of_nat(j) * nb_rows + i, xs_transpose);
{
    transpose_rec_to_src(xs, xs_transpose, nb_rows, nb_cols, i, j, 0, nat_of_int(j));
}

#endif //_LISTUTILS_GH_INCLUDED_
