#ifndef _TRANSPOSE_GH_INCLUDED_
#define _TRANSPOSE_GH_INCLUDED_

#include <nat.gh>
#include "arith.gh"
#include "listutils.gh"

// ------------- transpose -------------

fixpoint list<t> transpose_rec_row<t>(list<t> xs, int nb_cols, int idx_col_cst, int idx_row, nat it_row) {
    switch(it_row) {
        case zero: return nil;
        case succ(it_row_pred): return cons( nth(idx_row * nb_cols + idx_col_cst, xs) , transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row + 1, it_row_pred) );
    }
}

fixpoint list<t> transpose_rec<t>(list<t> xs, int nb_rows, int nb_cols, int idx_col, nat it_col) {
    switch(it_col) {
        case zero: return nil;
        case succ(it_col_pred): return append( transpose_rec_row(xs, nb_cols, idx_col, 0, nat_of_int(nb_rows)) , transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred) );
    }
}

fixpoint list<t> transpose<t>(list<t> xs, int nb_rows, int nb_cols) {
    return transpose_rec(xs, nb_rows, nb_cols, 0, nat_of_int(nb_cols));
}

lemma_auto(length(transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, it_row))) void length_transpose_rec_row<t>(list<t> xs, int nb_cols, int idx_col_cst, int idx_row, nat it_row)
    requires    true;
    ensures     length(transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, it_row)) == int_of_nat(it_row);
{
    switch(it_row) {
        case zero:
        case succ(it_row_pred): length_transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row + 1, it_row_pred);
    }
}

lemma_auto(length(transpose_rec(xs, nb_rows, nb_cols, idx_col, it_col))) void length_transpose_rec<t>(list<t> xs, int nb_rows, int nb_cols, int idx_col, nat it_col)
    requires    0 <= nb_rows;
    ensures     length(transpose_rec(xs, nb_rows, nb_cols, idx_col, it_col)) == nb_rows * int_of_nat(it_col);
{
    switch(it_col) {
        case zero:
        case succ(it_col_pred): 
            length_transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred);
            mul_subst(int_of_nat(it_col), int_of_nat(it_col_pred) + 1, nb_rows);
    }
}

lemma_auto(length(transpose(xs, nb_rows, nb_cols))) void length_transpose<t>(list<t> xs, int nb_rows, int nb_cols)
    requires    0 <= nb_rows && 0 <= nb_cols;
    ensures     length(transpose(xs, nb_rows, nb_cols)) == nb_rows * nb_cols;
{
    length_transpose_rec(xs, nb_rows, nb_cols, 0, nat_of_int(nb_cols));
}

lemma void transpose_rec_row_to_src<t>(list<t> xs, int nb_rows, int nb_cols, int i, int idx_col_cst, int idx_row, nat it_row)
    requires
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= idx_col_cst &*& idx_col_cst < nb_cols &*&
        0 <= idx_row &*& idx_row <= i &*&
        int_of_nat(it_row) == nb_rows - idx_row;
    ensures
        nth(i * nb_cols + idx_col_cst, xs) == nth(i - idx_row, transpose_rec_row(xs, nb_cols, idx_col_cst, idx_row, it_row));
{
    switch(it_row) {
        case zero:
        case succ(it_row_pred): if (idx_row < i) transpose_rec_row_to_src(xs, nb_rows, nb_cols, i, idx_col_cst, idx_row + 1, it_row_pred);
    }
}

lemma void transpose_rec_to_src<t>(list<t> xs, list<t> xs_transpose, int nb_rows, int nb_cols, int i, int j, int idx_col, nat it_col)
    requires
        xs_transpose == transpose(xs, nb_rows, nb_cols) &*& 
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= j &*& j < nb_cols &*&
        0 <= idx_col &*& idx_col <= j &*&
        int_of_nat(it_col) == nb_cols - idx_col;
    ensures
        nth(i * nb_cols + j, xs) == nth((j - idx_col) * nb_rows + i, transpose_rec(xs, nb_rows, nb_cols, idx_col, it_col));
{
    switch(it_col) {
        case zero: 
        case succ(it_col_pred): 
            if (idx_col < j) {
                transpose_rec_to_src(xs, xs_transpose, nb_rows, nb_cols, i, j, idx_col + 1, it_col_pred);
                mul_bounds(0, j - (idx_col + 1), nb_rows, nb_rows);
                mul_bounds(j - (idx_col + 1), int_of_nat(it_col_pred) - 1, nb_rows, nb_rows);
                nth_append_r(transpose_rec_row(xs, nb_cols, idx_col, 0, nat_of_int(nb_rows)) , transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred), (j - (idx_col + 1)) * nb_rows + i);
            } else {
                assert (idx_col == j);
                assert ((j - idx_col) * nb_rows + i == i);
                transpose_rec_row_to_src(xs, nb_rows, nb_cols, i, idx_col, 0, nat_of_int(nb_rows));
                nth_append(transpose_rec_row(xs, nb_cols, idx_col, 0, nat_of_int(nb_rows)) , transpose_rec(xs, nb_rows, nb_cols, idx_col + 1, it_col_pred), i);
            }
    }
}

lemma void transpose_to_src<t>(list<t> xs, list<t> xs_transpose, int nb_rows, int nb_cols, int i, int j)
    requires
        xs_transpose == transpose(xs, nb_rows, nb_cols) &*&
        length(xs) == nb_rows * nb_cols &*&
        0 <= i &*& i < nb_rows &*&
        0 <= j &*& j < nb_cols;
    ensures
        nth(i * nb_cols + j, xs) == nth(j * nb_rows + i, xs_transpose);
{
    transpose_rec_to_src(xs, xs_transpose, nb_rows, nb_cols, i, j, 0, nat_of_int(nb_cols));
}

lemma void transpose_preserves_count<t>(list<t> xs, int nb_rows, int nb_cols, int count, fixpoint (t, bool) fp)
    requires    count(xs, fp) == count &*& length(xs) == nb_rows * nb_cols;
    ensures     count(transpose(xs, nb_rows, nb_cols), fp) == count;
{
    assume (count(transpose(xs, nb_rows, nb_cols), fp) == count);
}

lemma void transpose_preserves_integer_copies(list<int> xs, int nb_rows, int nb_cols, int nb_copies, nat val)
    requires    true == integer_copies(val, nb_copies, xs) &*& length(xs) == nb_rows * nb_cols;
    ensures     true == integer_copies(val, nb_copies, transpose(xs, nb_rows, nb_cols));
{
    switch(val) {
        case zero:  transpose_preserves_count(xs, nb_rows, nb_cols, nb_copies, (eq)(0));
        case succ(val_pred): 
            transpose_preserves_count(xs, nb_rows, nb_cols, nb_copies, (eq)(int_of_nat(val)));
            transpose_preserves_integer_copies(xs, nb_rows, nb_cols, nb_copies, val_pred);
    }
}

// ------------- extract_row/column -------------

fixpoint int extract_row(int nb_cols, int n) {
    return n / nb_cols;
}

fixpoint int extract_column(int nb_cols, int n) {
    return n % nb_cols;
}

lemma void extract_works(int n, int nb_cols, int row, int col)
    requires    extract_row(nb_cols, n) == row &*& extract_column(nb_cols, n) == col &*& 0 < nb_cols &*& 0 <= n;
    ensures     n == row * nb_cols + col;
{
    div_rem_nonneg(n, nb_cols);
}

lemma void extract_row_val(int nb_cols, int n, int i, int j)
    requires   
        n == i * nb_cols + j &*&
        0 <= n &*& 0 < nb_cols &*&
        0 <= i &*& 0 <= j;
    ensures    
        extract_row(nb_cols, n) == i;
{
    assume (extract_row(nb_cols, n) == i);
}

lemma void extract_column_val(int nb_cols, int n, int i, int j)
    requires   
        n == i * nb_cols + j &*&
        0 <= n &*& 0 < nb_cols &*&
        0 <= i &*& 0 <= j;
    ensures    
        extract_column(nb_cols, n) == j;
{
    assume (extract_column(nb_cols, n) == j);
}

#endif //_LISTUTILS_GH_INCLUDED_
