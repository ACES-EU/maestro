#ifndef _PERMUTATIONS_GH_INCLUDED_
#define _PERMUTATIONS_GH_INCLUDED_

#include <nat.gh>
#include "listutils.gh"
#include "stdex.gh"
#include "listexex.gh"


// ------------- is_permutation -------------

fixpoint bool is_permutation(list<int> xs) {
    return forall(xs, (lt)(length(xs))) && true == forall(xs, (ge)(0)) && no_dups(xs);
}

// ------------- is_sub_permutation -------------

fixpoint bool is_sub_permutation(list<int> xs, int max_val) {
    return forall(xs, (lt)(max_val)) && true == forall(xs, (ge)(0)) && no_dups(xs);
}

lemma void sub_permutation_complete(list<int> xs)
    requires    true == is_sub_permutation(xs, length(xs));
    ensures     true == is_permutation(xs);
{}

lemma void take_preserves_mem<t>(list<t> tail, t head, int i)
    requires    false == mem(head, tail) &*& 0 <= i;
    ensures     false == mem(head, take(i, tail));
{
    switch(tail) {
        case nil:
        case cons(x0, xs0):
            assert (head != x0);
            if (i > 0) {
            	take_preserves_mem(xs0, head, i-1);
            }
    }
}

lemma void take_preserves_no_dups<t>(list<t> xs, int i)
    requires    true == no_dups(xs) &*& 0 <= i;
    ensures     true == no_dups(take(i, xs));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0):
            if (i > 0) {
                take_preserves_no_dups(xs0, i - 1);
                cons_take_take_cons(x0, xs0, i - 1);
                take_preserves_mem(xs0, x0, i - 1);
            } else {
	            take_0(xs);
            }
    }
}

lemma void sub_permutation_take(list<int> xs, int max_val, int i)
    requires    true == is_sub_permutation(xs, max_val) &*& 0 <= i;
    ensures     true == is_sub_permutation(take(i, xs), max_val);
{
    switch(xs) {
        case nil:
        case cons(x0, xs0):
            if (i <= 0) {
            	assert (take(i, xs) == nil);
            	assert (true == is_sub_permutation(take(i, xs), max_val));
            } else {
                sub_permutation_take(xs0, max_val, i - 1);
                assume (take(i, xs) == append(take(i - 1, xs0), cons(x0, nil)));
                cons_take_take_cons(x0, xs0, i - 1);
                forall_append(take(i - 1, xs0), cons(x0, nil), (lt)(max_val));
                forall_append(take(i - 1, xs0), cons(x0, nil), (ge)(max_val));
		        take_preserves_no_dups(xs, i);
            }
            
    }
}

// ------------- is_sub_permutation2 -------------

fixpoint bool is_sub_permutation2(int max_val, list<int> xs) {
    return is_sub_permutation(xs, max_val);
}

lemma_auto(is_sub_permutation2(max_val, nil)) void sub_permutation2_nil(int max_val)
    requires    true;
    ensures     true == is_sub_permutation2(max_val, nil);
{}

lemma void sub_permutation2_forall_nil(list< list<int> > xs, int max_val)
    requires    true == forall(xs, (eq)(nil));
    ensures     true == forall(xs, (is_sub_permutation2)(max_val));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): sub_permutation2_forall_nil(xs0, max_val);
    }
}

// ------------- is_permutation_map_fst -------------

fixpoint bool is_permutation_map_fst(list< pair<int, real> > xs) {
    return is_permutation(map(fst, xs));
}

lemma void is_permutation_map_fst_extract(list< pair<int, real> > xs, list<int> map_fst)
    requires    map_fst == map(fst, xs) &*& true == is_permutation_map_fst(xs);
    ensures     true == forall(map_fst, (lt)(length(map_fst))) &*& true == forall(map_fst, (ge)(0)) &*& true == no_dups(map_fst);
{}

// ------------- is_sub_permutation_map_fst -------------

fixpoint bool is_sub_permutation_map_fst(int max_val, list< pair<int, real> > xs) {
    return is_sub_permutation(map(fst, xs), max_val);
}

lemma_auto(is_sub_permutation_map_fst(max_val, nil)) void sub_permutation_map_fst_nil(int max_val)
    requires    true;
    ensures     true == is_sub_permutation_map_fst(max_val, nil);
{}

lemma void sub_permutation_map_fst_forall_nil(list< list< pair<int, real> > > xs, int max_val)
    requires    true == forall(xs, (eq)(nil));
    ensures     true == forall(xs, (is_sub_permutation_map_fst)(max_val));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): sub_permutation_map_fst_forall_nil(xs0, max_val);
    }
}

lemma void sub_permutation_map_fst_complete(list< pair<int, real> > xs)
    requires    true == is_sub_permutation_map_fst(length(xs), xs);
    ensures     true == is_permutation_map_fst(xs);
{
    map_preserves_length(fst, xs);
    assert (true == is_sub_permutation(map(fst, xs), length(xs)));
    sub_permutation_complete(map(fst, xs));
}


// ------------- permutations & count -------------

lemma void permutation_to_count(list<int> xs)
    requires    true == is_permutation(xs) &*& 0 < length(xs);
    ensures     true == integer_copies(nat_of_int(length(xs) - 1), 1, xs);
{
    assume (true == integer_copies(nat_of_int(length(xs) - 1), 1, xs));
}

lemma void permutation_list_to_count(list<int> xs, nat nb_split, int n)
    requires    true == forall(split(xs, nb_split, n), is_permutation) &*& 0 < length(xs);
    ensures     true == forall(split(xs, nb_split, n), (integer_copies)(nat_of_int(n - 1), 1));
{
    assume (true == forall(split(xs, nb_split, n), (integer_copies)(nat_of_int(n - 1), 1)));
}

lemma void permutation_split_to_count(list<int> xs, nat nb_split, int n)
    requires    true == forall(split(xs, nb_split, n), is_permutation) &*& 0 < length(xs);
    ensures     true == integer_copies(nat_of_int(n - 1), int_of_nat(nb_split), xs);
{
    assume (true == integer_copies(nat_of_int(n - 1), int_of_nat(nb_split), xs));
}


lemma void copies_to_sub(nat val, int nb_copies, list<int> xs)
    requires    true == integer_copies(val, nb_copies, xs);
    ensures     true == sub_integer_copies(val, nb_copies, xs);
{
    switch(val) {
        case zero:
        case succ(val_pred): copies_to_sub(val_pred, nb_copies, xs);
    }
}

lemma void split_varlim_subcount(list<int> xs, int n, list<int> limits)
    requires    true == forall(split(xs, nat_of_int(length(limits)), n), is_permutation) &*& 0 < n;
    ensures     true == forall(split_varlim(xs, n, limits), (sub_integer_copies)(nat_of_int(n - 1), 1));
{
    assume(true == forall(split_varlim(xs, n, limits), (sub_integer_copies)(nat_of_int(n - 1), 1)));
}

lemma void split_varlim_subpermutation(list<int> xs, int n, list<int> limits, int i)
    requires
        true == forall(split(xs, nat_of_int(length(limits)), n), is_permutation) &*&
        0 < n &*& 0 <= i &*& i < length(limits) &*& 
        0 <= nth(i, limits) &*& nth(i, limits) <= n;
    ensures
        true == is_sub_permutation(nth(i, split_varlim(xs, n, limits)), n);
{
    assume (true == is_sub_permutation(nth(i, split_varlim(xs, n, limits)), n));
}

#endif //_PERMUTATIONS_GH_INCLUDED_
