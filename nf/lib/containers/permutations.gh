#ifndef _PERMUTATIONS_GH_INCLUDED_
#define _PERMUTATIONS_GH_INCLUDED_

#include <nat.gh>
#include "listutils.gh"
#include "transpose.gh"
#include "stdex.gh"
#include "listexex.gh"
#include "set.gh"


// ------------- is_permutation -------------

fixpoint bool is_permutation(list<int> xs) {
    return forall(xs, (lt)(length(xs))) && true == forall(xs, (ge)(0)) && no_dups(xs);
}

// ------------- is_sub_permutation -------------

fixpoint bool is_sub_permutation(list<int> xs, int max_val) {
    return forall(xs, (lt)(max_val)) && true == forall(xs, (ge)(0)) && no_dups(xs);
}

lemma void sub_permutation_complete(list<int> xs)
    requires    true == is_sub_permutation(xs, length(xs));
    ensures     true == is_permutation(xs);
{}

lemma void take_preserves_mem<t>(list<t> tail, t head, int i)
    requires    false == mem(head, tail) &*& 0 <= i;
    ensures     false == mem(head, take(i, tail));
{
    switch(tail) {
        case nil:
        case cons(x0, xs0):
            assert (head != x0);
            if (i > 0) {
            	take_preserves_mem(xs0, head, i-1);
            }
    }
}

lemma void take_preserves_no_dups<t>(list<t> xs, int i)
    requires    true == no_dups(xs) &*& 0 <= i;
    ensures     true == no_dups(take(i, xs));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0):
            if (i > 0) {
                take_preserves_no_dups(xs0, i - 1);
                cons_take_take_cons(x0, xs0, i - 1);
                take_preserves_mem(xs0, x0, i - 1);
            } else {
	            take_0(xs);
            }
    }
}

lemma void sub_permutation_take(list<int> xs, int max_val, int i)
    requires    true == is_sub_permutation(xs, max_val) &*& 0 <= i;
    ensures     true == is_sub_permutation(take(i, xs), max_val);
{
    switch(xs) {
        case nil:
        case cons(x0, xs0):
            if (i <= 0) {
            	assert (take(i, xs) == nil);
            	assert (true == is_sub_permutation(take(i, xs), max_val));
            } else {
                sub_permutation_take(xs0, max_val, i - 1);
                assume (take(i, xs) == append(take(i - 1, xs0), cons(x0, nil)));
                cons_take_take_cons(x0, xs0, i - 1);
                forall_append(take(i - 1, xs0), cons(x0, nil), (lt)(max_val));
                forall_append(take(i - 1, xs0), cons(x0, nil), (ge)(max_val));
		        take_preserves_no_dups(xs, i);
            }
            
    }
}

// ------------- is_sub_permutation2 -------------

fixpoint bool is_sub_permutation2(int max_val, list<int> xs) {
    return is_sub_permutation(xs, max_val);
}

lemma_auto(is_sub_permutation2(max_val, nil)) void sub_permutation2_nil(int max_val)
    requires    true;
    ensures     true == is_sub_permutation2(max_val, nil);
{}

lemma void sub_permutation2_forall_nil(list< list<int> > xs, int max_val)
    requires    true == forall(xs, (eq)(nil));
    ensures     true == forall(xs, (is_sub_permutation2)(max_val));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): sub_permutation2_forall_nil(xs0, max_val);
    }
}

// ------------- is_permutation_map_fst -------------

fixpoint bool is_permutation_map_fst(list< pair<int, real> > xs) {
    return is_permutation(map(fst, xs));
}

lemma void is_permutation_map_fst_extract(list< pair<int, real> > xs, list<int> map_fst)
    requires    map_fst == map(fst, xs) &*& true == is_permutation_map_fst(xs);
    ensures     true == forall(map_fst, (lt)(length(map_fst))) &*& true == forall(map_fst, (ge)(0)) &*& true == no_dups(map_fst);
{}

// ------------- is_sub_permutation_map_fst -------------

fixpoint bool is_sub_permutation_map_fst(int max_val, list< pair<int, real> > xs) {
    return is_sub_permutation(map(fst, xs), max_val);
}

lemma_auto(is_sub_permutation_map_fst(max_val, nil)) void sub_permutation_map_fst_nil(int max_val)
    requires    true;
    ensures     true == is_sub_permutation_map_fst(max_val, nil);
{}

lemma void sub_permutation_map_fst_forall_nil(list< list< pair<int, real> > > xs, int max_val)
    requires    true == forall(xs, (eq)(nil));
    ensures     true == forall(xs, (is_sub_permutation_map_fst)(max_val));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): sub_permutation_map_fst_forall_nil(xs0, max_val);
    }
}

lemma void sub_permutation_map_fst_complete(list< pair<int, real> > xs)
    requires    true == is_sub_permutation_map_fst(length(xs), xs);
    ensures     true == is_permutation_map_fst(xs);
{
    map_preserves_length(fst, xs);
    assert (true == is_sub_permutation(map(fst, xs), length(xs)));
    sub_permutation_complete(map(fst, xs));
}

// ------------- permutations & count -------------

lemma void mem_count_zero<t>(list<t> xs, t elem)
    requires    false == mem(elem, xs);
    ensures     count(xs, (eq)(elem)) == 0;
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): mem_count_zero(xs0, elem);
    }
}

lemma void mem_count_bound<t>(list<t> xs, t elem)
    requires    true == mem(elem, xs);
    ensures     count(xs, (eq)(elem)) >= 1;
{
    switch(xs) {
        case nil:
        case cons(x0, xs0):
            if (x0 != elem) {
                mem_count_bound(xs0, elem);
            } else {
                if (mem(elem, xs0)) {
                    mem_count_bound(xs0, elem);
                } else {
                    mem_count_zero(xs0, elem);
                }
            }

    }
}

lemma void count_no_dups<t>(list<t> xs, t elem)
    requires    true == no_dups(xs);
    ensures     count(xs, (eq)(elem)) <= 1;
{
    switch(xs) {
        case nil:
        case cons(x0, xs0):
            if (x0 != elem) {
                count_no_dups(xs0, elem);
            } else {
                assert (false == mem(elem, xs0));
                mem_count_zero(xs0, elem);
            }

    }
}

lemma void permutation_exists_helper(list<int> xs, list<int> integers, int max_val, int x)
    requires    
        true == is_sub_permutation(xs, max_val) &*& 0 < max_val &*&
        0 <= x &*& x < max_val &*& length(xs) == length(integers) &*& 
        true == subset(xs, integers) &*& true == mem(x, integers);
    ensures
        true == mem(x, xs);
{
    switch(xs) {
        case nil:
            length_0_nil(integers);
            assert (integers == nil);
            assert (false == mem(x, integers));
        case cons(x0, xs0):
            if (x0 == x) {
                assert (true == mem(x, xs));
            } else {
                remove_both_subset(x0, xs, integers);
                neq_mem_remove(x, x0, integers);
                permutation_exists_helper(xs0, remove(x0, integers), max_val, x);
            }
    }
}

lemma void permutation_exists(list<int> xs, int x)
    requires    true == is_permutation(xs) &*& 0 <= x &*& x < length(xs);
    ensures     count(xs, (eq)(x)) == 1;
{
    list<int> integers = integers_list(nat_of_int(length(xs)), 0);
    integers_list_subset(xs, 0, length(xs));
    val_integers_list(nat_of_int(length(xs)), 0, x);
    permutation_exists_helper(xs, integers, length(xs), x);
    count_no_dups(xs, x);
    mem_count_bound(xs, x);
}

lemma void permutation_to_count(list<int> xs, nat val)
    requires    true == is_permutation(xs) &*& 0 < length(xs) &*& int_of_nat(val) <= length(xs) - 1;
    ensures     true == integer_copies(val, 1, xs);
{
    switch(val) {
        case zero:permutation_exists(xs, 0);
        case succ(val_pred): 
            permutation_exists(xs, int_of_nat(val));
            permutation_to_count(xs, val_pred);
    }
}

lemma void permutation_split_to_count(list<int> xs, nat nb_split, int n)
    requires    
        true == forall(split(xs, nb_split, n), is_permutation) &*&
        length(xs) == int_of_nat(nb_split) * n &*&
        0 < n &*& n <= length(xs);
    ensures     
        true == integer_copies(nat_of_int(n - 1), int_of_nat(nb_split), xs);
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred):
            if (nb_split_pred != zero) {
                // Recursive call
                length_drop(n, xs);
                mul_subst(int_of_nat(nb_split_pred) + 1, int_of_nat(nb_split), n);
                mul_equal(n, int_of_nat(nb_split_pred), length(xs) - n);
                permutation_split_to_count(drop(n, xs), nb_split_pred, n);            
            }

            list<int> ret_xs = drop(n, xs);
            list<int> first_chunk = take(n, xs);
            assert (xs == append(first_chunk, ret_xs));

            split_chunk_equiv(xs, nb_split, n, 0);
            permutation_to_count(first_chunk, nat_of_int(length(first_chunk) - 1));
            integer_copies_append(first_chunk, ret_xs, nat_of_int(n - 1), 1, int_of_nat(nb_split_pred));
    }
}

lemma void forall_ge_lower(list<int> xs, int low_bound, int x)
    requires true == forall(xs, (ge)(low_bound)) &*& x < low_bound;
    ensures !mem(x, xs);
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): forall_ge_lower(xs0, low_bound, x);
    }
}

lemma void no_dups_ge(list<int> xs, int low_bound, int x)
    requires true == no_dups(xs) &*& true == forall(xs, (ge)(low_bound)) &*& x < low_bound;
    ensures true == no_dups(cons(x, xs));
{
    forall_ge_lower(xs, low_bound, x);
}

lemma void list_unit_length(list<int> xs)
    requires    length(xs) == 1;
    ensures     xs == cons(nth(0, xs), nil);
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): length_0_nil(xs0);
    }
}

lemma void permutation_from_filter_idx(list<int> xs, nat nb_split, int nb_split_base, int n, int bucket_id, int idx)
    requires    
        true == forall(split(xs, nb_split, n), is_permutation) &*&
        length(xs) == int_of_nat(nb_split) * n &*&
        0 <= bucket_id &*& bucket_id < n &*& 
        idx == nb_split_base * n - length(xs) &*& 0 <= nb_split_base &*& 0 <= idx &*&
        0 < n &*& n <= length(xs);
    ensures     
        true == is_sub_permutation(map( (extract_row)(n) , filter_idx(xs, idx, (eq)(bucket_id)) ), nb_split_base);
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred):
            if (nb_split_pred != zero) {
                // Recursive call
                length_drop(n, xs);
                mul_subst(int_of_nat(nb_split_pred) + 1, int_of_nat(nb_split), n);
                mul_equal(n, int_of_nat(nb_split_pred), length(xs) - n);
                permutation_from_filter_idx(drop(n, xs), nb_split_pred, nb_split_base, n, bucket_id, idx + n);                
            }

            list<int> ret_xs = drop(n, xs);
            list<int> ret_recursive = filter_idx(ret_xs, idx + n, (eq)(bucket_id));
            list<int> map_ret_recursive = map( (extract_row)(n) , ret_recursive );
            assert (true == is_sub_permutation(map_ret_recursive, nb_split_base));

            // Prove that all elements in map_ret_recursive are >= (idx/n) + 1
            filter_idx_ge(ret_xs, idx + n, (eq)(bucket_id));
            extract_row_ge(n, idx, ret_recursive);
            assert (true == forall(map_ret_recursive, (ge)(idx/n + 1)));

            list<int> first_chunk = take(n, xs);
            list<int> filter_first_chunk = filter_idx(first_chunk, idx, (eq)(bucket_id));
            list<int> map_filter_first_chunk = map( (extract_row)(n) , filter_first_chunk );
            split_chunk_equiv(xs, nb_split, n, 0);
            assert (nth(0, split(xs, nb_split, n)) == first_chunk);

            // Prove that length(filter_first_chunk) == 1
            forall_nth(split(xs, nb_split, n), is_permutation, 0);
            permutation_to_count(first_chunk, nat_of_int(length(first_chunk) - 1));
            integer_copies_val(bucket_id, nat_of_int(n - 1), 1, first_chunk);
            filter_idx_length_count_equiv(first_chunk, idx, (eq)(bucket_id));
            map_preserves_length((extract_row)(n), filter_first_chunk);
            assert (length(filter_first_chunk) == 1);

            // Prove that all elements in map_filter_first_chunk are < (idx/n) + 1
            int new_idx = nth(0, filter_first_chunk);
            int map_new_idx = extract_row(n, new_idx);
            nth_map(0, (extract_row)(n), filter_first_chunk);
            filter_idx_lt(first_chunk, idx, (eq)(bucket_id));
            extract_row_lt(n, idx, filter_first_chunk);
            assert (true == forall(map_filter_first_chunk, (lt)(idx/n + 1)));
            forall_nth(map_filter_first_chunk, (lt)((idx/n) + 1), 0);
            assert(map_new_idx < idx/n + 1);
            
            // Prove that map_new_idx isn't in map_ret_recursive
            no_dups_ge(map_ret_recursive, idx/n + 1, map_new_idx);
            list_unit_length(map_filter_first_chunk);
            assert (true == no_dups(append(map_filter_first_chunk, map_ret_recursive)));
            map_append((extract_row)(n), filter_first_chunk, ret_recursive);
            assert (append(map_filter_first_chunk, map_ret_recursive) == map((extract_row)(n), append(filter_first_chunk, ret_recursive)) );
        
            // Append rule for filter_idx
            filter_idx_append(first_chunk, ret_xs, idx, (eq)(bucket_id));
            assert (filter_idx(append(first_chunk, ret_xs), idx, (eq)(bucket_id)) == append(filter_first_chunk, ret_recursive));
            
            // Prove bounds                
            filter_idx_ge(first_chunk, idx, (eq)(bucket_id));
            forall_nth(filter_first_chunk, (ge)(idx), 0);
            assert (new_idx >= 0);

            forall_nth(filter_first_chunk, (lt)(idx + n), 0);
            assert (new_idx < nb_split_base * n);

            div_exact(nb_split_base, n);
            div_lt(new_idx, nb_split_base * n, n);
            div_ge(0, new_idx, n);
            div_zero(n);

            forall_append(map_filter_first_chunk, map_ret_recursive, (ge)(0));
            forall_append(map_filter_first_chunk, map_ret_recursive, (lt)(n));
            assert (true == forall(append(map_filter_first_chunk, map_ret_recursive), (ge)(0)));
            assert (true == forall(append(map_filter_first_chunk, map_ret_recursive), (lt)(nb_split_base)));
    }
}

#endif //_PERMUTATIONS_GH_INCLUDED_
