(set-logic ALL)
(declare-sort Inductive 0)
(declare-fun ctortag (Inductive) Int)
(declare-fun box_int (Int) Inductive)
(declare-fun unbox_int (Inductive) Int)
(assert
   (forall ((var Int))
      (! (= (unbox_int (box_int var)) var) :pattern ((box_int var)))))
(assert
   (forall ((var Inductive))
      (! (= (box_int (unbox_int var)) var) :pattern ((unbox_int var)))))
(declare-fun box_bool (Bool) Inductive)
(declare-fun unbox_bool (Inductive) Bool)
(assert
   (forall ((var Bool))
      (! (= (unbox_bool (box_bool var)) var) :pattern ((box_bool var)))))
(declare-fun box_real (Real) Inductive)
(declare-fun unbox_real (Inductive) Real)
(assert
   (forall ((var Real))
      (! (= (unbox_real (box_real var)) var) :pattern ((box_real var)))))
(assert
   (forall ((var Inductive))
      (! (= (box_real (unbox_real var)) var) :pattern ((unbox_real var)))))
(declare-fun _@ (Inductive Inductive) Inductive)
(declare-fun ancestry (Int) Inductive)
(declare-fun ancester_at (Int Int) Int)
(declare-fun getClass (Int) Int)
(declare-fun class_serial_number (Int) Int)
(declare-fun class_rank (Int) Real)
(declare-fun func_rank (Int) Real)
(declare-fun bitor (Int Int) Int)
(declare-fun bitxor (Int Int) Int)
(declare-fun bitand (Int Int) Int)
(declare-fun bitnot (Int) Int)
(declare-fun arraylength (Int) Int)
(declare-fun shiftleft (Int Int) Int)
(declare-fun shiftright (Int Int) Int)
; Assert: (= (unbox_bool (box_int 0)) false)
(assert (= (unbox_bool (box_int 0)) false))
(declare-fun instanceof (Int Int) Bool)
(declare-fun array_type (Int) Int)
(declare-fun lpm-dir-_2_4-_8-lemmas () Int)
(declare-fun default_value () Inductive)
(declare-fun unit () Inductive)
; disjointness axiom
(assert (= (ctortag unit) 0))
; injectiveness axioms
(declare-fun none () Inductive)
; disjointness axiom
(assert (= (ctortag none) 1))
; injectiveness axioms
(declare-fun some (Inductive) Inductive)
; disjointness axiom
(assert
   (forall ((var Inductive))
      (! (= (ctortag (some var)) 2) :pattern ((some var)))))
; injectiveness axioms
(declare-fun ctorinv (Inductive) Inductive)
(assert
   (forall ((var Inductive))
      (! (= (ctorinv (some var)) var) :pattern ((some var)))))
(declare-fun _@some () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@some var) (some var)) :pattern ((_@ _@some var)))))
(declare-fun pair (Inductive Inductive) Inductive)
; disjointness axiom
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (ctortag (pair var var0)) 3) :pattern ((pair var var0)))))
; injectiveness axioms
(declare-fun ctorinv0 (Inductive) Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (ctorinv0 (pair var var0)) var) :pattern ((pair var var0)))))
(declare-fun ctorinv1 (Inductive) Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (ctorinv1 (pair var var0)) var0) :pattern ((pair var var0)))))
(declare-fun _@pair () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@pair var) var0) (pair var var0))
         :pattern ((_@ (_@ _@pair var) var0)))))
(declare-fun fst (Inductive) Inductive)
(declare-fun _@fst () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@fst var) (fst var)) :pattern ((_@ _@fst var)))))
(declare-fun snd (Inductive) Inductive)
(declare-fun _@snd () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@snd var) (snd var)) :pattern ((_@ _@snd var)))))
(declare-fun boxed_int (Int) Inductive)
; disjointness axiom
(assert
   (forall ((var Int))
      (! (= (ctortag (boxed_int var)) 4) :pattern ((boxed_int var)))))
; injectiveness axioms
(declare-fun ctorinv2 (Inductive) Int)
(assert
   (forall ((var Int))
      (! (= (ctorinv2 (boxed_int var)) var) :pattern ((boxed_int var)))))
(declare-fun _@boxed_int () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@boxed_int (box_int var)) (boxed_int var))
         :pattern ((_@ _@boxed_int (box_int var))))))
(declare-fun unboxed_int (Inductive) Int)
(declare-fun _@unboxed_int () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@unboxed_int var)) (unboxed_int var))
         :pattern ((_@ _@unboxed_int var)))))
(declare-fun boxed_bool (Bool) Inductive)
; disjointness axiom
(assert
   (forall ((var Bool))
      (! (= (ctortag (boxed_bool var)) 5) :pattern ((boxed_bool var)))))
; injectiveness axioms
(declare-fun ctorinv3 (Inductive) Bool)
(assert
   (forall ((var Bool))
      (! (= (ctorinv3 (boxed_bool var)) var) :pattern ((boxed_bool var)))))
(declare-fun _@boxed_bool () Inductive)
(assert
   (forall ((var Bool))
      (! (= (_@ _@boxed_bool (box_bool var)) (boxed_bool var))
         :pattern ((_@ _@boxed_bool (box_bool var))))))
(declare-fun unboxed_bool (Inductive) Bool)
(declare-fun _@unboxed_bool () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_bool (_@ _@unboxed_bool var)) (unboxed_bool var))
         :pattern ((_@ _@unboxed_bool var)))))
(declare-fun boxed_real (Real) Inductive)
; disjointness axiom
(assert
   (forall ((var Real))
      (! (= (ctortag (boxed_real var)) 6) :pattern ((boxed_real var)))))
; injectiveness axioms
(declare-fun ctorinv4 (Inductive) Real)
(assert
   (forall ((var Real))
      (! (= (ctorinv4 (boxed_real var)) var) :pattern ((boxed_real var)))))
(declare-fun _@boxed_real () Inductive)
(assert
   (forall ((var Real))
      (! (= (_@ _@boxed_real (box_real var)) (boxed_real var))
         :pattern ((_@ _@boxed_real (box_real var))))))
(declare-fun unboxed_real (Inductive) Real)
(declare-fun _@unboxed_real () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_real (_@ _@unboxed_real var)) (unboxed_real var))
         :pattern ((_@ _@unboxed_real var)))))
(declare-fun default_value_eq_zero () Int)
; set_fpclauses
; function fst
; switching on argument number 0
; constructor pair
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (fst (pair var var0)) var) :pattern ((fst (pair var var0))))))
; set_fpclauses
; function snd
; switching on argument number 0
; constructor pair
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (snd (pair var var0)) var0) :pattern ((snd (pair var var0))))))
; set_fpclauses
; function unboxed_int
; switching on argument number 0
; constructor boxed_int
(assert
   (forall ((var Int))
      (! (= (unboxed_int (boxed_int var)) var)
         :pattern ((unboxed_int (boxed_int var))))))
; set_fpclauses
; function unboxed_bool
; switching on argument number 0
; constructor boxed_bool
(assert
   (forall ((var Bool))
      (! (= (unboxed_bool (boxed_bool var)) var)
         :pattern ((unboxed_bool (boxed_bool var))))))
; set_fpclauses
; function unboxed_real
; switching on argument number 0
; constructor boxed_real
(assert
   (forall ((var Real))
      (! (= (unboxed_real (boxed_real var)) var)
         :pattern ((unboxed_real (boxed_real var))))))
(declare-fun nil () Inductive)
; disjointness axiom
(assert (= (ctortag nil) 7))
; injectiveness axioms
(declare-fun cons (Inductive Inductive) Inductive)
; disjointness axiom
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (ctortag (cons var var0)) 8) :pattern ((cons var var0)))))
; injectiveness axioms
(declare-fun ctorinv5 (Inductive) Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (ctorinv5 (cons var var0)) var) :pattern ((cons var var0)))))
(declare-fun ctorinv6 (Inductive) Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (ctorinv6 (cons var var0)) var0) :pattern ((cons var var0)))))
(declare-fun _@cons () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@cons var) var0) (cons var var0))
         :pattern ((_@ (_@ _@cons var) var0)))))
(declare-fun head (Inductive) Inductive)
(declare-fun _@head () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@head var) (head var)) :pattern ((_@ _@head var)))))
(declare-fun tail (Inductive) Inductive)
(declare-fun _@tail () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@tail var) (tail var)) :pattern ((_@ _@tail var)))))
(declare-fun length (Inductive) Int)
(declare-fun _@length () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@length var)) (length var))
         :pattern ((_@ _@length var)))))
(declare-fun append (Inductive Inductive) Inductive)
(declare-fun _@append () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@append var) var0) (append var var0))
         :pattern ((_@ (_@ _@append var) var0)))))
(declare-fun reverse (Inductive) Inductive)
(declare-fun _@reverse () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@reverse var) (reverse var)) :pattern ((_@ _@reverse var)))))
(declare-fun mem (Inductive Inductive) Bool)
(declare-fun _@mem () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@mem var) var0)) (mem var var0))
         :pattern ((_@ (_@ _@mem var) var0)))))
(declare-fun nth (Int Inductive) Inductive)
(declare-fun _@nth () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (_@ (_@ _@nth (box_int var)) var0) (nth var var0))
         :pattern ((_@ (_@ _@nth (box_int var)) var0)))))
(declare-fun distinct0 (Inductive) Bool)
(declare-fun _@distinct () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_bool (_@ _@distinct var)) (distinct0 var))
         :pattern ((_@ _@distinct var)))))
(declare-fun take (Int Inductive) Inductive)
(declare-fun _@take () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (_@ (_@ _@take (box_int var)) var0) (take var var0))
         :pattern ((_@ (_@ _@take (box_int var)) var0)))))
(declare-fun drop (Int Inductive) Inductive)
(declare-fun _@drop () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (_@ (_@ _@drop (box_int var)) var0) (drop var var0))
         :pattern ((_@ (_@ _@drop (box_int var)) var0)))))
(declare-fun remove (Inductive Inductive) Inductive)
(declare-fun _@remove () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@remove var) var0) (remove var var0))
         :pattern ((_@ (_@ _@remove var) var0)))))
(declare-fun remove_nth (Int Inductive) Inductive)
(declare-fun _@remove_nth () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (_@ (_@ _@remove_nth (box_int var)) var0) (remove_nth var var0))
         :pattern ((_@ (_@ _@remove_nth (box_int var)) var0)))))
(declare-fun index_of (Inductive Inductive) Int)
(declare-fun _@index_of () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_int (_@ (_@ _@index_of var) var0)) (index_of var var0))
         :pattern ((_@ (_@ _@index_of var) var0)))))
(declare-fun map0 (Inductive Inductive) Inductive)
(declare-fun _@map () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@map var) var0) (map0 var var0))
         :pattern ((_@ (_@ _@map var) var0)))))
(declare-fun forall0 (Inductive Inductive) Bool)
(declare-fun _@forall () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@forall var) var0)) (forall0 var var0))
         :pattern ((_@ (_@ _@forall var) var0)))))
(declare-fun exists0 (Inductive Inductive) Bool)
(declare-fun _@exists () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@exists var) var0)) (exists0 var var0))
         :pattern ((_@ (_@ _@exists var) var0)))))
(declare-fun update (Int Inductive Inductive) Inductive)
(declare-fun _@update () Inductive)
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive))
      (!
         (= (_@ (_@ (_@ _@update (box_int var)) var0) var1)
            (update var var0 var1))
         :pattern ((_@ (_@ (_@ _@update (box_int var)) var0) var1)))))
(declare-fun all_eq (Inductive Inductive) Bool)
(declare-fun _@all_eq () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@all_eq var) var0)) (all_eq var var0))
         :pattern ((_@ (_@ _@all_eq var) var0)))))
(declare-fun count (Inductive Inductive) Int)
(declare-fun _@count () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_int (_@ (_@ _@count var) var0)) (count var var0))
         :pattern ((_@ (_@ _@count var) var0)))))
(declare-fun foreach () Inductive)
(declare-fun length_nonnegative () Int)
(declare-fun append_nil () Int)
(declare-fun append_assoc () Int)
(declare-fun length_append () Int)
(declare-fun nth_append () Int)
(declare-fun nth_append_r () Int)
(declare-fun reverse_append () Int)
(declare-fun reverse_reverse () Int)
(declare-fun mem_nth () Int)
(declare-fun mem_append () Int)
(declare-fun take__0 () Int)
(declare-fun take_length () Int)
(declare-fun length_take () Int)
(declare-fun nth_take () Int)
(declare-fun drop__0 () Int)
(declare-fun drop_n_plus_one () Int)
(declare-fun drop_length () Int)
(declare-fun length_drop () Int)
(declare-fun drop_n_take_n () Int)
(declare-fun length_remove () Int)
(declare-fun drop_take_remove_nth () Int)
(declare-fun append_take_drop_n () Int)
(declare-fun mem_index_of () Int)
(declare-fun foreach_remove () Int)
(declare-fun foreach_unremove () Int)
(declare-fun foreach_append () Int)
(declare-fun nth_update () Int)
(declare-fun length_update () Int)
(declare-fun all_eq_nth () Int)
(declare-fun count_nonnegative () Int)
(declare-fun count_remove () Int)
(declare-fun count_zero_mem () Int)
(declare-fun count_non_zero () Int)
(declare-fun count_append () Int)
; set_fpclauses
; function head
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (head (cons var var0)) var) :pattern ((head (cons var var0))))))
; constructor nil
(assert (= (head nil) default_value))
; set_fpclauses
; function tail
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (tail (cons var var0)) var0) :pattern ((tail (cons var var0))))))
; constructor nil
(assert (= (tail nil) nil))
; set_fpclauses
; function length
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (length (cons var var0)) (+ 1 (length var0)))
         :pattern ((length (cons var var0))))))
; constructor nil
(assert (= (length nil) 0))
; set_fpclauses
; function append
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (! (= (append (cons var var0) var1) (cons var (append var0 var1)))
         :pattern ((append (cons var var0) var1)))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (append nil var) var) :pattern ((append nil var)))))
; set_fpclauses
; function reverse
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (reverse (cons var var0)) (append (reverse var0) (cons var nil)))
         :pattern ((reverse (cons var var0))))))
; constructor nil
(assert (= (reverse nil) nil))
; set_fpclauses
; function mem
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (! (= (mem var (cons var0 var1)) (or (= var var0) (mem var var1)))
         :pattern ((mem var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (mem var nil) false) :pattern ((mem var nil)))))
; set_fpclauses
; function nth
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive))
      (!
         (= (nth var (cons var0 var1))
            (ite (= var 0) var0 (nth (- var 1) var1)))
         :pattern ((nth var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Int))
      (! (= (nth var nil) default_value) :pattern ((nth var nil)))))
; set_fpclauses
; function distinct0
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (distinct0 (cons var var0))
            (and (not (mem var var0)) (distinct0 var0)))
         :pattern ((distinct0 (cons var var0))))))
; constructor nil
(assert (= (distinct0 nil) true))
; set_fpclauses
; function take
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive))
      (!
         (= (take var (cons var0 var1))
            (ite (= var 0) nil (cons var0 (take (- var 1) var1))))
         :pattern ((take var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Int)) (! (= (take var nil) nil) :pattern ((take var nil)))))
; set_fpclauses
; function drop
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive))
      (!
         (= (drop var (cons var0 var1))
            (ite (= var 0) (cons var0 var1) (drop (- var 1) var1)))
         :pattern ((drop var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Int)) (! (= (drop var nil) nil) :pattern ((drop var nil)))))
; set_fpclauses
; function remove
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (remove var (cons var0 var1))
            (ite (= var0 var) var1 (cons var0 (remove var var1))))
         :pattern ((remove var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (remove var nil) nil) :pattern ((remove var nil)))))
; set_fpclauses
; function remove_nth
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive))
      (!
         (= (remove_nth var (cons var0 var1))
            (ite (= var 0) var1 (cons var0 (remove_nth (- var 1) var1))))
         :pattern ((remove_nth var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Int))
      (! (= (remove_nth var nil) nil) :pattern ((remove_nth var nil)))))
; set_fpclauses
; function index_of
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (index_of var (cons var0 var1))
            (ite (= var0 var) 0 (+ 1 (index_of var var1))))
         :pattern ((index_of var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (index_of var nil) 0) :pattern ((index_of var nil)))))
; set_fpclauses
; function map0
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (! (= (map0 var (cons var0 var1)) (cons (_@ var var0) (map0 var var1)))
         :pattern ((map0 var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (map0 var nil) nil) :pattern ((map0 var nil)))))
; set_fpclauses
; function forall0
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (forall0 (cons var var0) var1)
            (and (unbox_bool (_@ var1 var)) (forall0 var0 var1)))
         :pattern ((forall0 (cons var var0) var1)))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (forall0 nil var) true) :pattern ((forall0 nil var)))))
; set_fpclauses
; function exists0
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (exists0 (cons var var0) var1)
            (or (unbox_bool (_@ var1 var)) (exists0 var0 var1)))
         :pattern ((exists0 (cons var var0) var1)))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (exists0 nil var) false) :pattern ((exists0 nil var)))))
; set_fpclauses
; function update
; switching on argument number 2
; constructor cons
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (update var var0 (cons var1 var2))
            (ite (= var 0) (cons var0 var2)
               (cons var1 (update (- var 1) var0 var2))))
         :pattern ((update var var0 (cons var1 var2))))))
; constructor nil
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (update var var0 nil) nil) :pattern ((update var var0 nil)))))
; set_fpclauses
; function all_eq
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (all_eq (cons var var0) var1)
            (and (= var var1) (all_eq var0 var1)))
         :pattern ((all_eq (cons var var0) var1)))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (all_eq nil var) true) :pattern ((all_eq nil var)))))
; set_fpclauses
; function count
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (count (cons var var0) var1)
            (+ (count var0 var1) (ite (unbox_bool (_@ var1 var)) 1 0)))
         :pattern ((count (cons var var0) var1)))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (count nil var) 0) :pattern ((count nil var)))))
; Assert: (< (func_rank length_nonnegative) 0)
(assert (< (func_rank length_nonnegative) 0))
(assert (forall ((var Inductive)) (=> true (<= 0 (length var)))))
; Assert: (< (func_rank append_nil) 0)
(assert (< (func_rank append_nil) 0))
(assert (forall ((var Inductive)) (=> true (= (append var nil) var))))
; Assert: (< (func_rank length_append) 0)
(assert (< (func_rank length_append) 0))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (=> true
            (= (length (append var var0)) (+ (length var) (length var0))))
         :pattern ((length (append var var0))))))
; Assert: (< (func_rank reverse_reverse) 0)
(assert (< (func_rank reverse_reverse) 0))
(assert (forall ((var Inductive)) (=> true (= (reverse (reverse var)) var))))
; Assert: (< (func_rank mem_nth) 0)
(assert (< (func_rank mem_nth) 0))
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (=> (and (<= 0 var) (< var (length var0)))
            (= (mem (nth var var0) var0) true))
         :pattern ((mem (nth var var0) var0)))))
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (=> true
            (= (mem var (append var0 var1))
               (or (mem var var0) (mem var var1))))
         :pattern ((mem var (append var0 var1))))))
; Assert: (< (func_rank take__0) 0)
(assert (< (func_rank take__0) 0))
(assert (forall ((var Inductive)) (=> true (= (take 0 var) nil))))
; Assert: (< (func_rank take_length) 0)
(assert (< (func_rank take_length) 0))
(assert
   (forall ((var Inductive))
      (! (=> true (= (take (length var) var) var))
         :pattern ((take (length var) var)))))
; Assert: (< (func_rank length_take) 0)
(assert (< (func_rank length_take) 0))
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (=> (and (<= 0 var) (<= var (length var0)))
            (= (length (take var var0)) var))
         :pattern ((length (take var var0))))))
; Assert: (< (func_rank nth_take) 0)
(assert (< (func_rank nth_take) 0))
(assert
   (forall ((var Int) (var0 Int) (var1 Inductive))
      (!
         (=> (and (and (<= 0 var) (< var var0)) (<= var0 (length var1)))
            (= (nth var (take var0 var1)) (nth var var1)))
         :pattern ((nth var (take var0 var1))))))
; Assert: (< (func_rank drop__0) 0)
(assert (< (func_rank drop__0) 0))
(assert (forall ((var Inductive)) (=> true (= (drop 0 var) var))))
; Assert: (< (func_rank drop_length) 0)
(assert (< (func_rank drop_length) 0))
(assert
   (forall ((var Inductive))
      (! (=> true (= (drop (length var) var) nil))
         :pattern ((drop (length var) var)))))
; Assert: (< (func_rank length_drop) 0)
(assert (< (func_rank length_drop) 0))
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (=> (and (<= 0 var) (<= var (length var0)))
            (= (length (drop var var0)) (- (length var0) var)))
         :pattern ((length (drop var var0))))))
; Assert: (< (func_rank drop_n_take_n) 0)
(assert (< (func_rank drop_n_take_n) 0))
(assert
   (forall ((var Int) (var0 Inductive))
      (! (=> true (= (drop var (take var var0)) nil))
         :pattern ((drop var (take var var0))))))
; Assert: (< (func_rank length_remove) 0)
(assert (< (func_rank length_remove) 0))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (=> true
            (= (length (remove var var0))
               (ite (mem var var0) (- (length var0) 1) (length var0))))
         :pattern ((length (remove var var0))))))
; Assert: (< (func_rank drop_take_remove_nth) 0)
(assert (< (func_rank drop_take_remove_nth) 0))
(assert
   (forall ((var Inductive) (var0 Int))
      (!
         (=> (and (<= 0 var0) (< var0 (length var)))
            (= (append (take var0 var) (tail (drop var0 var)))
               (remove_nth var0 var)))
         :pattern ((append (take var0 var) (tail (drop var0 var)))))))
; Assert: (< (func_rank append_take_drop_n) 0)
(assert (< (func_rank append_take_drop_n) 0))
(assert
   (forall ((var Inductive) (var0 Int))
      (!
         (=> (and (<= 0 var0) (<= var0 (length var)))
            (= (append (take var0 var) (drop var0 var)) var))
         :pattern ((append (take var0 var) (drop var0 var))))))
; Assert: (< (func_rank mem_index_of) 0)
(assert (< (func_rank mem_index_of) 0))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (=> (= (mem var var0) true)
            (and (<= 0 (index_of var var0))
               (< (index_of var var0) (length var0))))
         :pattern ((index_of var var0)))))
; Assert: (< (func_rank nth_update) 0)
(assert (< (func_rank nth_update) 0))
(assert
   (forall ((var Int) (var0 Int) (var1 Inductive) (var2 Inductive))
      (!
         (=>
            (and (and (and (<= 0 var) (< var (length var2))) (<= 0 var0))
               (< var0 (length var2)))
            (= (nth var (update var0 var1 var2))
               (ite (= var var0) var1 (nth var var2))))
         :pattern ((nth var (update var0 var1 var2))))))
; Assert: (< (func_rank length_update) 0)
(assert (< (func_rank length_update) 0))
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive))
      (! (=> true (= (length (update var var0 var1)) (length var1)))
         :pattern ((length (update var var0 var1))))))
(declare-fun is_main (Int) Bool)
(declare-fun _@is_main () Inductive)
(assert
   (forall ((var Int))
      (! (= (unbox_bool (_@ _@is_main (box_int var))) (is_main var))
         :pattern ((_@ _@is_main (box_int var))))))
(declare-fun truncate_unsigned (Int Int) Int)
(declare-fun _@truncate_unsigned () Inductive)
(assert
   (forall ((var Int) (var0 Int))
      (!
         (=
            (unbox_int
               (_@ (_@ _@truncate_unsigned (box_int var)) (box_int var0)))
            (truncate_unsigned var var0))
         :pattern
         ((_@ (_@ _@truncate_unsigned (box_int var)) (box_int var0))))))
(declare-fun truncate_signed (Int Int) Int)
(declare-fun _@truncate_signed () Inductive)
(assert
   (forall ((var Int) (var0 Int))
      (!
         (=
            (unbox_int
               (_@ (_@ _@truncate_signed (box_int var)) (box_int var0)))
            (truncate_signed var var0))
         :pattern ((_@ (_@ _@truncate_signed (box_int var)) (box_int var0))))))
(declare-fun abs0 (Int) Int)
(declare-fun _@abs () Inductive)
(assert
   (forall ((var Int))
      (! (= (unbox_int (_@ _@abs (box_int var))) (abs0 var))
         :pattern ((_@ _@abs (box_int var))))))
(declare-fun pointer_of_chars (Inductive) Int)
(declare-fun _@pointer_of_chars () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@pointer_of_chars var)) (pointer_of_chars var))
         :pattern ((_@ _@pointer_of_chars var)))))
(declare-fun chars_of_pointer (Int) Inductive)
(declare-fun _@chars_of_pointer () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@chars_of_pointer (box_int var)) (chars_of_pointer var))
         :pattern ((_@ _@chars_of_pointer (box_int var))))))
(declare-fun chars_within_limits (Inductive) Bool)
(declare-fun _@chars_within_limits () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_bool (_@ _@chars_within_limits var))
            (chars_within_limits var))
         :pattern ((_@ _@chars_within_limits var)))))
(declare-fun int_of_chars (Inductive) Int)
(declare-fun _@int_of_chars () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@int_of_chars var)) (int_of_chars var))
         :pattern ((_@ _@int_of_chars var)))))
(declare-fun chars_of_int (Int) Inductive)
(declare-fun _@chars_of_int () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@chars_of_int (box_int var)) (chars_of_int var))
         :pattern ((_@ _@chars_of_int (box_int var))))))
(declare-fun char_of_uchar (Int) Int)
(declare-fun _@char_of_uchar () Inductive)
(assert
   (forall ((var Int))
      (!
         (= (unbox_int (_@ _@char_of_uchar (box_int var)))
            (char_of_uchar var))
         :pattern ((_@ _@char_of_uchar (box_int var))))))
(declare-fun uchar_of_char (Int) Int)
(declare-fun _@uchar_of_char () Inductive)
(assert
   (forall ((var Int))
      (!
         (= (unbox_int (_@ _@uchar_of_char (box_int var)))
            (uchar_of_char var))
         :pattern ((_@ _@uchar_of_char (box_int var))))))
(declare-fun pointers_of_chars (Inductive) Inductive)
(declare-fun _@pointers_of_chars () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@pointers_of_chars var) (pointers_of_chars var))
         :pattern ((_@ _@pointers_of_chars var)))))
(declare-fun chars_of_pointers (Inductive) Inductive)
(declare-fun _@chars_of_pointers () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@chars_of_pointers var) (chars_of_pointers var))
         :pattern ((_@ _@chars_of_pointers var)))))
(declare-fun vararg_int (Int) Inductive)
; disjointness axiom
(assert
   (forall ((var Int))
      (! (= (ctortag (vararg_int var)) 9) :pattern ((vararg_int var)))))
; injectiveness axioms
(declare-fun ctorinv7 (Inductive) Int)
(assert
   (forall ((var Int))
      (! (= (ctorinv7 (vararg_int var)) var) :pattern ((vararg_int var)))))
(declare-fun _@vararg_int () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@vararg_int (box_int var)) (vararg_int var))
         :pattern ((_@ _@vararg_int (box_int var))))))
(declare-fun vararg_uint (Int) Inductive)
; disjointness axiom
(assert
   (forall ((var Int))
      (! (= (ctortag (vararg_uint var)) 10) :pattern ((vararg_uint var)))))
; injectiveness axioms
(declare-fun ctorinv8 (Inductive) Int)
(assert
   (forall ((var Int))
      (! (= (ctorinv8 (vararg_uint var)) var) :pattern ((vararg_uint var)))))
(declare-fun _@vararg_uint () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@vararg_uint (box_int var)) (vararg_uint var))
         :pattern ((_@ _@vararg_uint (box_int var))))))
(declare-fun vararg_pointer (Int) Inductive)
; disjointness axiom
(assert
   (forall ((var Int))
      (! (= (ctortag (vararg_pointer var)) 11)
         :pattern ((vararg_pointer var)))))
; injectiveness axioms
(declare-fun ctorinv9 (Inductive) Int)
(assert
   (forall ((var Int))
      (! (= (ctorinv9 (vararg_pointer var)) var)
         :pattern ((vararg_pointer var)))))
(declare-fun _@vararg_pointer () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@vararg_pointer (box_int var)) (vararg_pointer var))
         :pattern ((_@ _@vararg_pointer (box_int var))))))
(declare-fun func_lt (Int Int) Bool)
(declare-fun _@func_lt () Inductive)
(assert
   (forall ((var Int) (var0 Int))
      (!
         (= (unbox_bool (_@ (_@ _@func_lt (box_int var)) (box_int var0)))
            (func_lt var var0))
         :pattern ((_@ (_@ _@func_lt (box_int var)) (box_int var0))))))
(declare-fun is_action_permission_0 (Inductive) Bool)
(declare-fun _@is_action_permission_0 () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_bool (_@ _@is_action_permission_0 var))
            (is_action_permission_0 var))
         :pattern ((_@ _@is_action_permission_0 var)))))
(declare-fun is_action_permission_1_dispenser (Inductive) Bool)
(declare-fun _@is_action_permission_1_dispenser () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_bool (_@ _@is_action_permission_1_dispenser var))
            (is_action_permission_1_dispenser var))
         :pattern ((_@ _@is_action_permission_1_dispenser var)))))
(declare-fun get_action_permission_1_for_dispenser (Inductive) Inductive)
(declare-fun _@get_action_permission_1_for_dispenser () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (_@ _@get_action_permission_1_for_dispenser var)
            (get_action_permission_1_for_dispenser var))
         :pattern ((_@ _@get_action_permission_1_for_dispenser var)))))
(declare-fun is_action_permission_1 (Inductive) Bool)
(declare-fun _@is_action_permission_1 () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_bool (_@ _@is_action_permission_1 var))
            (is_action_permission_1 var))
         :pattern ((_@ _@is_action_permission_1 var)))))
(declare-fun box_level (Int) Real)
(declare-fun _@box_level () Inductive)
(assert
   (forall ((var Int))
      (! (= (unbox_real (_@ _@box_level (box_int var))) (box_level var))
         :pattern ((_@ _@box_level (box_int var))))))
(declare-fun is_main_full () Inductive)
(declare-fun exists_0 () Inductive)
(declare-fun integer_ () Inductive)
(declare-fun character () Inductive)
(declare-fun u_character () Inductive)
(declare-fun integer () Inductive)
(declare-fun u_integer () Inductive)
(declare-fun llong_integer () Inductive)
(declare-fun u_llong_integer () Inductive)
(declare-fun short_integer () Inductive)
(declare-fun u_short_integer () Inductive)
(declare-fun pointer () Inductive)
(declare-fun float_ () Inductive)
(declare-fun double_ () Inductive)
(declare-fun long_double () Inductive)
(declare-fun chars () Inductive)
(declare-fun uchars () Inductive)
(declare-fun ints () Inductive)
(declare-fun uints () Inductive)
(declare-fun llongs () Inductive)
(declare-fun ullongs () Inductive)
(declare-fun shorts () Inductive)
(declare-fun ushorts () Inductive)
(declare-fun pointers () Inductive)
(declare-fun integers_ () Inductive)
(declare-fun floats () Inductive)
(declare-fun doubles () Inductive)
(declare-fun long_doubles () Inductive)
(declare-fun divrem () Inductive)
(declare-fun malloc_block () Inductive)
(declare-fun malloc_block_chars () Inductive)
(declare-fun malloc_block_uchars () Inductive)
(declare-fun malloc_block_ints () Inductive)
(declare-fun malloc_block_uints () Inductive)
(declare-fun malloc_block_shorts () Inductive)
(declare-fun malloc_block_ushorts () Inductive)
(declare-fun malloc_block_pointers () Inductive)
(declare-fun malloc_block_llongs () Inductive)
(declare-fun malloc_block_ullongs () Inductive)
(declare-fun malloc_block_floats () Inductive)
(declare-fun malloc_block_doubles () Inductive)
(declare-fun malloc_block_long_doubles () Inductive)
(declare-fun string () Inductive)
(declare-fun call_perm_ () Inductive)
(declare-fun call_below_perm_ () Inductive)
(declare-fun module () Inductive)
(declare-fun module_code () Inductive)
(declare-fun argv () Inductive)
(declare-fun is_handle () Inductive)
(declare-fun current_box_level () Inductive)
(declare-fun assume () Int)
(declare-fun mul_mono_l () Int)
(declare-fun div_rem () Int)
(declare-fun div_rem_nonneg () Int)
(declare-fun character_limits () Int)
(declare-fun u_character_limits () Int)
(declare-fun integer_distinct () Int)
(declare-fun integer_unique () Int)
(declare-fun integer_limits () Int)
(declare-fun u_integer_limits () Int)
(declare-fun short_integer_limits () Int)
(declare-fun u_short_integer_limits () Int)
(declare-fun pointer_distinct () Int)
(declare-fun pointer_unique () Int)
(declare-fun pointer_nonzero () Int)
(declare-fun pointer_limits () Int)
(declare-fun pointer_of_chars_of_pointer () Int)
(declare-fun chars_of_pointer_of_chars () Int)
(declare-fun chars_inv () Int)
(declare-fun chars_zero () Int)
(declare-fun chars_limits () Int)
(declare-fun chars_split () Int)
(declare-fun chars_join () Int)
(declare-fun int_of_chars_of_int () Int)
(declare-fun chars_of_int_of_chars () Int)
(declare-fun int_of_chars_injective () Int)
(declare-fun chars_of_int_injective () Int)
(declare-fun chars_of_int_size () Int)
(declare-fun int_of_chars_size () Int)
(declare-fun chars_of_int_char_in_bounds () Int)
(declare-fun chars_to_integer () Int)
(declare-fun chars_to_u_integer () Int)
(declare-fun chars_to_short_integer () Int)
(declare-fun chars_to_u_short_integer () Int)
(declare-fun chars_to_pointer () Int)
(declare-fun chars_to_integer_ () Int)
(declare-fun integer_to_chars () Int)
(declare-fun u_integer_to_chars () Int)
(declare-fun short_integer_to_chars () Int)
(declare-fun u_short_integer_to_chars () Int)
(declare-fun pointer_to_chars () Int)
(declare-fun integer__to_chars () Int)
(declare-fun u_character_to_character () Int)
(declare-fun character_to_u_character () Int)
(declare-fun uchars_inv () Int)
(declare-fun uchars_split () Int)
(declare-fun uchars_join () Int)
(declare-fun ints_inv () Int)
(declare-fun uints_inv () Int)
(declare-fun llongs_inv () Int)
(declare-fun ullongs_inv () Int)
(declare-fun shorts_inv () Int)
(declare-fun ushorts_inv () Int)
(declare-fun pointers_inv () Int)
(declare-fun pointers_limits () Int)
(declare-fun pointers_split () Int)
(declare-fun pointers_join () Int)
(declare-fun map_uchar_of_char_char_of_uchar () Int)
(declare-fun map_char_of_uchar_uchar_of_char () Int)
(declare-fun chars_to_uchars () Int)
(declare-fun uchars_to_chars () Int)
(declare-fun chars_to_ints () Int)
(declare-fun ints_to_chars () Int)
(declare-fun chars_to_uints () Int)
(declare-fun uints_to_chars () Int)
(declare-fun chars_to_integers_ () Int)
(declare-fun integers__to_chars () Int)
(declare-fun uchars_to_integers_ () Int)
(declare-fun integers__to_uchars () Int)
(declare-fun chars_to_pointers () Int)
(declare-fun pointers_to_chars () Int)
(declare-fun integers__inv () Int)
(declare-fun divrem_intro () Int)
(declare-fun divrem_elim () Int)
(declare-fun string_to_body_chars () Int)
(declare-fun body_chars_to_string () Int)
(declare-fun chars_to_string () Int)
(declare-fun string_to_chars () Int)
(declare-fun chars_separate_string () Int)
(declare-fun chars_unseparate_string () Int)
(declare-fun string_limits () Int)
(declare-fun action_permission_0_unique () Int)
(declare-fun action_permission_1_split () Int)
(declare-fun action_permission_1_split_2 () Int)
(declare-fun action_permission_1_merge () Int)
(declare-fun action_permission_1_unique () Int)
(declare-fun is_handle_unique () Int)
(declare-fun box_level_unique () Int)
(assert
   (forall ((var Int))
      (! (= (abs0 var) (ite (< var 0) (- 0 var) var)) :pattern ((abs0 var)))))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
; Assert: (< (func_rank pointer_nonzero) 0)
(assert (< (func_rank pointer_nonzero) 0))
; Assert: (< (func_rank pointer_of_chars_of_pointer) 0)
(assert (< (func_rank pointer_of_chars_of_pointer) 0))
(assert
   (forall ((var Int))
      (!
         (=> (and (<= 0 var) (<= var 4294967295))
            (and
               (and (= (pointer_of_chars (chars_of_pointer var)) var)
                  (= (chars_within_limits (chars_of_pointer var)) true))
               (= (length (chars_of_pointer var)) 4)))
         :pattern ((pointer_of_chars (chars_of_pointer var))))))
; Assert: (< (func_rank chars_of_pointer_of_chars) 0)
(assert (< (func_rank chars_of_pointer_of_chars) 0))
(assert
   (forall ((var Inductive))
      (!
         (=> (and (= (length var) 4) (= (chars_within_limits var) true))
            (= (chars_of_pointer (pointer_of_chars var)) var))
         :pattern ((chars_of_pointer (pointer_of_chars var))))))
; Assert: (< (func_rank chars_inv) 0)
(assert (< (func_rank chars_inv) 0))
; Assert: (< (func_rank chars_split) 0)
(assert (< (func_rank chars_split) 0))
; Assert: (< (func_rank chars_join) 0)
(assert (< (func_rank chars_join) 0))
; Assert: (< (func_rank int_of_chars_of_int) 0)
(assert (< (func_rank int_of_chars_of_int) 0))
(assert
   (forall ((var Int))
      (!
         (=> (and (<= (- 2147483648) var) (<= var 2147483647))
            (= var (int_of_chars (chars_of_int var))))
         :pattern ((int_of_chars (chars_of_int var))))))
; Assert: (< (func_rank chars_of_int_of_chars) 0)
(assert (< (func_rank chars_of_int_of_chars) 0))
(assert
   (forall ((var Inductive))
      (! (=> true (= var (chars_of_int (int_of_chars var))))
         :pattern ((chars_of_int (int_of_chars var))))))
; Assert: (< (func_rank chars_of_int_size) 0)
(assert (< (func_rank chars_of_int_size) 0))
(assert
   (forall ((var Int))
      (=> (and (<= (- 2147483648) var) (<= var 2147483647))
         (= (length (chars_of_int var)) 4))))
; Assert: (< (func_rank int_of_chars_size) 0)
(assert (< (func_rank int_of_chars_size) 0))
(assert
   (forall ((var Inductive))
      (=> (and (= (length var) 4) (chars_within_limits var))
         (and (<= (- 2147483648) (int_of_chars var))
            (<= (int_of_chars var) 2147483647)))))
; Assert: (< (func_rank chars_to_integer) 0)
(assert (< (func_rank chars_to_integer) 0))
; Assert: (< (func_rank chars_to_u_integer) 0)
(assert (< (func_rank chars_to_u_integer) 0))
; Assert: (< (func_rank chars_to_short_integer) 0)
(assert (< (func_rank chars_to_short_integer) 0))
; Assert: (< (func_rank chars_to_u_short_integer) 0)
(assert (< (func_rank chars_to_u_short_integer) 0))
; Assert: (< (func_rank chars_to_pointer) 0)
(assert (< (func_rank chars_to_pointer) 0))
; Assert: (< (func_rank chars_to_integer_) 0)
(assert (< (func_rank chars_to_integer_) 0))
; Assert: (< (func_rank integer_to_chars) 0)
(assert (< (func_rank integer_to_chars) 0))
; Assert: (< (func_rank u_integer_to_chars) 0)
(assert (< (func_rank u_integer_to_chars) 0))
; Assert: (< (func_rank short_integer_to_chars) 0)
(assert (< (func_rank short_integer_to_chars) 0))
; Assert: (< (func_rank u_short_integer_to_chars) 0)
(assert (< (func_rank u_short_integer_to_chars) 0))
; Assert: (< (func_rank pointer_to_chars) 0)
(assert (< (func_rank pointer_to_chars) 0))
; Assert: (< (func_rank integer__to_chars) 0)
(assert (< (func_rank integer__to_chars) 0))
; Assert: (< (func_rank u_character_to_character) 0)
(assert (< (func_rank u_character_to_character) 0))
; Assert: (< (func_rank character_to_u_character) 0)
(assert (< (func_rank character_to_u_character) 0))
; Assert: (< (func_rank uchars_inv) 0)
(assert (< (func_rank uchars_inv) 0))
; Assert: (< (func_rank uchars_split) 0)
(assert (< (func_rank uchars_split) 0))
; Assert: (< (func_rank uchars_join) 0)
(assert (< (func_rank uchars_join) 0))
; Assert: (< (func_rank ints_inv) 0)
(assert (< (func_rank ints_inv) 0))
; Assert: (< (func_rank uints_inv) 0)
(assert (< (func_rank uints_inv) 0))
; Assert: (< (func_rank llongs_inv) 0)
(assert (< (func_rank llongs_inv) 0))
; Assert: (< (func_rank ullongs_inv) 0)
(assert (< (func_rank ullongs_inv) 0))
; Assert: (< (func_rank shorts_inv) 0)
(assert (< (func_rank shorts_inv) 0))
; Assert: (< (func_rank ushorts_inv) 0)
(assert (< (func_rank ushorts_inv) 0))
; Assert: (< (func_rank pointers_inv) 0)
(assert (< (func_rank pointers_inv) 0))
; Assert: (< (func_rank pointers_split) 0)
(assert (< (func_rank pointers_split) 0))
; Assert: (< (func_rank pointers_join) 0)
(assert (< (func_rank pointers_join) 0))
; Assert: (< (func_rank map_uchar_of_char_char_of_uchar) 0)
(assert (< (func_rank map_uchar_of_char_char_of_uchar) 0))
(assert
   (forall ((var Inductive))
      (=> true (= (map0 _@uchar_of_char (map0 _@char_of_uchar var)) var))))
; Assert: (< (func_rank map_char_of_uchar_uchar_of_char) 0)
(assert (< (func_rank map_char_of_uchar_uchar_of_char) 0))
(assert
   (forall ((var Inductive))
      (=> true (= (map0 _@char_of_uchar (map0 _@uchar_of_char var)) var))))
; Assert: (< (func_rank chars_to_uchars) 0)
(assert (< (func_rank chars_to_uchars) 0))
; Assert: (< (func_rank uchars_to_chars) 0)
(assert (< (func_rank uchars_to_chars) 0))
; Assert: (< (func_rank chars_to_ints) 0)
(assert (< (func_rank chars_to_ints) 0))
; Assert: (< (func_rank ints_to_chars) 0)
(assert (< (func_rank ints_to_chars) 0))
; Assert: (< (func_rank chars_to_uints) 0)
(assert (< (func_rank chars_to_uints) 0))
; Assert: (< (func_rank uints_to_chars) 0)
(assert (< (func_rank uints_to_chars) 0))
; Assert: (< (func_rank chars_to_integers_) 0)
(assert (< (func_rank chars_to_integers_) 0))
; Assert: (< (func_rank integers__to_chars) 0)
(assert (< (func_rank integers__to_chars) 0))
; Assert: (< (func_rank uchars_to_integers_) 0)
(assert (< (func_rank uchars_to_integers_) 0))
; Assert: (< (func_rank integers__to_uchars) 0)
(assert (< (func_rank integers__to_uchars) 0))
; Assert: (< (func_rank chars_to_pointers) 0)
(assert (< (func_rank chars_to_pointers) 0))
; Assert: (< (func_rank pointers_to_chars) 0)
(assert (< (func_rank pointers_to_chars) 0))
; Assert: (< (func_rank integers__inv) 0)
(assert (< (func_rank integers__inv) 0))
; Assert: (< (func_rank divrem_elim) 0)
(assert (< (func_rank divrem_elim) 0))
; Assert: (< (func_rank string_to_body_chars) 0)
(assert (< (func_rank string_to_body_chars) 0))
; Assert: (< (func_rank body_chars_to_string) 0)
(assert (< (func_rank body_chars_to_string) 0))
; Assert: (< (func_rank chars_to_string) 0)
(assert (< (func_rank chars_to_string) 0))
; Assert: (< (func_rank string_to_chars) 0)
(assert (< (func_rank string_to_chars) 0))
; Assert: (< (func_rank chars_separate_string) 0)
(assert (< (func_rank chars_separate_string) 0))
; Assert: (< (func_rank chars_unseparate_string) 0)
(assert (< (func_rank chars_unseparate_string) 0))
(declare-fun zero () Inductive)
; disjointness axiom
(assert (= (ctortag zero) 12))
; injectiveness axioms
(declare-fun succ (Inductive) Inductive)
; disjointness axiom
(assert
   (forall ((var Inductive))
      (! (= (ctortag (succ var)) 13) :pattern ((succ var)))))
; injectiveness axioms
(declare-fun ctorinv10 (Inductive) Inductive)
(assert
   (forall ((var Inductive))
      (! (= (ctorinv10 (succ var)) var) :pattern ((succ var)))))
(declare-fun _@succ () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@succ var) (succ var)) :pattern ((_@ _@succ var)))))
(declare-fun nat_plus (Inductive Inductive) Inductive)
(declare-fun _@nat_plus () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@nat_plus var) var0) (nat_plus var var0))
         :pattern ((_@ (_@ _@nat_plus var) var0)))))
(declare-fun nat_minus (Inductive Inductive) Inductive)
(declare-fun _@nat_minus () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@nat_minus var) var0) (nat_minus var var0))
         :pattern ((_@ (_@ _@nat_minus var) var0)))))
(declare-fun nat_predecessor (Inductive) Inductive)
(declare-fun _@nat_predecessor () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@nat_predecessor var) (nat_predecessor var))
         :pattern ((_@ _@nat_predecessor var)))))
(declare-fun nat_double (Inductive) Inductive)
(declare-fun _@nat_double () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@nat_double var) (nat_double var))
         :pattern ((_@ _@nat_double var)))))
(declare-fun nat_times (Inductive Inductive) Inductive)
(declare-fun _@nat_times () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@nat_times var) var0) (nat_times var var0))
         :pattern ((_@ (_@ _@nat_times var) var0)))))
(declare-fun N_0 () Inductive)
(declare-fun N_1 () Inductive)
(declare-fun N_2 () Inductive)
(declare-fun N_3 () Inductive)
(declare-fun N_4 () Inductive)
(declare-fun N_5 () Inductive)
(declare-fun N_6 () Inductive)
(declare-fun N_7 () Inductive)
(declare-fun N_8 () Inductive)
(declare-fun N_9 () Inductive)
(declare-fun N_1_0 () Inductive)
(declare-fun N_1_1 () Inductive)
(declare-fun N_1_2 () Inductive)
(declare-fun N_1_3 () Inductive)
(declare-fun N_1_4 () Inductive)
(declare-fun N_1_5 () Inductive)
(declare-fun NxA () Inductive)
(declare-fun NxB () Inductive)
(declare-fun NxC () Inductive)
(declare-fun NxD () Inductive)
(declare-fun NxE () Inductive)
(declare-fun NxF () Inductive)
(declare-fun N_1_6 () Inductive)
(declare-fun N_3_2 () Inductive)
(declare-fun N_3_1 () Inductive)
(declare-fun N_6_4 () Inductive)
(declare-fun N_6_3 () Inductive)
(declare-fun N_1_2_8 () Inductive)
(declare-fun N_1_2_7 () Inductive)
(declare-fun nat_of_digits_little_endian (Inductive Inductive) Inductive)
(declare-fun _@nat_of_digits_little_endian () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (_@ (_@ _@nat_of_digits_little_endian var) var0)
            (nat_of_digits_little_endian var var0))
         :pattern ((_@ (_@ _@nat_of_digits_little_endian var) var0)))))
(declare-fun nat_of_digits (Inductive Inductive) Inductive)
(declare-fun _@nat_of_digits () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@nat_of_digits var) var0) (nat_of_digits var var0))
         :pattern ((_@ (_@ _@nat_of_digits var) var0)))))
(declare-fun Nbin (Inductive) Inductive)
(declare-fun _@Nbin () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@Nbin var) (Nbin var)) :pattern ((_@ _@Nbin var)))))
(declare-fun Ndec (Inductive) Inductive)
(declare-fun _@Ndec () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@Ndec var) (Ndec var)) :pattern ((_@ _@Ndec var)))))
(declare-fun Nhex (Inductive) Inductive)
(declare-fun _@Nhex () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@Nhex var) (Nhex var)) :pattern ((_@ _@Nhex var)))))
(declare-fun int_of_nat (Inductive) Int)
(declare-fun _@int_of_nat () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@int_of_nat var)) (int_of_nat var))
         :pattern ((_@ _@int_of_nat var)))))
(declare-fun nat_of_int (Int) Inductive)
(declare-fun _@nat_of_int () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@nat_of_int (box_int var)) (nat_of_int var))
         :pattern ((_@ _@nat_of_int (box_int var))))))
(declare-fun pow_nat (Int Inductive) Int)
(declare-fun _@pow_nat () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (unbox_int (_@ (_@ _@pow_nat (box_int var)) var0))
            (pow_nat var var0))
         :pattern ((_@ (_@ _@pow_nat (box_int var)) var0)))))
(declare-fun int_of_nat_of_int () Int)
(declare-fun nat_of_int_of_nat () Int)
(declare-fun nat_of_zero () Int)
(declare-fun nat_of__1 () Int)
(declare-fun nat_of__2 () Int)
(declare-fun nat_of__3 () Int)
(declare-fun nat_of__4 () Int)
(declare-fun nat_of__5 () Int)
(declare-fun nat_of__6 () Int)
(declare-fun nat_of__7 () Int)
(declare-fun nat_of__8 () Int)
(declare-fun nat_of__9 () Int)
(declare-fun nat_of__1_0 () Int)
(declare-fun nat_of__1_1 () Int)
(declare-fun nat_of__1_2 () Int)
(declare-fun nat_of__1_3 () Int)
(declare-fun nat_of__1_4 () Int)
(declare-fun nat_of__1_5 () Int)
(declare-fun nat_of__1_6 () Int)
(declare-fun nat_of__3_1 () Int)
(declare-fun nat_of__3_2 () Int)
(declare-fun nat_of__6_3 () Int)
(declare-fun nat_of__6_4 () Int)
(declare-fun nat_of__1_2_7 () Int)
(declare-fun nat_of__1_2_8 () Int)
(declare-fun int_of_nat_nonnegative () Int)
(declare-fun succ_int () Int)
(declare-fun pow_nat_nonnegative () Int)
(declare-fun pow_nat_nat_minus () Int)
; set_fpclauses
; function nat_plus
; switching on argument number 0
; constructor succ
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (nat_plus (succ var) var0) (nat_plus var (succ var0)))
         :pattern ((nat_plus (succ var) var0)))))
; constructor zero
(assert
   (forall ((var Inductive))
      (! (= (nat_plus zero var) var) :pattern ((nat_plus zero var)))))
(declare-fun switch_expression (Inductive Inductive Inductive Inductive)
   Inductive)
; set_fpclauses
; function switch_expression
; switching on argument number 0
; constructor zero
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (! (= (switch_expression zero var var0 var1) var0)
         :pattern ((switch_expression zero var var0 var1)))))
; constructor succ
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (switch_expression (succ var) var0 var1 var2)
            (nat_minus var2 var))
         :pattern ((switch_expression (succ var) var0 var1 var2)))))
; set_fpclauses
; function nat_minus
; switching on argument number 0
; constructor succ
(declare-fun switch_expression_0 (Inductive Inductive Inductive Inductive)
   Inductive)
; set_fpclauses
; function switch_expression_0
; switching on argument number 0
; constructor zero
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (! (= (switch_expression_0 zero var var0 var1) var0)
         :pattern ((switch_expression_0 zero var var0 var1)))))
; constructor succ
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (switch_expression_0 (succ var) var0 var1 var2)
            (nat_minus var2 var))
         :pattern ((switch_expression_0 (succ var) var0 var1 var2)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (nat_minus (succ var) var0)
            (switch_expression_0 var0 var0 (succ var) var))
         :pattern ((nat_minus (succ var) var0)))))
; constructor zero
(assert
   (forall ((var Inductive))
      (! (= (nat_minus zero var) zero) :pattern ((nat_minus zero var)))))
; set_fpclauses
; function nat_predecessor
; switching on argument number 0
; constructor succ
(assert
   (forall ((var Inductive))
      (! (= (nat_predecessor (succ var)) var)
         :pattern ((nat_predecessor (succ var))))))
; constructor zero
(assert (= (nat_predecessor zero) zero))
(assert
   (forall ((var Inductive))
      (! (= (nat_double var) (nat_plus var var)) :pattern ((nat_double var)))))
; set_fpclauses
; function nat_times
; switching on argument number 0
; constructor succ
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (nat_times (succ var) var0) (nat_plus var0 (nat_times var var0)))
         :pattern ((nat_times (succ var) var0)))))
; constructor zero
(assert
   (forall ((var Inductive))
      (! (= (nat_times zero var) zero) :pattern ((nat_times zero var)))))
(assert (= N_0 zero))
(assert (= N_1 (succ N_0)))
(assert (= N_2 (succ N_1)))
(assert (= N_3 (succ N_2)))
(assert (= N_4 (succ N_3)))
(assert (= N_5 (succ N_4)))
(assert (= N_6 (succ N_5)))
(assert (= N_7 (succ N_6)))
(assert (= N_8 (succ N_7)))
(assert (= N_9 (succ N_8)))
(assert (= N_1_0 (succ N_9)))
(assert (= N_1_1 (succ N_1_0)))
(assert (= N_1_2 (succ N_1_1)))
(assert (= N_1_3 (succ N_1_2)))
(assert (= N_1_4 (succ N_1_3)))
(assert (= N_1_5 (succ N_1_4)))
(assert (= NxA N_1_0))
(assert (= NxB N_1_1))
(assert (= NxC N_1_2))
(assert (= NxD N_1_3))
(assert (= NxE N_1_4))
(assert (= NxF N_1_5))
(assert (= N_1_6 (succ N_1_5)))
(assert (= N_3_2 (nat_double N_1_6)))
(assert (= N_3_1 (nat_predecessor N_3_2)))
(assert (= N_6_4 (nat_double N_3_2)))
(assert (= N_6_3 (nat_predecessor N_6_4)))
(assert (= N_1_2_8 (nat_double N_6_4)))
(assert (= N_1_2_7 (nat_predecessor N_1_2_8)))
; set_fpclauses
; function nat_of_digits_little_endian
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (nat_of_digits_little_endian var (cons var0 var1))
            (nat_plus var0
               (nat_times var (nat_of_digits_little_endian var var1))))
         :pattern ((nat_of_digits_little_endian var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (nat_of_digits_little_endian var nil) zero)
         :pattern ((nat_of_digits_little_endian var nil)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (nat_of_digits var var0)
            (nat_of_digits_little_endian var (reverse var0)))
         :pattern ((nat_of_digits var var0)))))
(assert
   (forall ((var Inductive))
      (! (= (Nbin var) (nat_of_digits N_2 var)) :pattern ((Nbin var)))))
(assert
   (forall ((var Inductive))
      (! (= (Ndec var) (nat_of_digits N_1_0 var)) :pattern ((Ndec var)))))
(assert
   (forall ((var Inductive))
      (! (= (Nhex var) (nat_of_digits N_1_6 var)) :pattern ((Nhex var)))))
; set_fpclauses
; function int_of_nat
; switching on argument number 0
; constructor succ
(assert
   (forall ((var Inductive))
      (! (= (int_of_nat (succ var)) (+ 1 (int_of_nat var)))
         :pattern ((int_of_nat (succ var))))))
; constructor zero
(assert (= (int_of_nat zero) 0))
; set_fpclauses
; function pow_nat
; switching on argument number 1
; constructor succ
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (pow_nat var (succ var0)) (* var (pow_nat var var0)))
         :pattern ((pow_nat var (succ var0))))))
; constructor zero
(assert
   (forall ((var Int))
      (! (= (pow_nat var zero) 1) :pattern ((pow_nat var zero)))))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
; Assert: (< (func_rank int_of_nat_of_int) 0)
(assert (< (func_rank int_of_nat_of_int) 0))
(assert
   (forall ((var Int))
      (! (=> (<= 0 var) (= (int_of_nat (nat_of_int var)) var))
         :pattern ((int_of_nat (nat_of_int var))))))
; Assert: (< (func_rank nat_of_int_of_nat) 0)
(assert (< (func_rank nat_of_int_of_nat) 0))
(assert
   (forall ((var Inductive))
      (! (=> true (= (nat_of_int (int_of_nat var)) var))
         :pattern ((nat_of_int (int_of_nat var))))))
; Assert: (< (func_rank nat_of_zero) 0)
(assert (< (func_rank nat_of_zero) 0))
(assert (=> true (= (nat_of_int 0) N_0)))
; Assert: (< (func_rank nat_of__1) 0)
(assert (< (func_rank nat_of__1) 0))
(assert (=> true (= (nat_of_int 1) N_1)))
; Assert: (< (func_rank nat_of__2) 0)
(assert (< (func_rank nat_of__2) 0))
(assert (=> true (= (nat_of_int 2) N_2)))
; Assert: (< (func_rank nat_of__3) 0)
(assert (< (func_rank nat_of__3) 0))
(assert (=> true (= (nat_of_int 3) N_3)))
; Assert: (< (func_rank nat_of__4) 0)
(assert (< (func_rank nat_of__4) 0))
(assert (=> true (= (nat_of_int 4) N_4)))
; Assert: (< (func_rank nat_of__5) 0)
(assert (< (func_rank nat_of__5) 0))
(assert (=> true (= (nat_of_int 5) N_5)))
; Assert: (< (func_rank nat_of__6) 0)
(assert (< (func_rank nat_of__6) 0))
(assert (=> true (= (nat_of_int 6) N_6)))
; Assert: (< (func_rank nat_of__7) 0)
(assert (< (func_rank nat_of__7) 0))
(assert (=> true (= (nat_of_int 7) N_7)))
; Assert: (< (func_rank nat_of__8) 0)
(assert (< (func_rank nat_of__8) 0))
(assert (=> true (= (nat_of_int 8) N_8)))
; Assert: (< (func_rank nat_of__9) 0)
(assert (< (func_rank nat_of__9) 0))
(assert (=> true (= (nat_of_int 9) N_9)))
; Assert: (< (func_rank nat_of__1_0) 0)
(assert (< (func_rank nat_of__1_0) 0))
(assert (=> true (= (nat_of_int 10) N_1_0)))
; Assert: (< (func_rank nat_of__1_1) 0)
(assert (< (func_rank nat_of__1_1) 0))
(assert (=> true (= (nat_of_int 11) N_1_1)))
; Assert: (< (func_rank nat_of__1_2) 0)
(assert (< (func_rank nat_of__1_2) 0))
(assert (=> true (= (nat_of_int 12) N_1_2)))
; Assert: (< (func_rank nat_of__1_3) 0)
(assert (< (func_rank nat_of__1_3) 0))
(assert (=> true (= (nat_of_int 13) N_1_3)))
; Assert: (< (func_rank nat_of__1_4) 0)
(assert (< (func_rank nat_of__1_4) 0))
(assert (=> true (= (nat_of_int 14) N_1_4)))
; Assert: (< (func_rank nat_of__1_5) 0)
(assert (< (func_rank nat_of__1_5) 0))
(assert (=> true (= (nat_of_int 15) N_1_5)))
; Assert: (< (func_rank nat_of__1_6) 0)
(assert (< (func_rank nat_of__1_6) 0))
(assert (=> true (= (nat_of_int 16) N_1_6)))
; Assert: (< (func_rank nat_of__3_1) 0)
(assert (< (func_rank nat_of__3_1) 0))
(assert (=> true (= (nat_of_int 31) N_3_1)))
; Assert: (< (func_rank nat_of__3_2) 0)
(assert (< (func_rank nat_of__3_2) 0))
(assert (=> true (= (nat_of_int 32) N_3_2)))
; Assert: (< (func_rank nat_of__6_3) 0)
(assert (< (func_rank nat_of__6_3) 0))
(assert (=> true (= (nat_of_int 63) N_6_3)))
; Assert: (< (func_rank nat_of__6_4) 0)
(assert (< (func_rank nat_of__6_4) 0))
(assert (=> true (= (nat_of_int 64) N_6_4)))
; Assert: (< (func_rank nat_of__1_2_7) 0)
(assert (< (func_rank nat_of__1_2_7) 0))
(assert (=> true (= (nat_of_int 127) N_1_2_7)))
; Assert: (< (func_rank nat_of__1_2_8) 0)
(assert (< (func_rank nat_of__1_2_8) 0))
(assert (=> true (= (nat_of_int 128) N_1_2_8)))
; Assert: (< (func_rank int_of_nat_nonnegative) 0)
(assert (< (func_rank int_of_nat_nonnegative) 0))
(assert (forall ((var Inductive)) (=> true (<= 0 (int_of_nat var)))))
; Assert: (< (func_rank succ_int) 0)
(assert (< (func_rank succ_int) 0))
(assert
   (forall ((var Int))
      (! (=> (<= 0 var) (= (nat_of_int (+ var 1)) (succ (nat_of_int var))))
         :pattern ((succ (nat_of_int var))))))
; Assert: (< (func_rank pow_nat_nonnegative) 0)
(assert (< (func_rank pow_nat_nonnegative) 0))
(assert
   (forall ((var Int) (var0 Inductive))
      (=> (<= 0 var) (<= 0 (pow_nat var var0)))))
(declare-fun Zsign (Bool) Inductive)
; disjointness axiom
(assert
   (forall ((var Bool))
      (! (= (ctortag (Zsign var)) 14) :pattern ((Zsign var)))))
; injectiveness axioms
(declare-fun ctorinv11 (Inductive) Bool)
(assert
   (forall ((var Bool))
      (! (= (ctorinv11 (Zsign var)) var) :pattern ((Zsign var)))))
(declare-fun _@Zsign () Inductive)
(assert
   (forall ((var Bool))
      (! (= (_@ _@Zsign (box_bool var)) (Zsign var))
         :pattern ((_@ _@Zsign (box_bool var))))))
(declare-fun Zdigit (Inductive Bool) Inductive)
; disjointness axiom
(assert
   (forall ((var Inductive) (var0 Bool))
      (! (= (ctortag (Zdigit var var0)) 15) :pattern ((Zdigit var var0)))))
; injectiveness axioms
(declare-fun ctorinv12 (Inductive) Inductive)
(assert
   (forall ((var Inductive) (var0 Bool))
      (! (= (ctorinv12 (Zdigit var var0)) var) :pattern ((Zdigit var var0)))))
(declare-fun ctorinv13 (Inductive) Bool)
(assert
   (forall ((var Inductive) (var0 Bool))
      (! (= (ctorinv13 (Zdigit var var0)) var0) :pattern ((Zdigit var var0)))))
(declare-fun _@Zdigit () Inductive)
(assert
   (forall ((var Inductive) (var0 Bool))
      (! (= (_@ (_@ _@Zdigit var) (box_bool var0)) (Zdigit var var0))
         :pattern ((_@ (_@ _@Zdigit var) (box_bool var0))))))
(declare-fun int_of_Z (Inductive) Int)
(declare-fun _@int_of_Z () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@int_of_Z var)) (int_of_Z var))
         :pattern ((_@ _@int_of_Z var)))))
(declare-fun Z_and (Inductive Inductive) Inductive)
(declare-fun _@Z_and () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@Z_and var) var0) (Z_and var var0))
         :pattern ((_@ (_@ _@Z_and var) var0)))))
(declare-fun Z_not (Inductive) Inductive)
(declare-fun _@Z_not () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@Z_not var) (Z_not var)) :pattern ((_@ _@Z_not var)))))
(declare-fun Z_xor (Inductive Inductive) Inductive)
(declare-fun _@Z_xor () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@Z_xor var) var0) (Z_xor var var0))
         :pattern ((_@ (_@ _@Z_xor var) var0)))))
(declare-fun Z_or (Inductive Inductive) Inductive)
(declare-fun _@Z_or () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@Z_or var) var0) (Z_or var var0))
         :pattern ((_@ (_@ _@Z_or var) var0)))))
(declare-fun Z_shiftright (Inductive Inductive) Inductive)
(declare-fun _@Z_shiftright () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@Z_shiftright var) var0) (Z_shiftright var var0))
         :pattern ((_@ (_@ _@Z_shiftright var) var0)))))
(declare-fun Z_truncate_signed (Inductive Inductive) Inductive)
(declare-fun _@Z_truncate_signed () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (_@ (_@ _@Z_truncate_signed var) var0)
            (Z_truncate_signed var var0))
         :pattern ((_@ (_@ _@Z_truncate_signed var) var0)))))
(declare-fun bits_of_int (Int Inductive) Inductive)
(declare-fun _@bits_of_int () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (_@ (_@ _@bits_of_int (box_int var)) var0)
            (bits_of_int var var0))
         :pattern ((_@ (_@ _@bits_of_int (box_int var)) var0)))))
(declare-fun int_of_bits (Int Inductive) Int)
(declare-fun _@int_of_bits () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (unbox_int (_@ (_@ _@int_of_bits (box_int var)) var0))
            (int_of_bits var var0))
         :pattern ((_@ (_@ _@int_of_bits (box_int var)) var0)))))
(declare-fun Z_of_bits (Inductive Inductive) Inductive)
(declare-fun _@Z_of_bits () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@Z_of_bits var) var0) (Z_of_bits var var0))
         :pattern ((_@ (_@ _@Z_of_bits var) var0)))))
(declare-fun bitand_def () Int)
(declare-fun bitnot_def () Int)
(declare-fun bitxor_def () Int)
(declare-fun bitor_def () Int)
(declare-fun shiftleft_def () Int)
(declare-fun shiftright_def () Int)
(declare-fun truncate_unsigned_def () Int)
(declare-fun truncate_signed_def () Int)
(declare-fun bitand_limits () Int)
(declare-fun bitand_signed_limits () Int)
(declare-fun bitxor_limits () Int)
(declare-fun bitxor_signed_limits () Int)
(declare-fun bitor_limits () Int)
(declare-fun bitor_signed_limits () Int)
(declare-fun shiftleft_limits () Int)
(declare-fun shiftleft_signed_limits () Int)
(declare-fun shiftright_limits () Int)
(declare-fun shiftright_signed_limits () Int)
(declare-fun truncate_limits () Int)
(declare-fun truncate_signed_limits () Int)
(declare-fun int_of_bits_of_int () Int)
(declare-fun Z_of_uintN () Int)
(declare-fun Z_of_uint_8 () Int)
(declare-fun Z_of_uint_1_6 () Int)
(declare-fun Z_of_uint_3_2 () Int)
; set_fpclauses
; function int_of_Z
; switching on argument number 0
; constructor Zdigit
(assert
   (forall ((var Inductive) (var0 Bool))
      (!
         (= (int_of_Z (Zdigit var var0))
            (+ (* 2 (int_of_Z var)) (ite var0 1 0)))
         :pattern ((int_of_Z (Zdigit var var0))))))
; constructor Zsign
(assert
   (forall ((var Bool))
      (! (= (int_of_Z (Zsign var)) (ite var (- 0 1) 0))
         :pattern ((int_of_Z (Zsign var))))))
(declare-fun switch_expression_1
   (Inductive Inductive Inductive Bool Inductive) Inductive)
; set_fpclauses
; function switch_expression_1
; switching on argument number 0
; constructor Zsign
(assert
   (forall
    ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Bool)
       (var3 Inductive))
      (!
         (= (switch_expression_1 (Zsign var) var0 var1 var2 var3)
            (ite var var1 var0))
         :pattern ((switch_expression_1 (Zsign var) var0 var1 var2 var3)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Bool) (var4 Inductive))
      (!
         (= (switch_expression_1 (Zdigit var var0) var1 var2 var3 var4)
            (Zdigit (Z_and var4 var) (and var3 var0)))
         :pattern
         ((switch_expression_1 (Zdigit var var0) var1 var2 var3 var4)))))
; set_fpclauses
; function Z_and
; switching on argument number 0
; constructor Zdigit
(declare-fun switch_expression_2
   (Inductive Inductive Inductive Bool Inductive) Inductive)
; set_fpclauses
; function switch_expression_2
; switching on argument number 0
; constructor Zsign
(assert
   (forall
    ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Bool)
       (var3 Inductive))
      (!
         (= (switch_expression_2 (Zsign var) var0 var1 var2 var3)
            (ite var var1 var0))
         :pattern ((switch_expression_2 (Zsign var) var0 var1 var2 var3)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Bool) (var4 Inductive))
      (!
         (= (switch_expression_2 (Zdigit var var0) var1 var2 var3 var4)
            (Zdigit (Z_and var4 var) (and var3 var0)))
         :pattern
         ((switch_expression_2 (Zdigit var var0) var1 var2 var3 var4)))))
(assert
   (forall ((var Inductive) (var0 Bool) (var1 Inductive))
      (!
         (= (Z_and (Zdigit var var0) var1)
            (switch_expression_2 var1 var1 (Zdigit var var0) var0 var))
         :pattern ((Z_and (Zdigit var var0) var1)))))
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive))
      (! (= (Z_and (Zsign var) var0) (ite var var0 (Zsign var)))
         :pattern ((Z_and (Zsign var) var0)))))
; set_fpclauses
; function Z_not
; switching on argument number 0
; constructor Zdigit
(assert
   (forall ((var Inductive) (var0 Bool))
      (! (= (Z_not (Zdigit var var0)) (Zdigit (Z_not var) (not var0)))
         :pattern ((Z_not (Zdigit var var0))))))
; constructor Zsign
(assert
   (forall ((var Bool))
      (! (= (Z_not (Zsign var)) (Zsign (not var)))
         :pattern ((Z_not (Zsign var))))))
(declare-fun switch_expression_3
   (Inductive Inductive Inductive Bool Inductive) Inductive)
; set_fpclauses
; function switch_expression_3
; switching on argument number 0
; constructor Zsign
(assert
   (forall
    ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Bool)
       (var3 Inductive))
      (!
         (= (switch_expression_3 (Zsign var) var0 var1 var2 var3)
            (ite var (Z_not var1) var1))
         :pattern ((switch_expression_3 (Zsign var) var0 var1 var2 var3)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Bool) (var4 Inductive))
      (!
         (= (switch_expression_3 (Zdigit var var0) var1 var2 var3 var4)
            (Zdigit (Z_xor var4 var) (not (= var3 var0))))
         :pattern
         ((switch_expression_3 (Zdigit var var0) var1 var2 var3 var4)))))
; set_fpclauses
; function Z_xor
; switching on argument number 0
; constructor Zdigit
(declare-fun switch_expression_4
   (Inductive Inductive Inductive Bool Inductive) Inductive)
; set_fpclauses
; function switch_expression_4
; switching on argument number 0
; constructor Zsign
(assert
   (forall
    ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Bool)
       (var3 Inductive))
      (!
         (= (switch_expression_4 (Zsign var) var0 var1 var2 var3)
            (ite var (Z_not var1) var1))
         :pattern ((switch_expression_4 (Zsign var) var0 var1 var2 var3)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Bool) (var4 Inductive))
      (!
         (= (switch_expression_4 (Zdigit var var0) var1 var2 var3 var4)
            (Zdigit (Z_xor var4 var) (not (= var3 var0))))
         :pattern
         ((switch_expression_4 (Zdigit var var0) var1 var2 var3 var4)))))
(assert
   (forall ((var Inductive) (var0 Bool) (var1 Inductive))
      (!
         (= (Z_xor (Zdigit var var0) var1)
            (switch_expression_4 var1 var1 (Zdigit var var0) var0 var))
         :pattern ((Z_xor (Zdigit var var0) var1)))))
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive))
      (! (= (Z_xor (Zsign var) var0) (ite var (Z_not var0) var0))
         :pattern ((Z_xor (Zsign var) var0)))))
(declare-fun switch_expression_5
   (Inductive Inductive Inductive Bool Inductive) Inductive)
; set_fpclauses
; function switch_expression_5
; switching on argument number 0
; constructor Zsign
(assert
   (forall
    ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Bool)
       (var3 Inductive))
      (!
         (= (switch_expression_5 (Zsign var) var0 var1 var2 var3)
            (ite var var0 var1))
         :pattern ((switch_expression_5 (Zsign var) var0 var1 var2 var3)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Bool) (var4 Inductive))
      (!
         (= (switch_expression_5 (Zdigit var var0) var1 var2 var3 var4)
            (Zdigit (Z_or var4 var) (or var3 var0)))
         :pattern
         ((switch_expression_5 (Zdigit var var0) var1 var2 var3 var4)))))
; set_fpclauses
; function Z_or
; switching on argument number 0
; constructor Zdigit
(declare-fun switch_expression_6
   (Inductive Inductive Inductive Bool Inductive) Inductive)
; set_fpclauses
; function switch_expression_6
; switching on argument number 0
; constructor Zsign
(assert
   (forall
    ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Bool)
       (var3 Inductive))
      (!
         (= (switch_expression_6 (Zsign var) var0 var1 var2 var3)
            (ite var var0 var1))
         :pattern ((switch_expression_6 (Zsign var) var0 var1 var2 var3)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Bool) (var4 Inductive))
      (!
         (= (switch_expression_6 (Zdigit var var0) var1 var2 var3 var4)
            (Zdigit (Z_or var4 var) (or var3 var0)))
         :pattern
         ((switch_expression_6 (Zdigit var var0) var1 var2 var3 var4)))))
(assert
   (forall ((var Inductive) (var0 Bool) (var1 Inductive))
      (!
         (= (Z_or (Zdigit var var0) var1)
            (switch_expression_6 var1 var1 (Zdigit var var0) var0 var))
         :pattern ((Z_or (Zdigit var var0) var1)))))
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive))
      (! (= (Z_or (Zsign var) var0) (ite var (Zsign var) var0))
         :pattern ((Z_or (Zsign var) var0)))))
(declare-fun switch_expression_7 (Inductive Inductive Inductive Inductive)
   Inductive)
; set_fpclauses
; function switch_expression_7
; switching on argument number 0
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (! (= (switch_expression_7 (Zsign var) var0 var1 var2) var1)
         :pattern ((switch_expression_7 (Zsign var) var0 var1 var2)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Inductive))
      (!
         (= (switch_expression_7 (Zdigit var var0) var1 var2 var3)
            (Z_shiftright var var3))
         :pattern ((switch_expression_7 (Zdigit var var0) var1 var2 var3)))))
; set_fpclauses
; function Z_shiftright
; switching on argument number 1
; constructor succ
(declare-fun switch_expression_8 (Inductive Inductive Inductive Inductive)
   Inductive)
; set_fpclauses
; function switch_expression_8
; switching on argument number 0
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (! (= (switch_expression_8 (Zsign var) var0 var1 var2) var1)
         :pattern ((switch_expression_8 (Zsign var) var0 var1 var2)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Inductive))
      (!
         (= (switch_expression_8 (Zdigit var var0) var1 var2 var3)
            (Z_shiftright var var3))
         :pattern ((switch_expression_8 (Zdigit var var0) var1 var2 var3)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (Z_shiftright var (succ var0))
            (switch_expression_8 var (succ var0) var var0))
         :pattern ((Z_shiftright var (succ var0))))))
; constructor zero
(assert
   (forall ((var Inductive))
      (! (= (Z_shiftright var zero) var) :pattern ((Z_shiftright var zero)))))
(declare-fun switch_expression_9 (Inductive Inductive Inductive Inductive)
   Inductive)
; set_fpclauses
; function switch_expression_9
; switching on argument number 0
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (switch_expression_9 (Zsign var) var0 var1 var2)
            (Zdigit (Z_truncate_signed var1 var2) var))
         :pattern ((switch_expression_9 (Zsign var) var0 var1 var2)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Inductive))
      (!
         (= (switch_expression_9 (Zdigit var var0) var1 var2 var3)
            (Zdigit (Z_truncate_signed var var3) var0))
         :pattern ((switch_expression_9 (Zdigit var var0) var1 var2 var3)))))
(declare-fun switch_expression_1_0 (Inductive Inductive Inductive) Inductive)
; set_fpclauses
; function switch_expression_1_0
; switching on argument number 0
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive) (var1 Inductive))
      (! (= (switch_expression_1_0 (Zsign var) var0 var1) var1)
         :pattern ((switch_expression_1_0 (Zsign var) var0 var1)))))
; constructor Zdigit
(assert
   (forall ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive))
      (! (= (switch_expression_1_0 (Zdigit var var0) var1 var2) (Zsign var0))
         :pattern ((switch_expression_1_0 (Zdigit var var0) var1 var2)))))
; set_fpclauses
; function Z_truncate_signed
; switching on argument number 1
; constructor succ
(declare-fun switch_expression_1_1 (Inductive Inductive Inductive Inductive)
   Inductive)
; set_fpclauses
; function switch_expression_1_1
; switching on argument number 0
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (switch_expression_1_1 (Zsign var) var0 var1 var2)
            (Zdigit (Z_truncate_signed var1 var2) var))
         :pattern ((switch_expression_1_1 (Zsign var) var0 var1 var2)))))
; constructor Zdigit
(assert
   (forall
    ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive)
       (var3 Inductive))
      (!
         (= (switch_expression_1_1 (Zdigit var var0) var1 var2 var3)
            (Zdigit (Z_truncate_signed var var3) var0))
         :pattern ((switch_expression_1_1 (Zdigit var var0) var1 var2 var3)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (Z_truncate_signed var (succ var0))
            (switch_expression_1_1 var (succ var0) var var0))
         :pattern ((Z_truncate_signed var (succ var0))))))
; constructor zero
(declare-fun switch_expression_1_2 (Inductive Inductive Inductive) Inductive)
; set_fpclauses
; function switch_expression_1_2
; switching on argument number 0
; constructor Zsign
(assert
   (forall ((var Bool) (var0 Inductive) (var1 Inductive))
      (! (= (switch_expression_1_2 (Zsign var) var0 var1) var1)
         :pattern ((switch_expression_1_2 (Zsign var) var0 var1)))))
; constructor Zdigit
(assert
   (forall ((var Inductive) (var0 Bool) (var1 Inductive) (var2 Inductive))
      (! (= (switch_expression_1_2 (Zdigit var var0) var1 var2) (Zsign var0))
         :pattern ((switch_expression_1_2 (Zdigit var var0) var1 var2)))))
(assert
   (forall ((var Inductive))
      (!
         (= (Z_truncate_signed var zero)
            (switch_expression_1_2 var zero var))
         :pattern ((Z_truncate_signed var zero)))))
; set_fpclauses
; function bits_of_int
; switching on argument number 1
; constructor succ
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (bits_of_int var (succ var0))
            (pair (box_int (unbox_int (fst (bits_of_int (/ var 2) var0))))
               (cons (box_bool (= (mod var 2) 1))
                  (snd (bits_of_int (/ var 2) var0)))))
         :pattern ((bits_of_int var (succ var0))))))
; constructor zero
(assert
   (forall ((var Int))
      (! (= (bits_of_int var zero) (pair (box_int var) nil))
         :pattern ((bits_of_int var zero)))))
; set_fpclauses
; function int_of_bits
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive))
      (!
         (= (int_of_bits var (cons var0 var1))
            (+ (* 2 (int_of_bits var var1)) (ite (unbox_bool var0) 1 0)))
         :pattern ((int_of_bits var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Int))
      (! (= (int_of_bits var nil) var) :pattern ((int_of_bits var nil)))))
; set_fpclauses
; function Z_of_bits
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (Z_of_bits var (cons var0 var1))
            (Zdigit (Z_of_bits var var1) (unbox_bool var0)))
         :pattern ((Z_of_bits var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (Z_of_bits var nil) var) :pattern ((Z_of_bits var nil)))))
; Assert: (= (func_rank int_of_bits_of_int) 172)
(assert (= (func_rank int_of_bits_of_int) 172))
; Assert: (= (func_rank Z_of_uintN) 173)
(assert (= (func_rank Z_of_uintN) 173))
; Assert: (= (func_rank Z_of_uint_8) 174)
(assert (= (func_rank Z_of_uint_8) 174))
; Assert: (= (func_rank Z_of_uint_1_6) 175)
(assert (= (func_rank Z_of_uint_1_6) 175))
; Assert: (= (func_rank Z_of_uint_3_2) 176)
(assert (= (func_rank Z_of_uint_3_2) 176))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(push)
(declare-fun x () Int)
(declare-fun n () Inductive)
(declare-fun currentThread () Int)
(push)
(push)
; Assume: (<= 0 x)
(assert (<= 0 x))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= n zero)
(assert (= n zero))
(check-sat)
; Query: (= x (int_of_bits (unbox_int (fst (bits_of_int x n))) (snd (bits_of_int x n))))
(push)
(assert
   (not
      (= x
         (int_of_bits (unbox_int (fst (bits_of_int x n)))
            (snd (bits_of_int x n))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n_0 () Inductive)
(push)
(push)
; Assume: (= n (succ n_0))
(assert (= n (succ n_0)))
(check-sat)
; Assert: (< (func_rank div_rem) 0)
(assert (< (func_rank div_rem) 0))
; Query: (not (= 2 0))
(push)
(assert (not (not (= 2 0))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= x (+ (* (/ x 2) 2) (mod x 2)))
(assert (= x (+ (* (/ x 2) 2) (mod x 2))))
(check-sat)
(push)
; Assume: (< (abs0 (mod x 2)) (abs0 2))
(assert (< (abs0 (mod x 2)) (abs0 2)))
(check-sat)
(push)
; Assume: (<= (abs0 (* (/ x 2) 2)) (abs0 x))
(assert (<= (abs0 (* (/ x 2) 2)) (abs0 x)))
(check-sat)
; Query: (<= 0 (/ x 2))
(push)
(assert (not (<= 0 (/ x 2))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (/ x 2) (int_of_bits (unbox_int (fst (bits_of_int (/ x 2) n_0))) (snd (bits_of_int (/ x 2) n_0))))
(assert
   (= (/ x 2)
      (int_of_bits (unbox_int (fst (bits_of_int (/ x 2) n_0)))
         (snd (bits_of_int (/ x 2) n_0)))))
(check-sat)
; Query: (= x (int_of_bits (unbox_int (fst (bits_of_int x n))) (snd (bits_of_int x n))))
(push)
(assert
   (not
      (= x
         (int_of_bits (unbox_int (fst (bits_of_int x n)))
            (snd (bits_of_int x n))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x0 () Int)
(declare-fun N () Inductive)
(declare-fun currentThread0 () Int)
(push)
(push)
; Assume: (<= 0 x0)
(assert (<= 0 x0))
(check-sat)
(push)
; Assume: (< x0 (pow_nat 2 N))
(assert (< x0 (pow_nat 2 N)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= N zero)
(assert (= N zero))
(check-sat)
; Query: (= (Zsign false) (Z_of_bits (Zsign false) (snd (bits_of_int x0 N))))
(push)
(assert
   (not (= (Zsign false) (Z_of_bits (Zsign false) (snd (bits_of_int x0 N))))))
(check-sat)
(pop 1)
; Query: (= x0 (int_of_Z (Zsign false)))
(push)
(assert (not (= x0 (int_of_Z (Zsign false)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun N_0_0 () Inductive)
(push)
(push)
; Assume: (= N (succ N_0_0))
(assert (= N (succ N_0_0)))
(check-sat)
; Assert: (< (func_rank div_rem) 0)
(assert (< (func_rank div_rem) 0))
; Query: (not (= 2 0))
(push)
(assert (not (not (= 2 0))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= x0 (+ (* (/ x0 2) 2) (mod x0 2)))
(assert (= x0 (+ (* (/ x0 2) 2) (mod x0 2))))
(check-sat)
(push)
; Assume: (< (abs0 (mod x0 2)) (abs0 2))
(assert (< (abs0 (mod x0 2)) (abs0 2)))
(check-sat)
(push)
; Assume: (<= (abs0 (* (/ x0 2) 2)) (abs0 x0))
(assert (<= (abs0 (* (/ x0 2) 2)) (abs0 x0)))
(check-sat)
; Query: (<= 0 (/ x0 2))
(push)
(assert (not (<= 0 (/ x0 2))))
(check-sat)
(pop 1)
; Query: (< (/ x0 2) (pow_nat 2 N_0_0))
(push)
(assert (not (< (/ x0 2) (pow_nat 2 N_0_0))))
(check-sat)
(pop 1)
(declare-fun result () Inductive)
(push)
(push)
; Assume: (= result (Z_of_bits (Zsign false) (snd (bits_of_int (/ x0 2) N_0_0))))
(assert
   (= result (Z_of_bits (Zsign false) (snd (bits_of_int (/ x0 2) N_0_0)))))
(check-sat)
(push)
; Assume: (= (/ x0 2) (int_of_Z result))
(assert (= (/ x0 2) (int_of_Z result)))
(check-sat)
; Query: (<= 0 x0)
(push)
(assert (not (<= 0 x0)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= x0 (int_of_bits (unbox_int (fst (bits_of_int x0 N))) (snd (bits_of_int x0 N))))
(assert
   (= x0
      (int_of_bits (unbox_int (fst (bits_of_int x0 N)))
         (snd (bits_of_int x0 N)))))
(check-sat)
; Query: (= (Z_of_bits (Zsign false) (snd (bits_of_int x0 N))) (Z_of_bits (Zsign false) (snd (bits_of_int x0 N))))
(push)
(assert
   (not
      (= (Z_of_bits (Zsign false) (snd (bits_of_int x0 N)))
         (Z_of_bits (Zsign false) (snd (bits_of_int x0 N))))))
(check-sat)
(pop 1)
; Query: (= x0 (int_of_Z (Z_of_bits (Zsign false) (snd (bits_of_int x0 N)))))
(push)
(assert
   (not (= x0 (int_of_Z (Z_of_bits (Zsign false) (snd (bits_of_int x0 N)))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x1 () Int)
(declare-fun currentThread1 () Int)
(push)
(push)
; Assume: (<= 0 x1)
(assert (<= 0 x1))
(check-sat)
(push)
; Assume: (<= x1 255)
(assert (<= x1 255))
(check-sat)
(push)
(push)
; Query: (<= 0 x1)
(push)
(assert (not (<= 0 x1)))
(check-sat)
(pop 1)
; Query: (< x1 (pow_nat 2 N_8))
(push)
(assert (not (< x1 (pow_nat 2 N_8))))
(check-sat)
(pop 1)
(declare-fun result0 () Inductive)
(push)
(push)
; Assume: (= result0 (Z_of_bits (Zsign false) (snd (bits_of_int x1 N_8))))
(assert (= result0 (Z_of_bits (Zsign false) (snd (bits_of_int x1 N_8)))))
(check-sat)
(push)
; Assume: (= x1 (int_of_Z result0))
(assert (= x1 (int_of_Z result0)))
(check-sat)
(push)
(declare-fun value () Bool)
; Assume: (= result0 (Zsign value))
(assert (= result0 (Zsign value)))
(check-sat)
(pop 1)
(declare-fun value0 () Inductive)
(declare-fun value_0 () Bool)
(push)
; Assume: (= result0 (Zdigit value0 value_0))
(assert (= result0 (Zdigit value0 value_0)))
(check-sat)
(push)
(declare-fun value_1 () Bool)
; Assume: (= value0 (Zsign value_1))
(assert (= value0 (Zsign value_1)))
(check-sat)
(pop 1)
(declare-fun value_10 () Inductive)
(declare-fun value_2 () Bool)
(push)
; Assume: (= value0 (Zdigit value_10 value_2))
(assert (= value0 (Zdigit value_10 value_2)))
(check-sat)
(push)
(declare-fun value_3 () Bool)
; Assume: (= value_10 (Zsign value_3))
(assert (= value_10 (Zsign value_3)))
(check-sat)
(pop 1)
(declare-fun value_30 () Inductive)
(declare-fun value_4 () Bool)
(push)
; Assume: (= value_10 (Zdigit value_30 value_4))
(assert (= value_10 (Zdigit value_30 value_4)))
(check-sat)
(push)
(declare-fun value_5 () Bool)
; Assume: (= value_30 (Zsign value_5))
(assert (= value_30 (Zsign value_5)))
(check-sat)
(pop 1)
(declare-fun value_50 () Inductive)
(declare-fun value_6 () Bool)
(push)
; Assume: (= value_30 (Zdigit value_50 value_6))
(assert (= value_30 (Zdigit value_50 value_6)))
(check-sat)
(push)
(declare-fun value_7 () Bool)
; Assume: (= value_50 (Zsign value_7))
(assert (= value_50 (Zsign value_7)))
(check-sat)
(pop 1)
(declare-fun value_70 () Inductive)
(declare-fun value_8 () Bool)
(push)
; Assume: (= value_50 (Zdigit value_70 value_8))
(assert (= value_50 (Zdigit value_70 value_8)))
(check-sat)
(push)
(declare-fun value_9 () Bool)
; Assume: (= value_70 (Zsign value_9))
(assert (= value_70 (Zsign value_9)))
(check-sat)
(pop 1)
(declare-fun value_90 () Inductive)
(declare-fun value_1_0 () Bool)
(push)
; Assume: (= value_70 (Zdigit value_90 value_1_0))
(assert (= value_70 (Zdigit value_90 value_1_0)))
(check-sat)
(push)
(declare-fun value_1_1 () Bool)
; Assume: (= value_90 (Zsign value_1_1))
(assert (= value_90 (Zsign value_1_1)))
(check-sat)
(pop 1)
(declare-fun value_1_10 () Inductive)
(declare-fun value_1_2 () Bool)
(push)
; Assume: (= value_90 (Zdigit value_1_10 value_1_2))
(assert (= value_90 (Zdigit value_1_10 value_1_2)))
(check-sat)
(push)
(declare-fun value_1_3 () Bool)
; Assume: (= value_1_10 (Zsign value_1_3))
(assert (= value_1_10 (Zsign value_1_3)))
(check-sat)
(pop 1)
(declare-fun value_1_30 () Inductive)
(declare-fun value_1_4 () Bool)
(push)
; Assume: (= value_1_10 (Zdigit value_1_30 value_1_4))
(assert (= value_1_10 (Zdigit value_1_30 value_1_4)))
(check-sat)
; Query: (= (Zsign false) value_1_30)
(push)
(assert (not (= (Zsign false) value_1_30)))
(check-sat)
(pop 1)
; Query: (= x1 (int_of_Z result0))
(push)
(assert (not (= x1 (int_of_Z result0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x2 () Int)
(declare-fun currentThread2 () Int)
(push)
(push)
; Assume: (<= 0 x2)
(assert (<= 0 x2))
(check-sat)
(push)
; Assume: (<= x2 65535)
(assert (<= x2 65535))
(check-sat)
(push)
(push)
; Query: (<= 0 x2)
(push)
(assert (not (<= 0 x2)))
(check-sat)
(pop 1)
; Query: (< x2 (pow_nat 2 N_1_6))
(push)
(assert (not (< x2 (pow_nat 2 N_1_6))))
(check-sat)
(pop 1)
(declare-fun result1 () Inductive)
(push)
(push)
; Assume: (= result1 (Z_of_bits (Zsign false) (snd (bits_of_int x2 N_1_6))))
(assert (= result1 (Z_of_bits (Zsign false) (snd (bits_of_int x2 N_1_6)))))
(check-sat)
(push)
; Assume: (= x2 (int_of_Z result1))
(assert (= x2 (int_of_Z result1)))
(check-sat)
(push)
(declare-fun value1 () Bool)
; Assume: (= result1 (Zsign value1))
(assert (= result1 (Zsign value1)))
(check-sat)
(pop 1)
(declare-fun value2 () Inductive)
(declare-fun value_00 () Bool)
(push)
; Assume: (= result1 (Zdigit value2 value_00))
(assert (= result1 (Zdigit value2 value_00)))
(check-sat)
(push)
(declare-fun value_11 () Bool)
; Assume: (= value2 (Zsign value_11))
(assert (= value2 (Zsign value_11)))
(check-sat)
(pop 1)
(declare-fun value_12 () Inductive)
(declare-fun value_20 () Bool)
(push)
; Assume: (= value2 (Zdigit value_12 value_20))
(assert (= value2 (Zdigit value_12 value_20)))
(check-sat)
(push)
(declare-fun value_31 () Bool)
; Assume: (= value_12 (Zsign value_31))
(assert (= value_12 (Zsign value_31)))
(check-sat)
(pop 1)
(declare-fun value_32 () Inductive)
(declare-fun value_40 () Bool)
(push)
; Assume: (= value_12 (Zdigit value_32 value_40))
(assert (= value_12 (Zdigit value_32 value_40)))
(check-sat)
(push)
(declare-fun value_51 () Bool)
; Assume: (= value_32 (Zsign value_51))
(assert (= value_32 (Zsign value_51)))
(check-sat)
(pop 1)
(declare-fun value_52 () Inductive)
(declare-fun value_60 () Bool)
(push)
; Assume: (= value_32 (Zdigit value_52 value_60))
(assert (= value_32 (Zdigit value_52 value_60)))
(check-sat)
(push)
(declare-fun value_71 () Bool)
; Assume: (= value_52 (Zsign value_71))
(assert (= value_52 (Zsign value_71)))
(check-sat)
(pop 1)
(declare-fun value_72 () Inductive)
(declare-fun value_80 () Bool)
(push)
; Assume: (= value_52 (Zdigit value_72 value_80))
(assert (= value_52 (Zdigit value_72 value_80)))
(check-sat)
(push)
(declare-fun value_91 () Bool)
; Assume: (= value_72 (Zsign value_91))
(assert (= value_72 (Zsign value_91)))
(check-sat)
(pop 1)
(declare-fun value_92 () Inductive)
(declare-fun value_1_00 () Bool)
(push)
; Assume: (= value_72 (Zdigit value_92 value_1_00))
(assert (= value_72 (Zdigit value_92 value_1_00)))
(check-sat)
(push)
(declare-fun value_1_11 () Bool)
; Assume: (= value_92 (Zsign value_1_11))
(assert (= value_92 (Zsign value_1_11)))
(check-sat)
(pop 1)
(declare-fun value_1_12 () Inductive)
(declare-fun value_1_20 () Bool)
(push)
; Assume: (= value_92 (Zdigit value_1_12 value_1_20))
(assert (= value_92 (Zdigit value_1_12 value_1_20)))
(check-sat)
(push)
(declare-fun value_1_31 () Bool)
; Assume: (= value_1_12 (Zsign value_1_31))
(assert (= value_1_12 (Zsign value_1_31)))
(check-sat)
(pop 1)
(declare-fun value_1_32 () Inductive)
(declare-fun value_1_40 () Bool)
(push)
; Assume: (= value_1_12 (Zdigit value_1_32 value_1_40))
(assert (= value_1_12 (Zdigit value_1_32 value_1_40)))
(check-sat)
(push)
(declare-fun value_1_5 () Bool)
; Assume: (= value_1_32 (Zsign value_1_5))
(assert (= value_1_32 (Zsign value_1_5)))
(check-sat)
(pop 1)
(declare-fun value_1_50 () Inductive)
(declare-fun value_1_6 () Bool)
(push)
; Assume: (= value_1_32 (Zdigit value_1_50 value_1_6))
(assert (= value_1_32 (Zdigit value_1_50 value_1_6)))
(check-sat)
(push)
(declare-fun value_1_7 () Bool)
; Assume: (= value_1_50 (Zsign value_1_7))
(assert (= value_1_50 (Zsign value_1_7)))
(check-sat)
(pop 1)
(declare-fun value_1_70 () Inductive)
(declare-fun value_1_8 () Bool)
(push)
; Assume: (= value_1_50 (Zdigit value_1_70 value_1_8))
(assert (= value_1_50 (Zdigit value_1_70 value_1_8)))
(check-sat)
(push)
(declare-fun value_1_9 () Bool)
; Assume: (= value_1_70 (Zsign value_1_9))
(assert (= value_1_70 (Zsign value_1_9)))
(check-sat)
(pop 1)
(declare-fun value_1_90 () Inductive)
(declare-fun value_2_0 () Bool)
(push)
; Assume: (= value_1_70 (Zdigit value_1_90 value_2_0))
(assert (= value_1_70 (Zdigit value_1_90 value_2_0)))
(check-sat)
(push)
(declare-fun value_2_1 () Bool)
; Assume: (= value_1_90 (Zsign value_2_1))
(assert (= value_1_90 (Zsign value_2_1)))
(check-sat)
(pop 1)
(declare-fun value_2_10 () Inductive)
(declare-fun value_2_2 () Bool)
(push)
; Assume: (= value_1_90 (Zdigit value_2_10 value_2_2))
(assert (= value_1_90 (Zdigit value_2_10 value_2_2)))
(check-sat)
(push)
(declare-fun value_2_3 () Bool)
; Assume: (= value_2_10 (Zsign value_2_3))
(assert (= value_2_10 (Zsign value_2_3)))
(check-sat)
(pop 1)
(declare-fun value_2_30 () Inductive)
(declare-fun value_2_4 () Bool)
(push)
; Assume: (= value_2_10 (Zdigit value_2_30 value_2_4))
(assert (= value_2_10 (Zdigit value_2_30 value_2_4)))
(check-sat)
(push)
(declare-fun value_2_5 () Bool)
; Assume: (= value_2_30 (Zsign value_2_5))
(assert (= value_2_30 (Zsign value_2_5)))
(check-sat)
(pop 1)
(declare-fun value_2_50 () Inductive)
(declare-fun value_2_6 () Bool)
(push)
; Assume: (= value_2_30 (Zdigit value_2_50 value_2_6))
(assert (= value_2_30 (Zdigit value_2_50 value_2_6)))
(check-sat)
(push)
(declare-fun value_2_7 () Bool)
; Assume: (= value_2_50 (Zsign value_2_7))
(assert (= value_2_50 (Zsign value_2_7)))
(check-sat)
(pop 1)
(declare-fun value_2_70 () Inductive)
(declare-fun value_2_8 () Bool)
(push)
; Assume: (= value_2_50 (Zdigit value_2_70 value_2_8))
(assert (= value_2_50 (Zdigit value_2_70 value_2_8)))
(check-sat)
(push)
(declare-fun value_2_9 () Bool)
; Assume: (= value_2_70 (Zsign value_2_9))
(assert (= value_2_70 (Zsign value_2_9)))
(check-sat)
(pop 1)
(declare-fun value_2_90 () Inductive)
(declare-fun value_3_0 () Bool)
(push)
; Assume: (= value_2_70 (Zdigit value_2_90 value_3_0))
(assert (= value_2_70 (Zdigit value_2_90 value_3_0)))
(check-sat)
; Query: (= (Zsign false) value_2_90)
(push)
(assert (not (= (Zsign false) value_2_90)))
(check-sat)
(pop 1)
; Query: (= x2 (int_of_Z result1))
(push)
(assert (not (= x2 (int_of_Z result1))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x3 () Int)
(declare-fun currentThread3 () Int)
(push)
(push)
; Assume: (<= 0 x3)
(assert (<= 0 x3))
(check-sat)
(push)
; Assume: (<= x3 4294967295)
(assert (<= x3 4294967295))
(check-sat)
(push)
(push)
; Query: (<= 0 x3)
(push)
(assert (not (<= 0 x3)))
(check-sat)
(pop 1)
; Query: (< x3 (pow_nat 2 N_3_2))
(push)
(assert (not (< x3 (pow_nat 2 N_3_2))))
(check-sat)
(pop 1)
(declare-fun result2 () Inductive)
(push)
(push)
; Assume: (= result2 (Z_of_bits (Zsign false) (snd (bits_of_int x3 N_3_2))))
(assert (= result2 (Z_of_bits (Zsign false) (snd (bits_of_int x3 N_3_2)))))
(check-sat)
(push)
; Assume: (= x3 (int_of_Z result2))
(assert (= x3 (int_of_Z result2)))
(check-sat)
(push)
(declare-fun value3 () Bool)
; Assume: (= result2 (Zsign value3))
(assert (= result2 (Zsign value3)))
(check-sat)
(pop 1)
(declare-fun value4 () Inductive)
(declare-fun value_01 () Bool)
(push)
; Assume: (= result2 (Zdigit value4 value_01))
(assert (= result2 (Zdigit value4 value_01)))
(check-sat)
(push)
(declare-fun value_13 () Bool)
; Assume: (= value4 (Zsign value_13))
(assert (= value4 (Zsign value_13)))
(check-sat)
(pop 1)
(declare-fun value_14 () Inductive)
(declare-fun value_21 () Bool)
(push)
; Assume: (= value4 (Zdigit value_14 value_21))
(assert (= value4 (Zdigit value_14 value_21)))
(check-sat)
(push)
(declare-fun value_33 () Bool)
; Assume: (= value_14 (Zsign value_33))
(assert (= value_14 (Zsign value_33)))
(check-sat)
(pop 1)
(declare-fun value_34 () Inductive)
(declare-fun value_41 () Bool)
(push)
; Assume: (= value_14 (Zdigit value_34 value_41))
(assert (= value_14 (Zdigit value_34 value_41)))
(check-sat)
(push)
(declare-fun value_53 () Bool)
; Assume: (= value_34 (Zsign value_53))
(assert (= value_34 (Zsign value_53)))
(check-sat)
(pop 1)
(declare-fun value_54 () Inductive)
(declare-fun value_61 () Bool)
(push)
; Assume: (= value_34 (Zdigit value_54 value_61))
(assert (= value_34 (Zdigit value_54 value_61)))
(check-sat)
(push)
(declare-fun value_73 () Bool)
; Assume: (= value_54 (Zsign value_73))
(assert (= value_54 (Zsign value_73)))
(check-sat)
(pop 1)
(declare-fun value_74 () Inductive)
(declare-fun value_81 () Bool)
(push)
; Assume: (= value_54 (Zdigit value_74 value_81))
(assert (= value_54 (Zdigit value_74 value_81)))
(check-sat)
(push)
(declare-fun value_93 () Bool)
; Assume: (= value_74 (Zsign value_93))
(assert (= value_74 (Zsign value_93)))
(check-sat)
(pop 1)
(declare-fun value_94 () Inductive)
(declare-fun value_1_01 () Bool)
(push)
; Assume: (= value_74 (Zdigit value_94 value_1_01))
(assert (= value_74 (Zdigit value_94 value_1_01)))
(check-sat)
(push)
(declare-fun value_1_13 () Bool)
; Assume: (= value_94 (Zsign value_1_13))
(assert (= value_94 (Zsign value_1_13)))
(check-sat)
(pop 1)
(declare-fun value_1_14 () Inductive)
(declare-fun value_1_21 () Bool)
(push)
; Assume: (= value_94 (Zdigit value_1_14 value_1_21))
(assert (= value_94 (Zdigit value_1_14 value_1_21)))
(check-sat)
(push)
(declare-fun value_1_33 () Bool)
; Assume: (= value_1_14 (Zsign value_1_33))
(assert (= value_1_14 (Zsign value_1_33)))
(check-sat)
(pop 1)
(declare-fun value_1_34 () Inductive)
(declare-fun value_1_41 () Bool)
(push)
; Assume: (= value_1_14 (Zdigit value_1_34 value_1_41))
(assert (= value_1_14 (Zdigit value_1_34 value_1_41)))
(check-sat)
(push)
(declare-fun value_1_51 () Bool)
; Assume: (= value_1_34 (Zsign value_1_51))
(assert (= value_1_34 (Zsign value_1_51)))
(check-sat)
(pop 1)
(declare-fun value_1_52 () Inductive)
(declare-fun value_1_60 () Bool)
(push)
; Assume: (= value_1_34 (Zdigit value_1_52 value_1_60))
(assert (= value_1_34 (Zdigit value_1_52 value_1_60)))
(check-sat)
(push)
(declare-fun value_1_71 () Bool)
; Assume: (= value_1_52 (Zsign value_1_71))
(assert (= value_1_52 (Zsign value_1_71)))
(check-sat)
(pop 1)
(declare-fun value_1_72 () Inductive)
(declare-fun value_1_80 () Bool)
(push)
; Assume: (= value_1_52 (Zdigit value_1_72 value_1_80))
(assert (= value_1_52 (Zdigit value_1_72 value_1_80)))
(check-sat)
(push)
(declare-fun value_1_91 () Bool)
; Assume: (= value_1_72 (Zsign value_1_91))
(assert (= value_1_72 (Zsign value_1_91)))
(check-sat)
(pop 1)
(declare-fun value_1_92 () Inductive)
(declare-fun value_2_00 () Bool)
(push)
; Assume: (= value_1_72 (Zdigit value_1_92 value_2_00))
(assert (= value_1_72 (Zdigit value_1_92 value_2_00)))
(check-sat)
(push)
(declare-fun value_2_11 () Bool)
; Assume: (= value_1_92 (Zsign value_2_11))
(assert (= value_1_92 (Zsign value_2_11)))
(check-sat)
(pop 1)
(declare-fun value_2_12 () Inductive)
(declare-fun value_2_20 () Bool)
(push)
; Assume: (= value_1_92 (Zdigit value_2_12 value_2_20))
(assert (= value_1_92 (Zdigit value_2_12 value_2_20)))
(check-sat)
(push)
(declare-fun value_2_31 () Bool)
; Assume: (= value_2_12 (Zsign value_2_31))
(assert (= value_2_12 (Zsign value_2_31)))
(check-sat)
(pop 1)
(declare-fun value_2_32 () Inductive)
(declare-fun value_2_40 () Bool)
(push)
; Assume: (= value_2_12 (Zdigit value_2_32 value_2_40))
(assert (= value_2_12 (Zdigit value_2_32 value_2_40)))
(check-sat)
(push)
(declare-fun value_2_51 () Bool)
; Assume: (= value_2_32 (Zsign value_2_51))
(assert (= value_2_32 (Zsign value_2_51)))
(check-sat)
(pop 1)
(declare-fun value_2_52 () Inductive)
(declare-fun value_2_60 () Bool)
(push)
; Assume: (= value_2_32 (Zdigit value_2_52 value_2_60))
(assert (= value_2_32 (Zdigit value_2_52 value_2_60)))
(check-sat)
(push)
(declare-fun value_2_71 () Bool)
; Assume: (= value_2_52 (Zsign value_2_71))
(assert (= value_2_52 (Zsign value_2_71)))
(check-sat)
(pop 1)
(declare-fun value_2_72 () Inductive)
(declare-fun value_2_80 () Bool)
(push)
; Assume: (= value_2_52 (Zdigit value_2_72 value_2_80))
(assert (= value_2_52 (Zdigit value_2_72 value_2_80)))
(check-sat)
(push)
(declare-fun value_2_91 () Bool)
; Assume: (= value_2_72 (Zsign value_2_91))
(assert (= value_2_72 (Zsign value_2_91)))
(check-sat)
(pop 1)
(declare-fun value_2_92 () Inductive)
(declare-fun value_3_00 () Bool)
(push)
; Assume: (= value_2_72 (Zdigit value_2_92 value_3_00))
(assert (= value_2_72 (Zdigit value_2_92 value_3_00)))
(check-sat)
(push)
(declare-fun value_3_1 () Bool)
; Assume: (= value_2_92 (Zsign value_3_1))
(assert (= value_2_92 (Zsign value_3_1)))
(check-sat)
(pop 1)
(declare-fun value_3_10 () Inductive)
(declare-fun value_3_2 () Bool)
(push)
; Assume: (= value_2_92 (Zdigit value_3_10 value_3_2))
(assert (= value_2_92 (Zdigit value_3_10 value_3_2)))
(check-sat)
(push)
(declare-fun value_3_3 () Bool)
; Assume: (= value_3_10 (Zsign value_3_3))
(assert (= value_3_10 (Zsign value_3_3)))
(check-sat)
(pop 1)
(declare-fun value_3_30 () Inductive)
(declare-fun value_3_4 () Bool)
(push)
; Assume: (= value_3_10 (Zdigit value_3_30 value_3_4))
(assert (= value_3_10 (Zdigit value_3_30 value_3_4)))
(check-sat)
(push)
(declare-fun value_3_5 () Bool)
; Assume: (= value_3_30 (Zsign value_3_5))
(assert (= value_3_30 (Zsign value_3_5)))
(check-sat)
(pop 1)
(declare-fun value_3_50 () Inductive)
(declare-fun value_3_6 () Bool)
(push)
; Assume: (= value_3_30 (Zdigit value_3_50 value_3_6))
(assert (= value_3_30 (Zdigit value_3_50 value_3_6)))
(check-sat)
(push)
(declare-fun value_3_7 () Bool)
; Assume: (= value_3_50 (Zsign value_3_7))
(assert (= value_3_50 (Zsign value_3_7)))
(check-sat)
(pop 1)
(declare-fun value_3_70 () Inductive)
(declare-fun value_3_8 () Bool)
(push)
; Assume: (= value_3_50 (Zdigit value_3_70 value_3_8))
(assert (= value_3_50 (Zdigit value_3_70 value_3_8)))
(check-sat)
(push)
(declare-fun value_3_9 () Bool)
; Assume: (= value_3_70 (Zsign value_3_9))
(assert (= value_3_70 (Zsign value_3_9)))
(check-sat)
(pop 1)
(declare-fun value_3_90 () Inductive)
(declare-fun value_4_0 () Bool)
(push)
; Assume: (= value_3_70 (Zdigit value_3_90 value_4_0))
(assert (= value_3_70 (Zdigit value_3_90 value_4_0)))
(check-sat)
(push)
(declare-fun value_4_1 () Bool)
; Assume: (= value_3_90 (Zsign value_4_1))
(assert (= value_3_90 (Zsign value_4_1)))
(check-sat)
(pop 1)
(declare-fun value_4_10 () Inductive)
(declare-fun value_4_2 () Bool)
(push)
; Assume: (= value_3_90 (Zdigit value_4_10 value_4_2))
(assert (= value_3_90 (Zdigit value_4_10 value_4_2)))
(check-sat)
(push)
(declare-fun value_4_3 () Bool)
; Assume: (= value_4_10 (Zsign value_4_3))
(assert (= value_4_10 (Zsign value_4_3)))
(check-sat)
(pop 1)
(declare-fun value_4_30 () Inductive)
(declare-fun value_4_4 () Bool)
(push)
; Assume: (= value_4_10 (Zdigit value_4_30 value_4_4))
(assert (= value_4_10 (Zdigit value_4_30 value_4_4)))
(check-sat)
(push)
(declare-fun value_4_5 () Bool)
; Assume: (= value_4_30 (Zsign value_4_5))
(assert (= value_4_30 (Zsign value_4_5)))
(check-sat)
(pop 1)
(declare-fun value_4_50 () Inductive)
(declare-fun value_4_6 () Bool)
(push)
; Assume: (= value_4_30 (Zdigit value_4_50 value_4_6))
(assert (= value_4_30 (Zdigit value_4_50 value_4_6)))
(check-sat)
(push)
(declare-fun value_4_7 () Bool)
; Assume: (= value_4_50 (Zsign value_4_7))
(assert (= value_4_50 (Zsign value_4_7)))
(check-sat)
(pop 1)
(declare-fun value_4_70 () Inductive)
(declare-fun value_4_8 () Bool)
(push)
; Assume: (= value_4_50 (Zdigit value_4_70 value_4_8))
(assert (= value_4_50 (Zdigit value_4_70 value_4_8)))
(check-sat)
(push)
(declare-fun value_4_9 () Bool)
; Assume: (= value_4_70 (Zsign value_4_9))
(assert (= value_4_70 (Zsign value_4_9)))
(check-sat)
(pop 1)
(declare-fun value_4_90 () Inductive)
(declare-fun value_5_0 () Bool)
(push)
; Assume: (= value_4_70 (Zdigit value_4_90 value_5_0))
(assert (= value_4_70 (Zdigit value_4_90 value_5_0)))
(check-sat)
(push)
(declare-fun value_5_1 () Bool)
; Assume: (= value_4_90 (Zsign value_5_1))
(assert (= value_4_90 (Zsign value_5_1)))
(check-sat)
(pop 1)
(declare-fun value_5_10 () Inductive)
(declare-fun value_5_2 () Bool)
(push)
; Assume: (= value_4_90 (Zdigit value_5_10 value_5_2))
(assert (= value_4_90 (Zdigit value_5_10 value_5_2)))
(check-sat)
(push)
(declare-fun value_5_3 () Bool)
; Assume: (= value_5_10 (Zsign value_5_3))
(assert (= value_5_10 (Zsign value_5_3)))
(check-sat)
(pop 1)
(declare-fun value_5_30 () Inductive)
(declare-fun value_5_4 () Bool)
(push)
; Assume: (= value_5_10 (Zdigit value_5_30 value_5_4))
(assert (= value_5_10 (Zdigit value_5_30 value_5_4)))
(check-sat)
(push)
(declare-fun value_5_5 () Bool)
; Assume: (= value_5_30 (Zsign value_5_5))
(assert (= value_5_30 (Zsign value_5_5)))
(check-sat)
(pop 1)
(declare-fun value_5_50 () Inductive)
(declare-fun value_5_6 () Bool)
(push)
; Assume: (= value_5_30 (Zdigit value_5_50 value_5_6))
(assert (= value_5_30 (Zdigit value_5_50 value_5_6)))
(check-sat)
(push)
(declare-fun value_5_7 () Bool)
; Assume: (= value_5_50 (Zsign value_5_7))
(assert (= value_5_50 (Zsign value_5_7)))
(check-sat)
(pop 1)
(declare-fun value_5_70 () Inductive)
(declare-fun value_5_8 () Bool)
(push)
; Assume: (= value_5_50 (Zdigit value_5_70 value_5_8))
(assert (= value_5_50 (Zdigit value_5_70 value_5_8)))
(check-sat)
(push)
(declare-fun value_5_9 () Bool)
; Assume: (= value_5_70 (Zsign value_5_9))
(assert (= value_5_70 (Zsign value_5_9)))
(check-sat)
(pop 1)
(declare-fun value_5_90 () Inductive)
(declare-fun value_6_0 () Bool)
(push)
; Assume: (= value_5_70 (Zdigit value_5_90 value_6_0))
(assert (= value_5_70 (Zdigit value_5_90 value_6_0)))
(check-sat)
(push)
(declare-fun value_6_1 () Bool)
; Assume: (= value_5_90 (Zsign value_6_1))
(assert (= value_5_90 (Zsign value_6_1)))
(check-sat)
(pop 1)
(declare-fun value_6_10 () Inductive)
(declare-fun value_6_2 () Bool)
(push)
; Assume: (= value_5_90 (Zdigit value_6_10 value_6_2))
(assert (= value_5_90 (Zdigit value_6_10 value_6_2)))
(check-sat)
; Query: (= (Zsign false) value_6_10)
(push)
(assert (not (= (Zsign false) value_6_10)))
(check-sat)
(pop 1)
; Query: (= x3 (int_of_Z result2))
(push)
(assert (not (= x3 (int_of_Z result2))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(declare-fun max (Int Inductive) Int)
(declare-fun _@max () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (unbox_int (_@ (_@ _@max (box_int var)) var0)) (max var var0))
         :pattern ((_@ (_@ _@max (box_int var)) var0)))))
(declare-fun fold_left (Inductive Inductive Inductive) Inductive)
(declare-fun _@fold_left () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (_@ (_@ (_@ _@fold_left var) var0) var1)
            (fold_left var var0 var1))
         :pattern ((_@ (_@ (_@ _@fold_left var) var0) var1)))))
(declare-fun remove_all (Inductive Inductive) Inductive)
(declare-fun _@remove_all () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@remove_all var) var0) (remove_all var var0))
         :pattern ((_@ (_@ _@remove_all var) var0)))))
(declare-fun filter (Inductive Inductive) Inductive)
(declare-fun _@filter () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@filter var) var0) (filter var var0))
         :pattern ((_@ (_@ _@filter var) var0)))))
(declare-fun contains (Inductive Inductive) Bool)
(declare-fun _@contains () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@contains var) var0)) (contains var var0))
         :pattern ((_@ (_@ _@contains var) var0)))))
(declare-fun subset0 (Inductive Inductive) Bool)
(declare-fun _@subset () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@subset var) var0)) (subset0 var var0))
         :pattern ((_@ (_@ _@subset var) var0)))))
(declare-fun intersection0 (Inductive Inductive) Inductive)
(declare-fun _@intersection () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@intersection var) var0) (intersection0 var var0))
         :pattern ((_@ (_@ _@intersection var) var0)))))
(declare-fun foreachp () Inductive)
(declare-fun take_plus_one () Int)
(declare-fun take_append () Int)
(declare-fun distinct_mem_nth_take () Int)
(declare-fun nth_drop () Int)
(declare-fun neq_mem_remove () Int)
(declare-fun mem_remove_mem () Int)
(declare-fun remove_commutes () Int)
(declare-fun distinct_mem_remove () Int)
(declare-fun distinct_remove () Int)
(declare-fun mem_nth_index_of () Int)
(declare-fun index_of_append_l () Int)
(declare-fun index_of_append_r () Int)
(declare-fun nth_index_of () Int)
(declare-fun map_append () Int)
(declare-fun mem_map () Int)
(declare-fun forall_append () Int)
(declare-fun forall_mem () Int)
(declare-fun forall_drop () Int)
(declare-fun mem_max () Int)
(declare-fun fold_left_append () Int)
(declare-fun append_drop_take () Int)
(declare-fun drop_append () Int)
(declare-fun remove_all_nil () Int)
(declare-fun remove_all_cons () Int)
(declare-fun mem_remove_all () Int)
(declare-fun remove_remove_all () Int)
(declare-fun subset_intersection () Int)
(declare-fun intersection_nil () Int)
(declare-fun subset_intersection_subset () Int)
(declare-fun mem_intersection () Int)
(declare-fun subset_refl () Int)
(declare-fun mem_subset () Int)
(declare-fun subset_cons () Int)
(declare-fun subset_trans () Int)
(declare-fun subset_remove_all () Int)
(declare-fun not_mem_intersection () Int)
(declare-fun remove_intersection () Int)
(declare-fun foreach_remove_nth () Int)
(declare-fun foreach_unremove_nth () Int)
(declare-fun foreachp_remove () Int)
(declare-fun foreachp_unremove () Int)
(declare-fun foreachp_remove_nth () Int)
(declare-fun foreachp_unremove_nth () Int)
; set_fpclauses
; function max
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive))
      (!
         (= (max var (cons var0 var1))
            (ite (< var (unbox_int var0)) (max (unbox_int var0) var1)
               (max var var1)))
         :pattern ((max var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Int)) (! (= (max var nil) var) :pattern ((max var nil)))))
; set_fpclauses
; function fold_left
; switching on argument number 2
; constructor cons
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (fold_left var var0 (cons var1 var2))
            (fold_left (_@ (_@ var0 var) var1) var0 var2))
         :pattern ((fold_left var var0 (cons var1 var2))))))
; constructor nil
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (fold_left var var0 nil) var)
         :pattern ((fold_left var var0 nil)))))
; set_fpclauses
; function remove_all
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (remove_all (cons var var0) var1)
            (remove var (remove_all var0 var1)))
         :pattern ((remove_all (cons var var0) var1)))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (remove_all nil var) var) :pattern ((remove_all nil var)))))
; set_fpclauses
; function filter
; switching on argument number 1
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (filter var (cons var0 var1))
            (ite (unbox_bool (_@ var var0)) (cons var0 (filter var var1))
               (filter var var1)))
         :pattern ((filter var (cons var0 var1))))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (filter var nil) nil) :pattern ((filter var nil)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (contains var var0) (mem var0 var))
         :pattern ((contains var var0)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (subset0 var var0) (forall0 var (_@ _@contains var0)))
         :pattern ((subset0 var var0)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (intersection0 var var0) (filter (_@ _@contains var) var0))
         :pattern ((intersection0 var var0)))))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
; Assert: (< (func_rank index_of_append_r) 0)
(assert (< (func_rank index_of_append_r) 0))
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (=> (not (mem var var0))
            (= (index_of var (append var0 var1))
               (+ (length var0) (index_of var var1))))
         :pattern ((index_of var (append var0 var1))))))
; Assert: (< (func_rank append_drop_take) 0)
(assert (< (func_rank append_drop_take) 0))
(assert
   (forall ((var Inductive) (var0 Int))
      (=> (and (<= 0 var0) (<= var0 (length var)))
         (= (append (take var0 var) (drop var0 var)) var))))
; Assert: (< (func_rank remove_all_nil) 0)
(assert (< (func_rank remove_all_nil) 0))
(assert (forall ((var Inductive)) (=> true (= (remove_all var nil) nil))))
; Assert: (< (func_rank intersection_nil) 0)
(assert (< (func_rank intersection_nil) 0))
(assert (forall ((var Inductive)) (=> true (= (intersection0 nil var) nil))))
; Assert: (< (func_rank subset_refl) 0)
(assert (< (func_rank subset_refl) 0))
(assert (forall ((var Inductive)) (=> true (= (subset0 var var) true))))
(declare-fun disjoint (Inductive Inductive) Bool)
(declare-fun _@disjoint () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@disjoint var) var0)) (disjoint var var0))
         :pattern ((_@ (_@ _@disjoint var) var0)))))
(declare-fun nth_2 (Inductive Int) Inductive)
(declare-fun _@nth_2 () Inductive)
(assert
   (forall ((var Inductive) (var0 Int))
      (! (= (_@ (_@ _@nth_2 var) (box_int var0)) (nth_2 var var0))
         :pattern ((_@ (_@ _@nth_2 var) (box_int var0))))))
(declare-fun mem_2 (Inductive Inductive) Bool)
(declare-fun _@mem_2 () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@mem_2 var) var0)) (mem_2 var var0))
         :pattern ((_@ (_@ _@mem_2 var) var0)))))
(declare-fun length__0_nil () Int)
(declare-fun nth__0_head () Int)
(declare-fun nth_cons () Int)
(declare-fun nth_len_append_cons () Int)
(declare-fun append_take_nth_to_take () Int)
(declare-fun nth_less_append_cons () Int)
(declare-fun append_take_cons () Int)
(declare-fun cons_take_take_cons () Int)
(declare-fun cons_head_tail () Int)
(declare-fun length_tail () Int)
(declare-fun update_tail_tail_update () Int)
(declare-fun tail_of_update__0 () Int)
(declare-fun update_id () Int)
(declare-fun update_non_nil () Int)
(declare-fun head_update__0 () Int)
(declare-fun head_update_nonzero () Int)
(declare-fun update_irrelevant_cell () Int)
(declare-fun drop_update_relevant () Int)
(declare-fun drop_update_unrelevant () Int)
(declare-fun take_update_relevant () Int)
(declare-fun take_update_unrelevant () Int)
(declare-fun forall_update () Int)
(declare-fun update_update () Int)
(declare-fun nth_update_unrelevant () Int)
(declare-fun tail_drop () Int)
(declare-fun drop_cons () Int)
(declare-fun reverse_cons () Int)
(declare-fun append_reverse_take_cons () Int)
(declare-fun append_reverse_tail_cons_head () Int)
(declare-fun append_append_cons_to_append_cons () Int)
(declare-fun append_append_assoc () Int)
(declare-fun forall_nth () Int)
(declare-fun forall_remove () Int)
(declare-fun drop_drop () Int)
(declare-fun append_nonnil_l () Int)
(declare-fun filter_no_increase_len () Int)
(declare-fun map_preserves_length () Int)
(declare-fun take_effect_on_len () Int)
(declare-fun map_effect_on_len () Int)
(declare-fun filter_effect_on_len () Int)
(declare-fun car_drop_is_nth () Int)
(declare-fun take_take () Int)
(declare-fun take_map () Int)
(declare-fun remove_nonmem () Int)
(declare-fun distinct_unique () Int)
(declare-fun remove_unrelevant_preserves_distinct () Int)
(declare-fun remove_still_distinct () Int)
(declare-fun drop_append_small () Int)
(declare-fun take_append_small () Int)
(declare-fun head_take () Int)
(declare-fun nonmem_map_filter () Int)
(declare-fun distinct_map_filter () Int)
(declare-fun non_mem_map_remove () Int)
(declare-fun distinct_map_remove () Int)
(declare-fun forall_filter () Int)
(declare-fun filter_append_idemp () Int)
(declare-fun filter_forall () Int)
(declare-fun double_mem_append_nondistinct () Int)
(declare-fun append_remove_first () Int)
(declare-fun rem_preserves_no_mem () Int)
(declare-fun distinct_unappend () Int)
(declare-fun disjoint_mem () Int)
(declare-fun disjoint_uncons () Int)
(declare-fun disjoint_cons () Int)
(declare-fun distinct_and_disjoint_append () Int)
(declare-fun disjoint_unappend_left () Int)
(declare-fun disjoint_unappend () Int)
(declare-fun disjoint_comm () Int)
(declare-fun disjoint_append_left () Int)
(declare-fun disjoint_append () Int)
(declare-fun distinct_unmap () Int)
(declare-fun map_remove () Int)
(declare-fun remove_append_swap () Int)
(declare-fun unique_map_identical_elems () Int)
(declare-fun distinct_map_identical_elems () Int)
(declare-fun filter_filter_swap () Int)
(declare-fun filter_mem () Int)
(declare-fun mem_update () Int)
(declare-fun filter_unmem () Int)
(declare-fun filter_remove () Int)
(declare-fun index_of_positive () Int)
(declare-fun nth_remove () Int)
(declare-fun update_remove () Int)
(declare-fun mem_unfilter () Int)
(declare-fun mem_update_unrelevant () Int)
(declare-fun update_update_rewrite () Int)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (disjoint var var0) (= (intersection0 var var0) nil))
         :pattern ((disjoint var var0)))))
(assert
   (forall ((var Inductive) (var0 Int))
      (! (= (nth_2 var var0) (nth var0 var)) :pattern ((nth_2 var var0)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (mem_2 var var0) (mem var0 var)) :pattern ((mem_2 var var0)))))
; Assert: (= (func_rank length__0_nil) 220)
(assert (= (func_rank length__0_nil) 220))
; Assert: (= (func_rank nth__0_head) 221)
(assert (= (func_rank nth__0_head) 221))
; Assert: (= (func_rank nth_cons) 222)
(assert (= (func_rank nth_cons) 222))
; Assert: (= (func_rank nth_len_append_cons) 223)
(assert (= (func_rank nth_len_append_cons) 223))
; Assert: (= (func_rank append_take_nth_to_take) 224)
(assert (= (func_rank append_take_nth_to_take) 224))
; Assert: (= (func_rank nth_less_append_cons) 225)
(assert (= (func_rank nth_less_append_cons) 225))
; Assert: (= (func_rank append_take_cons) 226)
(assert (= (func_rank append_take_cons) 226))
; Assert: (= (func_rank cons_take_take_cons) 227)
(assert (= (func_rank cons_take_take_cons) 227))
; Assert: (= (func_rank cons_head_tail) 228)
(assert (= (func_rank cons_head_tail) 228))
; Assert: (= (func_rank length_tail) 229)
(assert (= (func_rank length_tail) 229))
; Assert: (= (func_rank update_tail_tail_update) 230)
(assert (= (func_rank update_tail_tail_update) 230))
; Assert: (= (func_rank tail_of_update__0) 231)
(assert (= (func_rank tail_of_update__0) 231))
; Assert: (= (func_rank update_id) 232)
(assert (= (func_rank update_id) 232))
; Assert: (= (func_rank update_non_nil) 233)
(assert (= (func_rank update_non_nil) 233))
; Assert: (= (func_rank head_update__0) 234)
(assert (= (func_rank head_update__0) 234))
; Assert: (= (func_rank head_update_nonzero) 235)
(assert (= (func_rank head_update_nonzero) 235))
; Assert: (= (func_rank update_irrelevant_cell) 236)
(assert (= (func_rank update_irrelevant_cell) 236))
; Assert: (= (func_rank drop_update_relevant) 237)
(assert (= (func_rank drop_update_relevant) 237))
; Assert: (= (func_rank drop_update_unrelevant) 238)
(assert (= (func_rank drop_update_unrelevant) 238))
; Assert: (= (func_rank take_update_relevant) 239)
(assert (= (func_rank take_update_relevant) 239))
; Assert: (= (func_rank take_update_unrelevant) 240)
(assert (= (func_rank take_update_unrelevant) 240))
; Assert: (= (func_rank forall_update) 241)
(assert (= (func_rank forall_update) 241))
; Assert: (= (func_rank update_update) 242)
(assert (= (func_rank update_update) 242))
; Assert: (= (func_rank nth_update_unrelevant) 243)
(assert (= (func_rank nth_update_unrelevant) 243))
; Assert: (= (func_rank tail_drop) 244)
(assert (= (func_rank tail_drop) 244))
; Assert: (= (func_rank drop_cons) 245)
(assert (= (func_rank drop_cons) 245))
; Assert: (= (func_rank reverse_cons) 246)
(assert (= (func_rank reverse_cons) 246))
; Assert: (= (func_rank append_reverse_take_cons) 247)
(assert (= (func_rank append_reverse_take_cons) 247))
; Assert: (= (func_rank append_reverse_tail_cons_head) 248)
(assert (= (func_rank append_reverse_tail_cons_head) 248))
; Assert: (= (func_rank append_append_cons_to_append_cons) 249)
(assert (= (func_rank append_append_cons_to_append_cons) 249))
; Assert: (= (func_rank append_append_assoc) 250)
(assert (= (func_rank append_append_assoc) 250))
; Assert: (= (func_rank forall_nth) 251)
(assert (= (func_rank forall_nth) 251))
; Assert: (= (func_rank forall_remove) 252)
(assert (= (func_rank forall_remove) 252))
; Assert: (= (func_rank drop_drop) 253)
(assert (= (func_rank drop_drop) 253))
; Assert: (= (func_rank append_nonnil_l) 254)
(assert (= (func_rank append_nonnil_l) 254))
; Assert: (= (func_rank filter_no_increase_len) 255)
(assert (= (func_rank filter_no_increase_len) 255))
; Assert: (= (func_rank map_preserves_length) 256)
(assert (= (func_rank map_preserves_length) 256))
; Assert: (= (func_rank take_effect_on_len) 257)
(assert (= (func_rank take_effect_on_len) 257))
; Assert: (= (func_rank map_effect_on_len) 258)
(assert (= (func_rank map_effect_on_len) 258))
; Assert: (= (func_rank filter_effect_on_len) 259)
(assert (= (func_rank filter_effect_on_len) 259))
; Assert: (= (func_rank car_drop_is_nth) 260)
(assert (= (func_rank car_drop_is_nth) 260))
; Assert: (= (func_rank take_take) 261)
(assert (= (func_rank take_take) 261))
; Assert: (= (func_rank take_map) 262)
(assert (= (func_rank take_map) 262))
; Assert: (= (func_rank remove_nonmem) 263)
(assert (= (func_rank remove_nonmem) 263))
; Assert: (= (func_rank distinct_unique) 264)
(assert (= (func_rank distinct_unique) 264))
; Assert: (= (func_rank remove_unrelevant_preserves_distinct) 265)
(assert (= (func_rank remove_unrelevant_preserves_distinct) 265))
; Assert: (= (func_rank remove_still_distinct) 266)
(assert (= (func_rank remove_still_distinct) 266))
; Assert: (= (func_rank drop_append_small) 267)
(assert (= (func_rank drop_append_small) 267))
; Assert: (= (func_rank take_append_small) 268)
(assert (= (func_rank take_append_small) 268))
; Assert: (= (func_rank head_take) 269)
(assert (= (func_rank head_take) 269))
; Assert: (= (func_rank nonmem_map_filter) 270)
(assert (= (func_rank nonmem_map_filter) 270))
; Assert: (= (func_rank distinct_map_filter) 271)
(assert (= (func_rank distinct_map_filter) 271))
; Assert: (= (func_rank non_mem_map_remove) 272)
(assert (= (func_rank non_mem_map_remove) 272))
; Assert: (= (func_rank distinct_map_remove) 273)
(assert (= (func_rank distinct_map_remove) 273))
; Assert: (= (func_rank forall_filter) 274)
(assert (= (func_rank forall_filter) 274))
; Assert: (= (func_rank filter_append_idemp) 275)
(assert (= (func_rank filter_append_idemp) 275))
; Assert: (= (func_rank filter_forall) 276)
(assert (= (func_rank filter_forall) 276))
; Assert: (= (func_rank double_mem_append_nondistinct) 277)
(assert (= (func_rank double_mem_append_nondistinct) 277))
; Assert: (= (func_rank append_remove_first) 278)
(assert (= (func_rank append_remove_first) 278))
; Assert: (= (func_rank rem_preserves_no_mem) 279)
(assert (= (func_rank rem_preserves_no_mem) 279))
; Assert: (= (func_rank distinct_unappend) 280)
(assert (= (func_rank distinct_unappend) 280))
; Assert: (= (func_rank disjoint_mem) 281)
(assert (= (func_rank disjoint_mem) 281))
; Assert: (= (func_rank disjoint_uncons) 282)
(assert (= (func_rank disjoint_uncons) 282))
; Assert: (= (func_rank disjoint_cons) 283)
(assert (= (func_rank disjoint_cons) 283))
; Assert: (= (func_rank distinct_and_disjoint_append) 284)
(assert (= (func_rank distinct_and_disjoint_append) 284))
; Assert: (= (func_rank disjoint_unappend_left) 285)
(assert (= (func_rank disjoint_unappend_left) 285))
; Assert: (= (func_rank disjoint_unappend) 286)
(assert (= (func_rank disjoint_unappend) 286))
; Assert: (= (func_rank disjoint_comm) 287)
(assert (= (func_rank disjoint_comm) 287))
; Assert: (= (func_rank disjoint_append_left) 288)
(assert (= (func_rank disjoint_append_left) 288))
; Assert: (= (func_rank disjoint_append) 289)
(assert (= (func_rank disjoint_append) 289))
; Assert: (= (func_rank distinct_unmap) 290)
(assert (= (func_rank distinct_unmap) 290))
; Assert: (= (func_rank map_remove) 291)
(assert (= (func_rank map_remove) 291))
; Assert: (= (func_rank remove_append_swap) 292)
(assert (= (func_rank remove_append_swap) 292))
; Assert: (= (func_rank unique_map_identical_elems) 293)
(assert (= (func_rank unique_map_identical_elems) 293))
; Assert: (= (func_rank distinct_map_identical_elems) 294)
(assert (= (func_rank distinct_map_identical_elems) 294))
; Assert: (= (func_rank filter_filter_swap) 295)
(assert (= (func_rank filter_filter_swap) 295))
; Assert: (= (func_rank filter_mem) 296)
(assert (= (func_rank filter_mem) 296))
; Assert: (= (func_rank mem_update) 297)
(assert (= (func_rank mem_update) 297))
; Assert: (= (func_rank filter_unmem) 298)
(assert (= (func_rank filter_unmem) 298))
; Assert: (= (func_rank filter_remove) 299)
(assert (= (func_rank filter_remove) 299))
; Assert: (= (func_rank index_of_positive) 300)
(assert (= (func_rank index_of_positive) 300))
; Assert: (= (func_rank nth_remove) 301)
(assert (= (func_rank nth_remove) 301))
; Assert: (= (func_rank update_remove) 302)
(assert (= (func_rank update_remove) 302))
; Assert: (= (func_rank mem_unfilter) 303)
(assert (= (func_rank mem_unfilter) 303))
; Assert: (= (func_rank mem_update_unrelevant) 304)
(assert (= (func_rank mem_update_unrelevant) 304))
; Assert: (= (func_rank update_update_rewrite) 305)
(assert (= (func_rank update_update_rewrite) 305))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(push)
(declare-fun lst () Inductive)
(declare-fun currentThread4 () Int)
(push)
(push)
; Assume: (= (length lst) 0)
(assert (= (length lst) 0))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst nil)
(assert (= lst nil))
(check-sat)
; Query: (= lst nil)
(push)
(assert (not (= lst nil)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h () Inductive)
(declare-fun t () Inductive)
(push)
(push)
; Assume: (= lst (cons h t))
(assert (= lst (cons h t)))
(check-sat)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst0 () Inductive)
(declare-fun currentThread5 () Int)
(push)
(push)
; Assume: (not (= lst0 nil))
(assert (not (= lst0 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst0 nil)
(assert (= lst0 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h0 () Inductive)
(declare-fun t0 () Inductive)
(push)
(push)
; Assume: (= lst0 (cons h0 t0))
(assert (= lst0 (cons h0 t0)))
(check-sat)
; Query: (= (nth 0 lst0) (head lst0))
(push)
(assert (not (= (nth 0 lst0) (head lst0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n0 () Int)
(declare-fun lst1 () Inductive)
(declare-fun head_0 () Inductive)
(declare-fun currentThread6 () Int)
(push)
(push)
; Assume: (< 0 n0)
(assert (< 0 n0))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst1 nil)
(assert (= lst1 nil))
(check-sat)
; Query: (= (nth (- n0 1) lst1) (nth n0 (cons head_0 lst1)))
(push)
(assert (not (= (nth (- n0 1) lst1) (nth n0 (cons head_0 lst1)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h1 () Inductive)
(declare-fun t1 () Inductive)
(push)
(push)
; Assume: (= lst1 (cons h1 t1))
(assert (= lst1 (cons h1 t1)))
(check-sat)
; Query: (= (nth (- n0 1) lst1) (nth n0 (cons head_0 lst1)))
(push)
(assert (not (= (nth (- n0 1) lst1) (nth n0 (cons head_0 lst1)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst2 () Inductive)
(declare-fun x4 () Inductive)
(declare-fun currentThread7 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst2 nil)
(assert (= lst2 nil))
(check-sat)
; Query: (= (nth (length lst2) (append lst2 (cons x4 nil))) x4)
(push)
(assert (not (= (nth (length lst2) (append lst2 (cons x4 nil))) x4)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h2 () Inductive)
(declare-fun t2 () Inductive)
(push)
(push)
; Assume: (= lst2 (cons h2 t2))
(assert (= lst2 (cons h2 t2)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (nth (length t2) (append t2 (cons x4 nil))) x4)
(assert (= (nth (length t2) (append t2 (cons x4 nil))) x4))
(check-sat)
; Query: (= (nth (length lst2) (append lst2 (cons x4 nil))) x4)
(push)
(assert (not (= (nth (length lst2) (append lst2 (cons x4 nil))) x4)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst3 () Inductive)
(declare-fun n1 () Int)
(declare-fun currentThread8 () Int)
(push)
(push)
; Assume: (<= 0 n1)
(assert (<= 0 n1))
(check-sat)
(push)
; Assume: (< n1 (length lst3))
(assert (< n1 (length lst3)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst3 nil)
(assert (= lst3 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h3 () Inductive)
(declare-fun t3 () Inductive)
(push)
(push)
; Assume: (= lst3 (cons h3 t3))
(assert (= lst3 (cons h3 t3)))
(check-sat)
(push)
(push)
; Assume: (not (= 0 n1))
(assert (not (= 0 n1)))
(check-sat)
(push)
; Query: (<= 0 (- n1 1))
(push)
(assert (not (<= 0 (- n1 1))))
(check-sat)
(pop 1)
; Query: (< (- n1 1) (length t3))
(push)
(assert (not (< (- n1 1) (length t3))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (take (+ (- n1 1) 1) t3) (append (take (- n1 1) t3) (cons (nth (- n1 1) t3) nil)))
(assert
   (= (take (+ (- n1 1) 1) t3)
      (append (take (- n1 1) t3) (cons (nth (- n1 1) t3) nil))))
(check-sat)
; Query: (= (take (+ n1 1) lst3) (append (take n1 lst3) (cons (nth n1 lst3) nil)))
(push)
(assert
   (not
      (= (take (+ n1 1) lst3)
         (append (take n1 lst3) (cons (nth n1 lst3) nil)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= 0 n1)))
(assert (not (not (= 0 n1))))
(check-sat)
(push)
; Query: (= (take (+ n1 1) lst3) (append (take n1 lst3) (cons (nth n1 lst3) nil)))
(push)
(assert
   (not
      (= (take (+ n1 1) lst3)
         (append (take n1 lst3) (cons (nth n1 lst3) nil)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n2 () Int)
(declare-fun lst4 () Inductive)
(declare-fun x5 () Inductive)
(declare-fun currentThread9 () Int)
(push)
(push)
; Assume: (<= 0 n2)
(assert (<= 0 n2))
(check-sat)
(push)
; Assume: (< n2 (length lst4))
(assert (< n2 (length lst4)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst4 nil)
(assert (= lst4 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h4 () Inductive)
(declare-fun t4 () Inductive)
(push)
(push)
; Assume: (= lst4 (cons h4 t4))
(assert (= lst4 (cons h4 t4)))
(check-sat)
(push)
(push)
; Assume: (= n2 0)
(assert (= n2 0))
(check-sat)
(push)
(push)
; Query: (= h4 (nth n2 lst4))
(push)
(assert (not (= h4 (nth n2 lst4))))
(check-sat)
(pop 1)
; Query: (= h4 (nth n2 (append lst4 (cons x5 nil))))
(push)
(assert (not (= h4 (nth n2 (append lst4 (cons x5 nil))))))
(check-sat)
(pop 1)
; Query: (= (nth n2 (append lst4 (cons x5 nil))) (nth n2 lst4))
(push)
(assert (not (= (nth n2 (append lst4 (cons x5 nil))) (nth n2 lst4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= n2 0))
(assert (not (= n2 0)))
(check-sat)
(push)
(push)
; Query: (<= 0 (- n2 1))
(push)
(assert (not (<= 0 (- n2 1))))
(check-sat)
(pop 1)
; Query: (< (- n2 1) (length t4))
(push)
(assert (not (< (- n2 1) (length t4))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (nth (- n2 1) (append t4 (cons x5 nil))) (nth (- n2 1) t4))
(assert (= (nth (- n2 1) (append t4 (cons x5 nil))) (nth (- n2 1) t4)))
(check-sat)
; Query: (= (nth n2 (append lst4 (cons x5 nil))) (nth n2 lst4))
(push)
(assert (not (= (nth n2 (append lst4 (cons x5 nil))) (nth n2 lst4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst5 () Inductive)
(declare-fun currentThread10 () Int)
(push)
(push)
; Assume: (not (= lst5 nil))
(assert (not (= lst5 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst5 nil)
(assert (= lst5 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h5 () Inductive)
(declare-fun t5 () Inductive)
(push)
(push)
; Assume: (= lst5 (cons h5 t5))
(assert (= lst5 (cons h5 t5)))
(check-sat)
(push)
(push)
; Assume: (= t5 nil)
(assert (= t5 nil))
(check-sat)
(push)
(push)
; Query: (= (length lst5) 1)
(push)
(assert (not (= (length lst5) 1)))
(check-sat)
(pop 1)
; Query: (= (take (- (length lst5) 1) lst5) nil)
(push)
(assert (not (= (take (- (length lst5) 1) lst5) nil)))
(check-sat)
(pop 1)
; Query: (= (cons (nth (- (length lst5) 1) lst5) nil) lst5)
(push)
(assert (not (= (cons (nth (- (length lst5) 1) lst5) nil) lst5)))
(check-sat)
(pop 1)
; Query: (= (append nil lst5) lst5)
(push)
(assert (not (= (append nil lst5) lst5)))
(check-sat)
(pop 1)
; Query: (= lst5 (append (take (- (length lst5) 1) lst5) (cons (nth (- (length lst5) 1) lst5) nil)))
(push)
(assert
   (not
      (= lst5
         (append (take (- (length lst5) 1) lst5)
            (cons (nth (- (length lst5) 1) lst5) nil)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= t5 nil))
(assert (not (= t5 nil)))
(check-sat)
(push)
(push)
; Query: (not (= t5 nil))
(push)
(assert (not (not (= t5 nil))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= t5 (append (take (- (length t5) 1) t5) (cons (nth (- (length t5) 1) t5) nil)))
(assert
   (= t5
      (append (take (- (length t5) 1) t5)
         (cons (nth (- (length t5) 1) t5) nil))))
(check-sat)
; Query: (= (take (- (length lst5) 1) lst5) (cons h5 (take (- (length t5) 1) t5)))
(push)
(assert
   (not
      (= (take (- (length lst5) 1) lst5)
         (cons h5 (take (- (length t5) 1) t5)))))
(check-sat)
(pop 1)
; Query: (= (nth (- (length lst5) 1) lst5) (nth (- (length t5) 1) t5))
(push)
(assert (not (= (nth (- (length lst5) 1) lst5) (nth (- (length t5) 1) t5))))
(check-sat)
(pop 1)
; Query: (= (append (take (- (length lst5) 1) lst5) (cons (nth (- (length lst5) 1) lst5) nil)) (cons h5 (append (take (- (length t5) 1) t5) (cons (nth (- (length t5) 1) t5) nil))))
(push)
(assert
   (not
      (=
         (append (take (- (length lst5) 1) lst5)
            (cons (nth (- (length lst5) 1) lst5) nil))
         (cons h5
            (append (take (- (length t5) 1) t5)
               (cons (nth (- (length t5) 1) t5) nil))))))
(check-sat)
(pop 1)
; Query: (= lst5 (append (take (- (length lst5) 1) lst5) (cons (nth (- (length lst5) 1) lst5) nil)))
(push)
(assert
   (not
      (= lst5
         (append (take (- (length lst5) 1) lst5)
            (cons (nth (- (length lst5) 1) lst5) nil)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun head_00 () Inductive)
(declare-fun tail_0 () Inductive)
(declare-fun n3 () Int)
(declare-fun currentThread11 () Int)
(push)
(push)
; Assume: (<= 0 n3)
(assert (<= 0 n3))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= tail_0 nil)
(assert (= tail_0 nil))
(check-sat)
; Query: (= (cons head_00 (take n3 tail_0)) (take (+ n3 1) (cons head_00 tail_0)))
(push)
(assert
   (not
      (= (cons head_00 (take n3 tail_0))
         (take (+ n3 1) (cons head_00 tail_0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h6 () Inductive)
(declare-fun t6 () Inductive)
(push)
(push)
; Assume: (= tail_0 (cons h6 t6))
(assert (= tail_0 (cons h6 t6)))
(check-sat)
; Query: (= (cons head_00 (take n3 tail_0)) (take (+ n3 1) (cons head_00 tail_0)))
(push)
(assert
   (not
      (= (cons head_00 (take n3 tail_0))
         (take (+ n3 1) (cons head_00 tail_0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst6 () Inductive)
(declare-fun currentThread12 () Int)
(push)
(push)
; Assume: (not (= lst6 nil))
(assert (not (= lst6 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst6 nil)
(assert (= lst6 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h7 () Inductive)
(declare-fun t7 () Inductive)
(push)
(push)
; Assume: (= lst6 (cons h7 t7))
(assert (= lst6 (cons h7 t7)))
(check-sat)
; Query: (= lst6 (cons (head lst6) (tail lst6)))
(push)
(assert (not (= lst6 (cons (head lst6) (tail lst6)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst7 () Inductive)
(declare-fun currentThread13 () Int)
(push)
(push)
; Assume: (not (= lst7 nil))
(assert (not (= lst7 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst7 nil)
(assert (= lst7 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h8 () Inductive)
(declare-fun t8 () Inductive)
(push)
(push)
; Assume: (= lst7 (cons h8 t8))
(assert (= lst7 (cons h8 t8)))
(check-sat)
; Query: (= (length lst7) (+ 1 (length (tail lst7))))
(push)
(assert (not (= (length lst7) (+ 1 (length (tail lst7))))))
(check-sat)
(pop 1)
; Query: (< 0 (length lst7))
(push)
(assert (not (< 0 (length lst7))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lhead () Inductive)
(declare-fun ltail () Inductive)
(declare-fun index () Int)
(declare-fun val () Inductive)
(declare-fun currentThread14 () Int)
(push)
(push)
; Assume: (< 0 index)
(assert (< 0 index))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= ltail nil)
(assert (= ltail nil))
(check-sat)
; Query: (= (tail (update index val (cons lhead ltail))) (update (- index 1) val ltail))
(push)
(assert
   (not
      (= (tail (update index val (cons lhead ltail)))
         (update (- index 1) val ltail))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h9 () Inductive)
(declare-fun t9 () Inductive)
(push)
(push)
; Assume: (= ltail (cons h9 t9))
(assert (= ltail (cons h9 t9)))
(check-sat)
(push)
(push)
; Assume: (= (- index 1) 0)
(assert (= (- index 1) 0))
(check-sat)
(push)
(push)
; Query: (= (tail (update index val (cons lhead ltail))) (update (- index 1) val ltail))
(push)
(assert
   (not
      (= (tail (update index val (cons lhead ltail)))
         (update (- index 1) val ltail))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (- index 1) 0))
(assert (not (= (- index 1) 0)))
(check-sat)
(push)
(push)
; Query: (< 0 (- index 1))
(push)
(assert (not (< 0 (- index 1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (tail (update (- index 1) val (cons h9 t9))) (update (- (- index 1) 1) val t9))
(assert
   (= (tail (update (- index 1) val (cons h9 t9)))
      (update (- (- index 1) 1) val t9)))
(check-sat)
; Query: (= (update (- index 1) val ltail) (cons h9 (update (- index 2) val t9)))
(push)
(assert
   (not
      (= (update (- index 1) val ltail)
         (cons h9 (update (- index 2) val t9)))))
(check-sat)
(pop 1)
; Query: (= (update index val (cons lhead ltail)) (cons lhead (update (- index 1) val ltail)))
(push)
(assert
   (not
      (= (update index val (cons lhead ltail))
         (cons lhead (update (- index 1) val ltail)))))
(check-sat)
(pop 1)
; Query: (= (tail (update index val (cons lhead ltail))) (update (- index 1) val ltail))
(push)
(assert
   (not
      (= (tail (update index val (cons lhead ltail)))
         (update (- index 1) val ltail))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst8 () Inductive)
(declare-fun val0 () Inductive)
(declare-fun currentThread15 () Int)
(push)
(push)
; Assume: (not (= lst8 nil))
(assert (not (= lst8 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst8 nil)
(assert (= lst8 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h10 () Inductive)
(declare-fun t10 () Inductive)
(push)
(push)
; Assume: (= lst8 (cons h10 t10))
(assert (= lst8 (cons h10 t10)))
(check-sat)
; Query: (= (tail lst8) (tail (update 0 val0 lst8)))
(push)
(assert (not (= (tail lst8) (tail (update 0 val0 lst8)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun index0 () Int)
(declare-fun lst9 () Inductive)
(declare-fun currentThread16 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst9 nil)
(assert (= lst9 nil))
(check-sat)
; Query: (= lst9 (update index0 (nth index0 lst9) lst9))
(push)
(assert (not (= lst9 (update index0 (nth index0 lst9) lst9))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h11 () Inductive)
(declare-fun t11 () Inductive)
(push)
(push)
; Assume: (= lst9 (cons h11 t11))
(assert (= lst9 (cons h11 t11)))
(check-sat)
(push)
(push)
; Assume: (= index0 0)
(assert (= index0 0))
(check-sat)
(push)
(push)
; Query: (= lst9 (update index0 (nth index0 lst9) lst9))
(push)
(assert (not (= lst9 (update index0 (nth index0 lst9) lst9))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= index0 0))
(assert (not (= index0 0)))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= t11 (update (- index0 1) (nth (- index0 1) t11) t11))
(assert (= t11 (update (- index0 1) (nth (- index0 1) t11) t11)))
(check-sat)
; Query: (= lst9 (update index0 (nth index0 lst9) lst9))
(push)
(assert (not (= lst9 (update index0 (nth index0 lst9) lst9))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(assert
   (forall ((var Int) (var0 Inductive))
      (! (=> true (= var0 (update var (nth var var0) var0)))
         :pattern ((update var (nth var var0) var0)))))
(push)
(declare-fun lst10 () Inductive)
(declare-fun n4 () Int)
(declare-fun val1 () Inductive)
(declare-fun currentThread17 () Int)
(push)
(push)
; Assume: (not (= lst10 nil))
(assert (not (= lst10 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst10 nil)
(assert (= lst10 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h12 () Inductive)
(declare-fun t12 () Inductive)
(push)
(push)
; Assume: (= lst10 (cons h12 t12))
(assert (= lst10 (cons h12 t12)))
(check-sat)
; Query: (not (= (update n4 val1 lst10) nil))
(push)
(assert (not (not (= (update n4 val1 lst10) nil))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun val2 () Inductive)
(declare-fun lst11 () Inductive)
(declare-fun currentThread18 () Int)
(push)
(push)
; Assume: (not (= lst11 nil))
(assert (not (= lst11 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst11 nil)
(assert (= lst11 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h13 () Inductive)
(declare-fun t13 () Inductive)
(push)
(push)
; Assume: (= lst11 (cons h13 t13))
(assert (= lst11 (cons h13 t13)))
(check-sat)
; Query: (= (head (update 0 val2 lst11)) val2)
(push)
(assert (not (= (head (update 0 val2 lst11)) val2)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n5 () Int)
(declare-fun val3 () Inductive)
(declare-fun lst12 () Inductive)
(declare-fun currentThread19 () Int)
(push)
(push)
; Assume: (< 0 n5)
(assert (< 0 n5))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst12 nil)
(assert (= lst12 nil))
(check-sat)
; Query: (= (head (update n5 val3 lst12)) (head lst12))
(push)
(assert (not (= (head (update n5 val3 lst12)) (head lst12))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h14 () Inductive)
(declare-fun t14 () Inductive)
(push)
(push)
; Assume: (= lst12 (cons h14 t14))
(assert (= lst12 (cons h14 t14)))
(check-sat)
; Query: (= (head (update n5 val3 lst12)) (head lst12))
(push)
(assert (not (= (head (update n5 val3 lst12)) (head lst12))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun vsearch () Inductive)
(declare-fun n6 () Int)
(declare-fun vnew () Inductive)
(declare-fun l () Inductive)
(declare-fun currentThread20 () Int)
(push)
(push)
; Assume: (= false (mem vsearch l))
(assert (= false (mem vsearch l)))
(check-sat)
(push)
; Assume: (not (= vsearch vnew))
(assert (not (= vsearch vnew)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l nil)
(assert (= l nil))
(check-sat)
; Query: (= false (mem vsearch (update n6 vnew l)))
(push)
(assert (not (= false (mem vsearch (update n6 vnew l)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h15 () Inductive)
(declare-fun t15 () Inductive)
(push)
(push)
; Assume: (= l (cons h15 t15))
(assert (= l (cons h15 t15)))
(check-sat)
(push)
(push)
; Assume: (= n6 0)
(assert (= n6 0))
(check-sat)
(push)
(push)
; Query: (= false (mem vsearch (update n6 vnew l)))
(push)
(assert (not (= false (mem vsearch (update n6 vnew l)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= n6 0))
(assert (not (= n6 0)))
(check-sat)
(push)
(push)
; Query: (= false (mem vsearch t15))
(push)
(assert (not (= false (mem vsearch t15))))
(check-sat)
(pop 1)
; Query: (not (= vsearch vnew))
(push)
(assert (not (not (= vsearch vnew))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem vsearch (update (- n6 1) vnew t15)))
(assert (= false (mem vsearch (update (- n6 1) vnew t15))))
(check-sat)
; Query: (= false (mem vsearch (update n6 vnew l)))
(push)
(assert (not (= false (mem vsearch (update n6 vnew l)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun k () Int)
(declare-fun i () Int)
(declare-fun val4 () Inductive)
(declare-fun l0 () Inductive)
(declare-fun currentThread21 () Int)
(push)
(push)
; Assume: (<= 0 k)
(assert (<= 0 k))
(check-sat)
(push)
; Assume: (<= k i)
(assert (<= k i))
(check-sat)
(push)
; Assume: (< i (length l0))
(assert (< i (length l0)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l0 nil)
(assert (= l0 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h16 () Inductive)
(declare-fun t16 () Inductive)
(push)
(push)
; Assume: (= l0 (cons h16 t16))
(assert (= l0 (cons h16 t16)))
(check-sat)
(push)
(push)
; Assume: (= k 0)
(assert (= k 0))
(check-sat)
(push)
; Query: (= (drop k (update i val4 l0)) (update (- i k) val4 (drop k l0)))
(push)
(assert
   (not (= (drop k (update i val4 l0)) (update (- i k) val4 (drop k l0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= k 0))
(assert (not (= k 0)))
(check-sat)
(push)
; Query: (<= 0 (- k 1))
(push)
(assert (not (<= 0 (- k 1))))
(check-sat)
(pop 1)
; Query: (<= (- k 1) (- i 1))
(push)
(assert (not (<= (- k 1) (- i 1))))
(check-sat)
(pop 1)
; Query: (< (- i 1) (length t16))
(push)
(assert (not (< (- i 1) (length t16))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (drop (- k 1) (update (- i 1) val4 t16)) (update (- (- i 1) (- k 1)) val4 (drop (- k 1) t16)))
(assert
   (= (drop (- k 1) (update (- i 1) val4 t16))
      (update (- (- i 1) (- k 1)) val4 (drop (- k 1) t16))))
(check-sat)
; Query: (= (drop k (update i val4 l0)) (update (- i k) val4 (drop k l0)))
(push)
(assert
   (not (= (drop k (update i val4 l0)) (update (- i k) val4 (drop k l0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun k0 () Int)
(declare-fun i0 () Int)
(declare-fun val5 () Inductive)
(declare-fun l1 () Inductive)
(declare-fun currentThread22 () Int)
(push)
(push)
; Assume: (<= 0 i0)
(assert (<= 0 i0))
(check-sat)
(push)
; Assume: (< i0 k0)
(assert (< i0 k0))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l1 nil)
(assert (= l1 nil))
(check-sat)
; Query: (= (drop k0 (update i0 val5 l1)) (drop k0 l1))
(push)
(assert (not (= (drop k0 (update i0 val5 l1)) (drop k0 l1))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h17 () Inductive)
(declare-fun t17 () Inductive)
(push)
(push)
; Assume: (= l1 (cons h17 t17))
(assert (= l1 (cons h17 t17)))
(check-sat)
(push)
(push)
; Assume: (= i0 0)
(assert (= i0 0))
(check-sat)
(push)
; Query: (= (drop k0 (update i0 val5 l1)) (drop k0 l1))
(push)
(assert (not (= (drop k0 (update i0 val5 l1)) (drop k0 l1))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= i0 0))
(assert (not (= i0 0)))
(check-sat)
(push)
; Query: (<= 0 (- i0 1))
(push)
(assert (not (<= 0 (- i0 1))))
(check-sat)
(pop 1)
; Query: (< (- i0 1) (- k0 1))
(push)
(assert (not (< (- i0 1) (- k0 1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (drop (- k0 1) (update (- i0 1) val5 t17)) (drop (- k0 1) t17))
(assert (= (drop (- k0 1) (update (- i0 1) val5 t17)) (drop (- k0 1) t17)))
(check-sat)
; Query: (= (drop k0 (update i0 val5 l1)) (drop k0 l1))
(push)
(assert (not (= (drop k0 (update i0 val5 l1)) (drop k0 l1))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun k1 () Int)
(declare-fun i1 () Int)
(declare-fun val6 () Inductive)
(declare-fun l2 () Inductive)
(declare-fun currentThread23 () Int)
(push)
(push)
; Assume: (<= 0 i1)
(assert (<= 0 i1))
(check-sat)
(push)
; Assume: (<= i1 k1)
(assert (<= i1 k1))
(check-sat)
(push)
; Assume: (< k1 (length l2))
(assert (< k1 (length l2)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l2 nil)
(assert (= l2 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h18 () Inductive)
(declare-fun t18 () Inductive)
(push)
(push)
; Assume: (= l2 (cons h18 t18))
(assert (= l2 (cons h18 t18)))
(check-sat)
(push)
(push)
; Assume: (= i1 0)
(assert (= i1 0))
(check-sat)
(push)
; Query: (= (take k1 (update i1 val6 l2)) (update i1 val6 (take k1 l2)))
(push)
(assert
   (not (= (take k1 (update i1 val6 l2)) (update i1 val6 (take k1 l2)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= i1 0))
(assert (not (= i1 0)))
(check-sat)
(push)
; Query: (<= 0 (- i1 1))
(push)
(assert (not (<= 0 (- i1 1))))
(check-sat)
(pop 1)
; Query: (<= (- i1 1) (- k1 1))
(push)
(assert (not (<= (- i1 1) (- k1 1))))
(check-sat)
(pop 1)
; Query: (< (- k1 1) (length t18))
(push)
(assert (not (< (- k1 1) (length t18))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (take (- k1 1) (update (- i1 1) val6 t18)) (update (- i1 1) val6 (take (- k1 1) t18)))
(assert
   (= (take (- k1 1) (update (- i1 1) val6 t18))
      (update (- i1 1) val6 (take (- k1 1) t18))))
(check-sat)
; Query: (= (take k1 (update i1 val6 l2)) (update i1 val6 (take k1 l2)))
(push)
(assert
   (not (= (take k1 (update i1 val6 l2)) (update i1 val6 (take k1 l2)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun k2 () Int)
(declare-fun i2 () Int)
(declare-fun val7 () Inductive)
(declare-fun l3 () Inductive)
(declare-fun currentThread24 () Int)
(push)
(push)
; Assume: (<= 0 k2)
(assert (<= 0 k2))
(check-sat)
(push)
; Assume: (<= k2 i2)
(assert (<= k2 i2))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l3 nil)
(assert (= l3 nil))
(check-sat)
; Query: (= (take k2 (update i2 val7 l3)) (take k2 l3))
(push)
(assert (not (= (take k2 (update i2 val7 l3)) (take k2 l3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h19 () Inductive)
(declare-fun t19 () Inductive)
(push)
(push)
; Assume: (= l3 (cons h19 t19))
(assert (= l3 (cons h19 t19)))
(check-sat)
(push)
(push)
; Assume: (= k2 0)
(assert (= k2 0))
(check-sat)
(push)
; Query: (= (take k2 (update i2 val7 l3)) (take k2 l3))
(push)
(assert (not (= (take k2 (update i2 val7 l3)) (take k2 l3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= k2 0))
(assert (not (= k2 0)))
(check-sat)
(push)
; Query: (<= 0 (- k2 1))
(push)
(assert (not (<= 0 (- k2 1))))
(check-sat)
(pop 1)
; Query: (<= (- k2 1) (- i2 1))
(push)
(assert (not (<= (- k2 1) (- i2 1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (take (- k2 1) (update (- i2 1) val7 t19)) (take (- k2 1) t19))
(assert (= (take (- k2 1) (update (- i2 1) val7 t19)) (take (- k2 1) t19)))
(check-sat)
; Query: (= (take k2 (update i2 val7 l3)) (take k2 l3))
(push)
(assert (not (= (take k2 (update i2 val7 l3)) (take k2 l3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst13 () Inductive)
(declare-fun prop () Inductive)
(declare-fun i3 () Int)
(declare-fun v () Inductive)
(declare-fun currentThread25 () Int)
(push)
(push)
; Assume: (= true (forall0 lst13 prop))
(assert (= true (forall0 lst13 prop)))
(check-sat)
(push)
; Assume: (= true (unbox_bool (_@ prop v)))
(assert (= true (unbox_bool (_@ prop v))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst13 nil)
(assert (= lst13 nil))
(check-sat)
; Query: (= true (forall0 (update i3 v lst13) prop))
(push)
(assert (not (= true (forall0 (update i3 v lst13) prop))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h20 () Inductive)
(declare-fun t20 () Inductive)
(push)
(push)
; Assume: (= lst13 (cons h20 t20))
(assert (= lst13 (cons h20 t20)))
(check-sat)
(push)
(push)
; Assume: (not (= i3 0))
(assert (not (= i3 0)))
(check-sat)
(push)
; Query: (= true (forall0 t20 prop))
(push)
(assert (not (= true (forall0 t20 prop))))
(check-sat)
(pop 1)
; Query: (= true (unbox_bool (_@ prop v)))
(push)
(assert (not (= true (unbox_bool (_@ prop v)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (update (- i3 1) v t20) prop))
(assert (= true (forall0 (update (- i3 1) v t20) prop)))
(check-sat)
; Query: (= true (forall0 (update i3 v lst13) prop))
(push)
(assert (not (= true (forall0 (update i3 v lst13) prop))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= i3 0)))
(assert (not (not (= i3 0))))
(check-sat)
(push)
; Query: (= true (forall0 (update i3 v lst13) prop))
(push)
(assert (not (= true (forall0 (update i3 v lst13) prop))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst14 () Inductive)
(declare-fun i4 () Int)
(declare-fun vi () Inductive)
(declare-fun j () Int)
(declare-fun vj () Inductive)
(declare-fun currentThread26 () Int)
(push)
(push)
; Assume: (not (= i4 j))
(assert (not (= i4 j)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst14 nil)
(assert (= lst14 nil))
(check-sat)
; Query: (= (update i4 vi (update j vj lst14)) (update j vj (update i4 vi lst14)))
(push)
(assert
   (not
      (= (update i4 vi (update j vj lst14))
         (update j vj (update i4 vi lst14)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h21 () Inductive)
(declare-fun t21 () Inductive)
(push)
(push)
; Assume: (= lst14 (cons h21 t21))
(assert (= lst14 (cons h21 t21)))
(check-sat)
(push)
(push)
; Assume: (= i4 0)
(assert (= i4 0))
(check-sat)
(push)
; Query: (= (update i4 vi (update j vj lst14)) (update j vj (update i4 vi lst14)))
(push)
(assert
   (not
      (= (update i4 vi (update j vj lst14))
         (update j vj (update i4 vi lst14)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= i4 0))
(assert (not (= i4 0)))
(check-sat)
(push)
(push)
(push)
; Assume: (= j 0)
(assert (= j 0))
(check-sat)
(push)
; Query: (= (update i4 vi (update j vj lst14)) (update j vj (update i4 vi lst14)))
(push)
(assert
   (not
      (= (update i4 vi (update j vj lst14))
         (update j vj (update i4 vi lst14)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= j 0))
(assert (not (= j 0)))
(check-sat)
(push)
; Query: (not (= (- i4 1) (- j 1)))
(push)
(assert (not (not (= (- i4 1) (- j 1)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (update (- i4 1) vi (update (- j 1) vj t21)) (update (- j 1) vj (update (- i4 1) vi t21)))
(assert
   (= (update (- i4 1) vi (update (- j 1) vj t21))
      (update (- j 1) vj (update (- i4 1) vi t21))))
(check-sat)
; Query: (= (update i4 vi (update j vj lst14)) (update j vj (update i4 vi lst14)))
(push)
(assert
   (not
      (= (update i4 vi (update j vj lst14))
         (update j vj (update i4 vi lst14)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun i5 () Int)
(declare-fun j0 () Int)
(declare-fun y () Inductive)
(declare-fun xs () Inductive)
(declare-fun currentThread27 () Int)
(push)
(push)
; Assume: (not (= i5 j0))
(assert (not (= i5 j0)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs nil)
(assert (= xs nil))
(check-sat)
; Query: (= (nth i5 (update j0 y xs)) (nth i5 xs))
(push)
(assert (not (= (nth i5 (update j0 y xs)) (nth i5 xs))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h22 () Inductive)
(declare-fun t22 () Inductive)
(push)
(push)
; Assume: (= xs (cons h22 t22))
(assert (= xs (cons h22 t22)))
(check-sat)
(push)
(push)
; Assume: (= j0 0)
(assert (= j0 0))
(check-sat)
(push)
; Query: (= (nth i5 (update j0 y xs)) (nth i5 xs))
(push)
(assert (not (= (nth i5 (update j0 y xs)) (nth i5 xs))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= j0 0))
(assert (not (= j0 0)))
(check-sat)
(push)
(push)
(push)
; Assume: (= i5 0)
(assert (= i5 0))
(check-sat)
(push)
; Query: (= (nth i5 (update j0 y xs)) (nth i5 xs))
(push)
(assert (not (= (nth i5 (update j0 y xs)) (nth i5 xs))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= i5 0))
(assert (not (= i5 0)))
(check-sat)
(push)
; Query: (not (= (- i5 1) (- j0 1)))
(push)
(assert (not (not (= (- i5 1) (- j0 1)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (nth (- i5 1) (update (- j0 1) y t22)) (nth (- i5 1) t22))
(assert (= (nth (- i5 1) (update (- j0 1) y t22)) (nth (- i5 1) t22)))
(check-sat)
; Query: (= (nth i5 (update j0 y xs)) (nth i5 xs))
(push)
(assert (not (= (nth i5 (update j0 y xs)) (nth i5 xs))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst15 () Inductive)
(declare-fun n7 () Int)
(declare-fun currentThread28 () Int)
(push)
(push)
; Assume: (<= 0 n7)
(assert (<= 0 n7))
(check-sat)
(push)
; Assume: (< n7 (length lst15))
(assert (< n7 (length lst15)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst15 nil)
(assert (= lst15 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h23 () Inductive)
(declare-fun t23 () Inductive)
(push)
(push)
; Assume: (= lst15 (cons h23 t23))
(assert (= lst15 (cons h23 t23)))
(check-sat)
(push)
(push)
; Assume: (= n7 0)
(assert (= n7 0))
(check-sat)
(push)
(push)
; Query: (= (drop (+ n7 1) lst15) (tail (drop n7 lst15)))
(push)
(assert (not (= (drop (+ n7 1) lst15) (tail (drop n7 lst15)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= n7 0))
(assert (not (= n7 0)))
(check-sat)
(push)
(push)
; Query: (<= 0 (- n7 1))
(push)
(assert (not (<= 0 (- n7 1))))
(check-sat)
(pop 1)
; Query: (< (- n7 1) (length t23))
(push)
(assert (not (< (- n7 1) (length t23))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (drop (+ (- n7 1) 1) t23) (tail (drop (- n7 1) t23)))
(assert (= (drop (+ (- n7 1) 1) t23) (tail (drop (- n7 1) t23))))
(check-sat)
; Query: (= (drop (+ n7 1) lst15) (tail (drop n7 lst15)))
(push)
(assert (not (= (drop (+ n7 1) lst15) (tail (drop n7 lst15)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst16 () Inductive)
(declare-fun n8 () Int)
(declare-fun currentThread29 () Int)
(push)
(push)
; Assume: (<= 0 n8)
(assert (<= 0 n8))
(check-sat)
(push)
; Assume: (< n8 (length lst16))
(assert (< n8 (length lst16)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst16 nil)
(assert (= lst16 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h24 () Inductive)
(declare-fun t24 () Inductive)
(push)
(push)
; Assume: (= lst16 (cons h24 t24))
(assert (= lst16 (cons h24 t24)))
(check-sat)
(push)
(push)
; Assume: (not (= n8 0))
(assert (not (= n8 0)))
(check-sat)
(push)
; Query: (<= 0 (- n8 1))
(push)
(assert (not (<= 0 (- n8 1))))
(check-sat)
(pop 1)
; Query: (< (- n8 1) (length t24))
(push)
(assert (not (< (- n8 1) (length t24))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (drop (- n8 1) t24) (cons (nth (- n8 1) t24) (drop (+ (- n8 1) 1) t24)))
(assert
   (= (drop (- n8 1) t24)
      (cons (nth (- n8 1) t24) (drop (+ (- n8 1) 1) t24))))
(check-sat)
; Query: (= (drop n8 lst16) (cons (nth n8 lst16) (drop (+ n8 1) lst16)))
(push)
(assert
   (not (= (drop n8 lst16) (cons (nth n8 lst16) (drop (+ n8 1) lst16)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= n8 0)))
(assert (not (not (= n8 0))))
(check-sat)
(push)
; Query: (= (drop n8 lst16) (cons (nth n8 lst16) (drop (+ n8 1) lst16)))
(push)
(assert
   (not (= (drop n8 lst16) (cons (nth n8 lst16) (drop (+ n8 1) lst16)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun head_01 () Inductive)
(declare-fun tail_00 () Inductive)
(declare-fun currentThread30 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
; Assert: (< (func_rank reverse_append) 0)
(assert (< (func_rank reverse_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (reverse (append (reverse tail_00) (cons head_01 nil))) (append (reverse (cons head_01 nil)) (reverse (reverse tail_00))))
(assert
   (= (reverse (append (reverse tail_00) (cons head_01 nil)))
      (append (reverse (cons head_01 nil)) (reverse (reverse tail_00)))))
(check-sat)
; Query: (= (reverse (cons head_01 tail_00)) (append (reverse tail_00) (cons head_01 nil)))
(push)
(assert
   (not
      (= (reverse (cons head_01 tail_00))
         (append (reverse tail_00) (cons head_01 nil)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n9 () Int)
(declare-fun head_02 () Inductive)
(declare-fun tail_01 () Inductive)
(declare-fun tt () Inductive)
(declare-fun currentThread31 () Int)
(push)
(push)
; Assume: (< 0 n9)
(assert (< 0 n9))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (reverse (cons head_02 (take (- n9 1) tail_01))) (append (reverse (take (- n9 1) tail_01)) (cons head_02 nil)))
(assert
   (= (reverse (cons head_02 (take (- n9 1) tail_01)))
      (append (reverse (take (- n9 1) tail_01)) (cons head_02 nil))))
(check-sat)
; Assert: (< (func_rank append_assoc) 0)
(assert (< (func_rank append_assoc) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (append (append (reverse (take (- n9 1) tail_01)) (cons head_02 nil)) tt) (append (reverse (take (- n9 1) tail_01)) (append (cons head_02 nil) tt)))
(assert
   (=
      (append (append (reverse (take (- n9 1) tail_01)) (cons head_02 nil))
         tt)
      (append (reverse (take (- n9 1) tail_01))
         (append (cons head_02 nil) tt))))
(check-sat)
; Query: (= (append (reverse (take (- n9 1) tail_01)) (cons head_02 tt)) (append (reverse (take n9 (cons head_02 tail_01))) tt))
(push)
(assert
   (not
      (= (append (reverse (take (- n9 1) tail_01)) (cons head_02 tt))
         (append (reverse (take n9 (cons head_02 tail_01))) tt))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_1 () Inductive)
(declare-fun l_2 () Inductive)
(declare-fun currentThread32 () Int)
(push)
(push)
; Assume: (not (= l_1 nil))
(assert (not (= l_1 nil)))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (reverse (cons (head l_1) (tail l_1))) (append (reverse (tail l_1)) (cons (head l_1) nil)))
(assert
   (= (reverse (cons (head l_1) (tail l_1)))
      (append (reverse (tail l_1)) (cons (head l_1) nil))))
(check-sat)
; Query: (not (= l_1 nil))
(push)
(assert (not (not (= l_1 nil))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= l_1 (cons (head l_1) (tail l_1)))
(assert (= l_1 (cons (head l_1) (tail l_1))))
(check-sat)
; Assert: (< (func_rank append_assoc) 0)
(assert (< (func_rank append_assoc) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (append (append (reverse (tail l_1)) (cons (head l_1) nil)) l_2) (append (reverse (tail l_1)) (append (cons (head l_1) nil) l_2)))
(assert
   (= (append (append (reverse (tail l_1)) (cons (head l_1) nil)) l_2)
      (append (reverse (tail l_1)) (append (cons (head l_1) nil) l_2))))
(check-sat)
; Query: (= (append (reverse (tail l_1)) (cons (head l_1) l_2)) (append (reverse l_1) l_2))
(push)
(assert
   (not
      (= (append (reverse (tail l_1)) (cons (head l_1) l_2))
         (append (reverse l_1) l_2))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_10 () Inductive)
(declare-fun el () Inductive)
(declare-fun l_20 () Inductive)
(declare-fun currentThread33 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_10 nil)
(assert (= l_10 nil))
(check-sat)
; Query: (= (append (append l_10 (cons el nil)) l_20) (append l_10 (cons el l_20)))
(push)
(assert
   (not
      (= (append (append l_10 (cons el nil)) l_20)
         (append l_10 (cons el l_20)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h25 () Inductive)
(declare-fun t25 () Inductive)
(push)
(push)
; Assume: (= l_10 (cons h25 t25))
(assert (= l_10 (cons h25 t25)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (append (append t25 (cons el nil)) l_20) (append t25 (cons el l_20)))
(assert
   (= (append (append t25 (cons el nil)) l_20) (append t25 (cons el l_20))))
(check-sat)
; Query: (= (append (append l_10 (cons el nil)) l_20) (append l_10 (cons el l_20)))
(push)
(assert
   (not
      (= (append (append l_10 (cons el nil)) l_20)
         (append l_10 (cons el l_20)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_11 () Inductive)
(declare-fun l_21 () Inductive)
(declare-fun l_3 () Inductive)
(declare-fun currentThread34 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_11 nil)
(assert (= l_11 nil))
(check-sat)
; Query: (= (append (append l_11 l_21) l_3) (append l_11 (append l_21 l_3)))
(push)
(assert
   (not (= (append (append l_11 l_21) l_3) (append l_11 (append l_21 l_3)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h26 () Inductive)
(declare-fun t26 () Inductive)
(push)
(push)
; Assume: (= l_11 (cons h26 t26))
(assert (= l_11 (cons h26 t26)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (append (append t26 l_21) l_3) (append t26 (append l_21 l_3)))
(assert (= (append (append t26 l_21) l_3) (append t26 (append l_21 l_3))))
(check-sat)
; Query: (= (append (append l_11 l_21) l_3) (append l_11 (append l_21 l_3)))
(push)
(assert
   (not (= (append (append l_11 l_21) l_3) (append l_11 (append l_21 l_3)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst17 () Inductive)
(declare-fun p () Inductive)
(declare-fun i6 () Int)
(declare-fun currentThread35 () Int)
(push)
(push)
; Assume: (<= 0 i6)
(assert (<= 0 i6))
(check-sat)
(push)
; Assume: (< i6 (length lst17))
(assert (< i6 (length lst17)))
(check-sat)
(push)
; Assume: (= true (forall0 lst17 p))
(assert (= true (forall0 lst17 p)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst17 nil)
(assert (= lst17 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h27 () Inductive)
(declare-fun t27 () Inductive)
(push)
(push)
; Assume: (= lst17 (cons h27 t27))
(assert (= lst17 (cons h27 t27)))
(check-sat)
(push)
(push)
; Assume: (= i6 0)
(assert (= i6 0))
(check-sat)
(push)
(push)
; Query: (= true (unbox_bool (_@ p (nth i6 lst17))))
(push)
(assert (not (= true (unbox_bool (_@ p (nth i6 lst17))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= i6 0))
(assert (not (= i6 0)))
(check-sat)
(push)
(push)
; Query: (<= 0 (- i6 1))
(push)
(assert (not (<= 0 (- i6 1))))
(check-sat)
(pop 1)
; Query: (< (- i6 1) (length t27))
(push)
(assert (not (< (- i6 1) (length t27))))
(check-sat)
(pop 1)
; Query: (= true (forall0 t27 p))
(push)
(assert (not (= true (forall0 t27 p))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (unbox_bool (_@ p (nth (- i6 1) t27))))
(assert (= true (unbox_bool (_@ p (nth (- i6 1) t27)))))
(check-sat)
; Query: (= true (unbox_bool (_@ p (nth i6 lst17))))
(push)
(assert (not (= true (unbox_bool (_@ p (nth i6 lst17))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst18 () Inductive)
(declare-fun x6 () Inductive)
(declare-fun p0 () Inductive)
(declare-fun currentThread36 () Int)
(push)
(push)
; Assume: (= true (forall0 lst18 p0))
(assert (= true (forall0 lst18 p0)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst18 nil)
(assert (= lst18 nil))
(check-sat)
; Query: (= true (forall0 (remove x6 lst18) p0))
(push)
(assert (not (= true (forall0 (remove x6 lst18) p0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h28 () Inductive)
(declare-fun t28 () Inductive)
(push)
(push)
; Assume: (= lst18 (cons h28 t28))
(assert (= lst18 (cons h28 t28)))
(check-sat)
(push)
(push)
; Assume: (= h28 x6)
(assert (= h28 x6))
(check-sat)
(push)
(push)
; Query: (= true (forall0 (remove x6 lst18) p0))
(push)
(assert (not (= true (forall0 (remove x6 lst18) p0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h28 x6))
(assert (not (= h28 x6)))
(check-sat)
(push)
(push)
; Query: (= true (forall0 t28 p0))
(push)
(assert (not (= true (forall0 t28 p0))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (remove x6 t28) p0))
(assert (= true (forall0 (remove x6 t28) p0)))
(check-sat)
; Query: (= true (forall0 (remove x6 lst18) p0))
(push)
(assert (not (= true (forall0 (remove x6 lst18) p0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n10 () Int)
(declare-fun m () Int)
(declare-fun l4 () Inductive)
(declare-fun currentThread37 () Int)
(push)
(push)
; Assume: (<= 0 n10)
(assert (<= 0 n10))
(check-sat)
(push)
; Assume: (<= 0 m)
(assert (<= 0 m))
(check-sat)
(push)
; Assume: (<= (+ n10 m) (length l4))
(assert (<= (+ n10 m) (length l4)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l4 nil)
(assert (= l4 nil))
(check-sat)
; Query: (= (drop n10 (drop m l4)) (drop (+ n10 m) l4))
(push)
(assert (not (= (drop n10 (drop m l4)) (drop (+ n10 m) l4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h29 () Inductive)
(declare-fun t29 () Inductive)
(push)
(push)
; Assume: (= l4 (cons h29 t29))
(assert (= l4 (cons h29 t29)))
(check-sat)
(push)
(push)
; Assume: (= n10 0)
(assert (= n10 0))
(check-sat)
(push)
; Query: (= (drop n10 (drop m l4)) (drop (+ n10 m) l4))
(push)
(assert (not (= (drop n10 (drop m l4)) (drop (+ n10 m) l4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= n10 0))
(assert (not (= n10 0)))
(check-sat)
(push)
(push)
(push)
; Assume: (= m 0)
(assert (= m 0))
(check-sat)
(push)
; Query: (= (drop n10 (drop m l4)) (drop (+ n10 m) l4))
(push)
(assert (not (= (drop n10 (drop m l4)) (drop (+ n10 m) l4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= m 0))
(assert (not (= m 0)))
(check-sat)
(push)
; Query: (<= 0 n10)
(push)
(assert (not (<= 0 n10)))
(check-sat)
(pop 1)
; Query: (<= 0 (- m 1))
(push)
(assert (not (<= 0 (- m 1))))
(check-sat)
(pop 1)
; Query: (<= (+ n10 (- m 1)) (length t29))
(push)
(assert (not (<= (+ n10 (- m 1)) (length t29))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (drop n10 (drop (- m 1) t29)) (drop (+ n10 (- m 1)) t29))
(assert (= (drop n10 (drop (- m 1) t29)) (drop (+ n10 (- m 1)) t29)))
(check-sat)
; Query: (= (drop n10 (drop m l4)) (drop (+ n10 m) l4))
(push)
(assert (not (= (drop n10 (drop m l4)) (drop (+ n10 m) l4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun a () Inductive)
(declare-fun b () Inductive)
(declare-fun currentThread38 () Int)
(push)
(push)
; Assume: (not (= a nil))
(assert (not (= a nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= a nil)
(assert (= a nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h30 () Inductive)
(declare-fun t30 () Inductive)
(push)
(push)
; Assume: (= a (cons h30 t30))
(assert (= a (cons h30 t30)))
(check-sat)
; Query: (not (= (append a b) nil))
(push)
(assert (not (not (= (append a b) nil))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f () Inductive)
(declare-fun xs0 () Inductive)
(declare-fun currentThread39 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs0 nil)
(assert (= xs0 nil))
(check-sat)
; Query: (<= (length (filter f xs0)) (length xs0))
(push)
(assert (not (<= (length (filter f xs0)) (length xs0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h31 () Inductive)
(declare-fun t31 () Inductive)
(push)
(push)
; Assume: (= xs0 (cons h31 t31))
(assert (= xs0 (cons h31 t31)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= (length (filter f t31)) (length t31))
(assert (<= (length (filter f t31)) (length t31)))
(check-sat)
; Query: (<= (length (filter f xs0)) (length xs0))
(push)
(assert (not (<= (length (filter f xs0)) (length xs0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f0 () Inductive)
(declare-fun xs1 () Inductive)
(declare-fun currentThread40 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs1 nil)
(assert (= xs1 nil))
(check-sat)
; Query: (= (length (map0 f0 xs1)) (length xs1))
(push)
(assert (not (= (length (map0 f0 xs1)) (length xs1))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h32 () Inductive)
(declare-fun t32 () Inductive)
(push)
(push)
; Assume: (= xs1 (cons h32 t32))
(assert (= xs1 (cons h32 t32)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (length (map0 f0 t32)) (length t32))
(assert (= (length (map0 f0 t32)) (length t32)))
(check-sat)
; Query: (= (length (map0 f0 xs1)) (length xs1))
(push)
(assert (not (= (length (map0 f0 xs1)) (length xs1))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l5 () Inductive)
(declare-fun n11 () Int)
(declare-fun currentThread41 () Int)
(push)
(push)
; Assume: (<= 0 n11)
(assert (<= 0 n11))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l5 nil)
(assert (= l5 nil))
(check-sat)
(push)
(push)
; Assume: (<= n11 (length l5))
(assert (<= n11 (length l5)))
(check-sat)
; Query: (= (length (take n11 l5)) n11)
(push)
(assert (not (= (length (take n11 l5)) n11)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= n11 (length l5)))
(assert (not (<= n11 (length l5))))
(check-sat)
; Query: (= (length (take n11 l5)) (length l5))
(push)
(assert (not (= (length (take n11 l5)) (length l5))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h33 () Inductive)
(declare-fun t33 () Inductive)
(push)
(push)
; Assume: (= l5 (cons h33 t33))
(assert (= l5 (cons h33 t33)))
(check-sat)
(push)
(push)
; Assume: (not (= n11 0))
(assert (not (= n11 0)))
(check-sat)
(push)
; Query: (<= 0 (- n11 1))
(push)
(assert (not (<= 0 (- n11 1))))
(check-sat)
(pop 1)
(push)
(push)
(push)
; Assume: (<= (- n11 1) (length t33))
(assert (<= (- n11 1) (length t33)))
(check-sat)
(push)
; Assume: (= (length (take (- n11 1) t33)) (- n11 1))
(assert (= (length (take (- n11 1) t33)) (- n11 1)))
(check-sat)
(push)
(push)
; Assume: (<= n11 (length l5))
(assert (<= n11 (length l5)))
(check-sat)
; Query: (= (length (take n11 l5)) n11)
(push)
(assert (not (= (length (take n11 l5)) n11)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= n11 (length l5)))
(assert (not (<= n11 (length l5))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= (- n11 1) (length t33)))
(assert (not (<= (- n11 1) (length t33))))
(check-sat)
(push)
; Assume: (= (length (take (- n11 1) t33)) (length t33))
(assert (= (length (take (- n11 1) t33)) (length t33)))
(check-sat)
(push)
(push)
; Assume: (<= n11 (length l5))
(assert (<= n11 (length l5)))
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= n11 (length l5)))
(assert (not (<= n11 (length l5))))
(check-sat)
; Query: (= (length (take n11 l5)) (length l5))
(push)
(assert (not (= (length (take n11 l5)) (length l5))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= n11 0)))
(assert (not (not (= n11 0))))
(check-sat)
(push)
(push)
(push)
; Assume: (<= n11 (length l5))
(assert (<= n11 (length l5)))
(check-sat)
; Query: (= (length (take n11 l5)) n11)
(push)
(assert (not (= (length (take n11 l5)) n11)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= n11 (length l5)))
(assert (not (<= n11 (length l5))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l6 () Inductive)
(declare-fun f1 () Inductive)
(declare-fun currentThread42 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l6 nil)
(assert (= l6 nil))
(check-sat)
; Query: (= (length l6) (length (map0 f1 l6)))
(push)
(assert (not (= (length l6) (length (map0 f1 l6)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h34 () Inductive)
(declare-fun t34 () Inductive)
(push)
(push)
; Assume: (= l6 (cons h34 t34))
(assert (= l6 (cons h34 t34)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (length t34) (length (map0 f1 t34)))
(assert (= (length t34) (length (map0 f1 t34))))
(check-sat)
; Query: (= (length l6) (length (map0 f1 l6)))
(push)
(assert (not (= (length l6) (length (map0 f1 l6)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l7 () Inductive)
(declare-fun f2 () Inductive)
(declare-fun currentThread43 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l7 nil)
(assert (= l7 nil))
(check-sat)
(push)
(push)
; Assume: (= (length (filter f2 l7)) (length l7))
(assert (= (length (filter f2 l7)) (length l7)))
(check-sat)
; Query: (= (filter f2 l7) l7)
(push)
(assert (not (= (filter f2 l7) l7)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (length (filter f2 l7)) (length l7)))
(assert (not (= (length (filter f2 l7)) (length l7))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h35 () Inductive)
(declare-fun t35 () Inductive)
(push)
(push)
; Assume: (= l7 (cons h35 t35))
(assert (= l7 (cons h35 t35)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
(push)
; Assume: (= (length (filter f2 t35)) (length t35))
(assert (= (length (filter f2 t35)) (length t35)))
(check-sat)
(push)
; Assume: (= (filter f2 t35) t35)
(assert (= (filter f2 t35) t35))
(check-sat)
(push)
(push)
; Assume: (= (length (filter f2 l7)) (length l7))
(assert (= (length (filter f2 l7)) (length l7)))
(check-sat)
; Query: (= (filter f2 l7) l7)
(push)
(assert (not (= (filter f2 l7) l7)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (length (filter f2 l7)) (length l7)))
(assert (not (= (length (filter f2 l7)) (length l7))))
(check-sat)
; Query: (< (length (filter f2 l7)) (length l7))
(push)
(assert (not (< (length (filter f2 l7)) (length l7))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (length (filter f2 t35)) (length t35)))
(assert (not (= (length (filter f2 t35)) (length t35))))
(check-sat)
(push)
; Assume: (< (length (filter f2 t35)) (length t35))
(assert (< (length (filter f2 t35)) (length t35)))
(check-sat)
(push)
(push)
; Assume: (= (length (filter f2 l7)) (length l7))
(assert (= (length (filter f2 l7)) (length l7)))
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (length (filter f2 l7)) (length l7)))
(assert (not (= (length (filter f2 l7)) (length l7))))
(check-sat)
; Query: (< (length (filter f2 l7)) (length l7))
(push)
(assert (not (< (length (filter f2 l7)) (length l7))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n12 () Int)
(declare-fun lst19 () Inductive)
(declare-fun currentThread44 () Int)
(push)
(push)
; Assume: (<= 0 n12)
(assert (<= 0 n12))
(check-sat)
(push)
; Assume: (< n12 (length lst19))
(assert (< n12 (length lst19)))
(check-sat)
(declare-fun head_03 () Inductive)
(declare-fun dummy () Inductive)
(push)
; Assume: (= (drop n12 lst19) (cons head_03 dummy))
(assert (= (drop n12 lst19) (cons head_03 dummy)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst19 nil)
(assert (= lst19 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h36 () Inductive)
(declare-fun t36 () Inductive)
(push)
(push)
; Assume: (= lst19 (cons h36 t36))
(assert (= lst19 (cons h36 t36)))
(check-sat)
(push)
(push)
; Assume: (< 0 n12)
(assert (< 0 n12))
(check-sat)
(push)
; Query: (<= 0 (- n12 1))
(push)
(assert (not (<= 0 (- n12 1))))
(check-sat)
(pop 1)
; Query: (< (- n12 1) (length t36))
(push)
(assert (not (< (- n12 1) (length t36))))
(check-sat)
(pop 1)
(push)
; Assume: (= (drop (- n12 1) t36) nil)
(assert (= (drop (- n12 1) t36) nil))
(check-sat)
(pop 1)
(declare-fun value5 () Inductive)
(declare-fun value_02 () Inductive)
(push)
; Assume: (= (drop (- n12 1) t36) (cons value5 value_02))
(assert (= (drop (- n12 1) t36) (cons value5 value_02)))
(check-sat)
(push)
(push)
; Assume: (= (nth (- n12 1) t36) value5)
(assert (= (nth (- n12 1) t36) value5))
(check-sat)
; Query: (= (nth n12 lst19) head_03)
(push)
(assert (not (= (nth n12 lst19) head_03)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (< 0 n12))
(assert (not (< 0 n12)))
(check-sat)
(push)
; Query: (= (nth n12 lst19) head_03)
(push)
(assert (not (= (nth n12 lst19) head_03)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n13 () Int)
(declare-fun m0 () Int)
(declare-fun lst20 () Inductive)
(declare-fun currentThread45 () Int)
(push)
(push)
; Assume: (<= 0 n13)
(assert (<= 0 n13))
(check-sat)
(push)
; Assume: (<= n13 m0)
(assert (<= n13 m0))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst20 nil)
(assert (= lst20 nil))
(check-sat)
; Query: (= (take n13 (take m0 lst20)) (take n13 lst20))
(push)
(assert (not (= (take n13 (take m0 lst20)) (take n13 lst20))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h37 () Inductive)
(declare-fun t37 () Inductive)
(push)
(push)
; Assume: (= lst20 (cons h37 t37))
(assert (= lst20 (cons h37 t37)))
(check-sat)
(push)
(push)
; Assume: (< 0 n13)
(assert (< 0 n13))
(check-sat)
(push)
; Query: (<= 0 (- n13 1))
(push)
(assert (not (<= 0 (- n13 1))))
(check-sat)
(pop 1)
; Query: (<= (- n13 1) (- m0 1))
(push)
(assert (not (<= (- n13 1) (- m0 1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (take (- n13 1) (take (- m0 1) t37)) (take (- n13 1) t37))
(assert (= (take (- n13 1) (take (- m0 1) t37)) (take (- n13 1) t37)))
(check-sat)
; Query: (= (take n13 (take m0 lst20)) (take n13 lst20))
(push)
(assert (not (= (take n13 (take m0 lst20)) (take n13 lst20))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (< 0 n13))
(assert (not (< 0 n13)))
(check-sat)
(push)
; Query: (= (take n13 (take m0 lst20)) (take n13 lst20))
(push)
(assert (not (= (take n13 (take m0 lst20)) (take n13 lst20))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n14 () Int)
(declare-fun f3 () Inductive)
(declare-fun lst21 () Inductive)
(declare-fun currentThread46 () Int)
(push)
(push)
; Assume: (<= 0 n14)
(assert (<= 0 n14))
(check-sat)
(push)
; Assume: (< n14 (length lst21))
(assert (< n14 (length lst21)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst21 nil)
(assert (= lst21 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h38 () Inductive)
(declare-fun t38 () Inductive)
(push)
(push)
; Assume: (= lst21 (cons h38 t38))
(assert (= lst21 (cons h38 t38)))
(check-sat)
(push)
(push)
; Assume: (< 0 n14)
(assert (< 0 n14))
(check-sat)
(push)
; Query: (<= 0 (- n14 1))
(push)
(assert (not (<= 0 (- n14 1))))
(check-sat)
(pop 1)
; Query: (< (- n14 1) (length t38))
(push)
(assert (not (< (- n14 1) (length t38))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (take (- n14 1) (map0 f3 t38)) (map0 f3 (take (- n14 1) t38)))
(assert (= (take (- n14 1) (map0 f3 t38)) (map0 f3 (take (- n14 1) t38))))
(check-sat)
; Query: (= (take n14 (map0 f3 lst21)) (map0 f3 (take n14 lst21)))
(push)
(assert (not (= (take n14 (map0 f3 lst21)) (map0 f3 (take n14 lst21)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (< 0 n14))
(assert (not (< 0 n14)))
(check-sat)
(push)
; Query: (= (take n14 (map0 f3 lst21)) (map0 f3 (take n14 lst21)))
(push)
(assert (not (= (take n14 (map0 f3 lst21)) (map0 f3 (take n14 lst21)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el0 () Inductive)
(declare-fun l8 () Inductive)
(declare-fun currentThread47 () Int)
(push)
(push)
; Assume: (= false (mem el0 l8))
(assert (= false (mem el0 l8)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l8 nil)
(assert (= l8 nil))
(check-sat)
; Query: (= (remove el0 l8) l8)
(push)
(assert (not (= (remove el0 l8) l8)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h39 () Inductive)
(declare-fun t39 () Inductive)
(push)
(push)
; Assume: (= l8 (cons h39 t39))
(assert (= l8 (cons h39 t39)))
(check-sat)
(push)
(push)
; Assume: (not (= h39 el0))
(assert (not (= h39 el0)))
(check-sat)
(push)
; Query: (= false (mem el0 t39))
(push)
(assert (not (= false (mem el0 t39))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el0 t39) t39)
(assert (= (remove el0 t39) t39))
(check-sat)
; Query: (= (remove el0 l8) l8)
(push)
(assert (not (= (remove el0 l8) l8)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h39 el0)))
(assert (not (not (= h39 el0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst22 () Inductive)
(declare-fun x7 () Inductive)
(declare-fun currentThread48 () Int)
(push)
(push)
; Assume: (= true (distinct0 lst22))
(assert (= true (distinct0 lst22)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst22 nil)
(assert (= lst22 nil))
(check-sat)
; Query: (= false (mem x7 (remove x7 lst22)))
(push)
(assert (not (= false (mem x7 (remove x7 lst22)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h40 () Inductive)
(declare-fun t40 () Inductive)
(push)
(push)
; Assume: (= lst22 (cons h40 t40))
(assert (= lst22 (cons h40 t40)))
(check-sat)
(push)
(push)
; Assume: (not (= h40 x7))
(assert (not (= h40 x7)))
(check-sat)
(push)
; Query: (= true (distinct0 t40))
(push)
(assert (not (= true (distinct0 t40))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem x7 (remove x7 t40)))
(assert (= false (mem x7 (remove x7 t40))))
(check-sat)
; Query: (= false (mem x7 (remove x7 lst22)))
(push)
(assert (not (= false (mem x7 (remove x7 lst22)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h40 x7)))
(assert (not (not (= h40 x7))))
(check-sat)
(push)
; Query: (= false (mem x7 (remove x7 lst22)))
(push)
(assert (not (= false (mem x7 (remove x7 lst22)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l9 () Inductive)
(declare-fun x8 () Inductive)
(declare-fun currentThread49 () Int)
(push)
(push)
; Assume: (= false (mem x8 (remove x8 l9)))
(assert (= false (mem x8 (remove x8 l9))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l9 nil)
(assert (= l9 nil))
(check-sat)
; Query: (= (distinct0 l9) (distinct0 (remove x8 l9)))
(push)
(assert (not (= (distinct0 l9) (distinct0 (remove x8 l9)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h41 () Inductive)
(declare-fun t41 () Inductive)
(push)
(push)
; Assume: (= l9 (cons h41 t41))
(assert (= l9 (cons h41 t41)))
(check-sat)
(push)
(push)
; Assume: (not (= h41 x8))
(assert (not (= h41 x8)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h41 x8))
(push)
(assert (not (not (= h41 x8))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h41 (remove x8 t41)) (mem h41 t41))
(assert (= (mem h41 (remove x8 t41)) (mem h41 t41)))
(check-sat)
; Query: (= false (mem x8 (remove x8 t41)))
(push)
(assert (not (= false (mem x8 (remove x8 t41)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (distinct0 t41) (distinct0 (remove x8 t41)))
(assert (= (distinct0 t41) (distinct0 (remove x8 t41))))
(check-sat)
; Query: (= (distinct0 l9) (distinct0 (remove x8 l9)))
(push)
(assert (not (= (distinct0 l9) (distinct0 (remove x8 l9)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h41 x8)))
(assert (not (not (= h41 x8))))
(check-sat)
(push)
; Query: (= (distinct0 l9) (distinct0 (remove x8 l9)))
(push)
(assert (not (= (distinct0 l9) (distinct0 (remove x8 l9)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l10 () Inductive)
(declare-fun x9 () Inductive)
(declare-fun currentThread50 () Int)
(push)
(push)
; Assume: (= true (distinct0 l10))
(assert (= true (distinct0 l10)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l10 nil)
(assert (= l10 nil))
(check-sat)
; Query: (= true (distinct0 (remove x9 l10)))
(push)
(assert (not (= true (distinct0 (remove x9 l10)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h42 () Inductive)
(declare-fun t42 () Inductive)
(push)
(push)
; Assume: (= l10 (cons h42 t42))
(assert (= l10 (cons h42 t42)))
(check-sat)
(push)
(push)
; Assume: (not (= h42 x9))
(assert (not (= h42 x9)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h42 x9))
(push)
(assert (not (not (= h42 x9))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h42 (remove x9 t42)) (mem h42 t42))
(assert (= (mem h42 (remove x9 t42)) (mem h42 t42)))
(check-sat)
; Query: (= true (distinct0 t42))
(push)
(assert (not (= true (distinct0 t42))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 (remove x9 t42)))
(assert (= true (distinct0 (remove x9 t42))))
(check-sat)
; Query: (= true (distinct0 (remove x9 l10)))
(push)
(assert (not (= true (distinct0 (remove x9 l10)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h42 x9)))
(assert (not (not (= h42 x9))))
(check-sat)
(push)
; Query: (= true (distinct0 (remove x9 l10)))
(push)
(assert (not (= true (distinct0 (remove x9 l10)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n15 () Int)
(declare-fun l_12 () Inductive)
(declare-fun l_22 () Inductive)
(declare-fun currentThread51 () Int)
(push)
(push)
; Assume: (<= 0 n15)
(assert (<= 0 n15))
(check-sat)
(push)
; Assume: (<= n15 (length l_12))
(assert (<= n15 (length l_12)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_12 nil)
(assert (= l_12 nil))
(check-sat)
; Query: (= (append (drop n15 l_12) l_22) (drop n15 (append l_12 l_22)))
(push)
(assert
   (not (= (append (drop n15 l_12) l_22) (drop n15 (append l_12 l_22)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h43 () Inductive)
(declare-fun t43 () Inductive)
(push)
(push)
; Assume: (= l_12 (cons h43 t43))
(assert (= l_12 (cons h43 t43)))
(check-sat)
(push)
(push)
; Assume: (= n15 0)
(assert (= n15 0))
(check-sat)
(push)
; Query: (= (append (drop n15 l_12) l_22) (drop n15 (append l_12 l_22)))
(push)
(assert
   (not (= (append (drop n15 l_12) l_22) (drop n15 (append l_12 l_22)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= n15 0))
(assert (not (= n15 0)))
(check-sat)
(push)
; Query: (<= 0 (- n15 1))
(push)
(assert (not (<= 0 (- n15 1))))
(check-sat)
(pop 1)
; Query: (<= (- n15 1) (length t43))
(push)
(assert (not (<= (- n15 1) (length t43))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (append (drop (- n15 1) t43) l_22) (drop (- n15 1) (append t43 l_22)))
(assert
   (= (append (drop (- n15 1) t43) l_22) (drop (- n15 1) (append t43 l_22))))
(check-sat)
; Query: (= (append (drop n15 l_12) l_22) (drop n15 (append l_12 l_22)))
(push)
(assert
   (not (= (append (drop n15 l_12) l_22) (drop n15 (append l_12 l_22)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n16 () Int)
(declare-fun l_13 () Inductive)
(declare-fun l_23 () Inductive)
(declare-fun currentThread52 () Int)
(push)
(push)
; Assume: (<= 0 n16)
(assert (<= 0 n16))
(check-sat)
(push)
; Assume: (<= n16 (length l_13))
(assert (<= n16 (length l_13)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_13 nil)
(assert (= l_13 nil))
(check-sat)
; Query: (= (take n16 l_13) (take n16 (append l_13 l_23)))
(push)
(assert (not (= (take n16 l_13) (take n16 (append l_13 l_23)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h44 () Inductive)
(declare-fun t44 () Inductive)
(push)
(push)
; Assume: (= l_13 (cons h44 t44))
(assert (= l_13 (cons h44 t44)))
(check-sat)
(push)
(push)
; Assume: (= n16 0)
(assert (= n16 0))
(check-sat)
(push)
; Query: (= (take n16 l_13) (take n16 (append l_13 l_23)))
(push)
(assert (not (= (take n16 l_13) (take n16 (append l_13 l_23)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= n16 0))
(assert (not (= n16 0)))
(check-sat)
(push)
; Query: (<= 0 (- n16 1))
(push)
(assert (not (<= 0 (- n16 1))))
(check-sat)
(pop 1)
; Query: (<= (- n16 1) (length t44))
(push)
(assert (not (<= (- n16 1) (length t44))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (take (- n16 1) t44) (take (- n16 1) (append t44 l_23)))
(assert (= (take (- n16 1) t44) (take (- n16 1) (append t44 l_23))))
(check-sat)
; Query: (= (take n16 l_13) (take n16 (append l_13 l_23)))
(push)
(assert (not (= (take n16 l_13) (take n16 (append l_13 l_23)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n17 () Int)
(declare-fun l11 () Inductive)
(declare-fun currentThread53 () Int)
(push)
(push)
; Assume: (< 0 n17)
(assert (< 0 n17))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l11 nil)
(assert (= l11 nil))
(check-sat)
; Query: (= (head l11) (head (take n17 l11)))
(push)
(assert (not (= (head l11) (head (take n17 l11)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h45 () Inductive)
(declare-fun t45 () Inductive)
(push)
(push)
; Assume: (= l11 (cons h45 t45))
(assert (= l11 (cons h45 t45)))
(check-sat)
(push)
(push)
; Assume: (= n17 1)
(assert (= n17 1))
(check-sat)
(push)
; Query: (= (head l11) (head (take n17 l11)))
(push)
(assert (not (= (head l11) (head (take n17 l11)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= n17 1))
(assert (not (= n17 1)))
(check-sat)
(push)
; Query: (< 0 (- n17 1))
(push)
(assert (not (< 0 (- n17 1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (head t45) (head (take (- n17 1) t45)))
(assert (= (head t45) (head (take (- n17 1) t45))))
(check-sat)
; Query: (= (head l11) (head (take n17 l11)))
(push)
(assert (not (= (head l11) (head (take n17 l11)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f_1 () Inductive)
(declare-fun f_2 () Inductive)
(declare-fun l12 () Inductive)
(declare-fun el1 () Inductive)
(declare-fun currentThread54 () Int)
(push)
(push)
; Assume: (= false (mem (_@ f_1 el1) (map0 f_1 l12)))
(assert (= false (mem (_@ f_1 el1) (map0 f_1 l12))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l12 nil)
(assert (= l12 nil))
(check-sat)
; Query: (= false (mem (_@ f_1 el1) (map0 f_1 (filter f_2 l12))))
(push)
(assert (not (= false (mem (_@ f_1 el1) (map0 f_1 (filter f_2 l12))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h46 () Inductive)
(declare-fun t46 () Inductive)
(push)
(push)
; Assume: (= l12 (cons h46 t46))
(assert (= l12 (cons h46 t46)))
(check-sat)
; Query: (= false (mem (_@ f_1 el1) (map0 f_1 t46)))
(push)
(assert (not (= false (mem (_@ f_1 el1) (map0 f_1 t46)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem (_@ f_1 el1) (map0 f_1 (filter f_2 t46))))
(assert (= false (mem (_@ f_1 el1) (map0 f_1 (filter f_2 t46)))))
(check-sat)
; Query: (= false (mem (_@ f_1 el1) (map0 f_1 (filter f_2 l12))))
(push)
(assert (not (= false (mem (_@ f_1 el1) (map0 f_1 (filter f_2 l12))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f_10 () Inductive)
(declare-fun f_20 () Inductive)
(declare-fun l13 () Inductive)
(declare-fun currentThread55 () Int)
(push)
(push)
; Assume: (= true (distinct0 (map0 f_10 l13)))
(assert (= true (distinct0 (map0 f_10 l13))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l13 nil)
(assert (= l13 nil))
(check-sat)
; Query: (= true (distinct0 (map0 f_10 (filter f_20 l13))))
(push)
(assert (not (= true (distinct0 (map0 f_10 (filter f_20 l13))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h47 () Inductive)
(declare-fun t47 () Inductive)
(push)
(push)
; Assume: (= l13 (cons h47 t47))
(assert (= l13 (cons h47 t47)))
(check-sat)
; Query: (= false (mem (_@ f_10 h47) (map0 f_10 t47)))
(push)
(assert (not (= false (mem (_@ f_10 h47) (map0 f_10 t47)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem (_@ f_10 h47) (map0 f_10 (filter f_20 t47))))
(assert (= false (mem (_@ f_10 h47) (map0 f_10 (filter f_20 t47)))))
(check-sat)
; Query: (= true (distinct0 (map0 f_10 t47)))
(push)
(assert (not (= true (distinct0 (map0 f_10 t47)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 (map0 f_10 (filter f_20 t47))))
(assert (= true (distinct0 (map0 f_10 (filter f_20 t47)))))
(check-sat)
; Query: (= true (distinct0 (map0 f_10 (filter f_20 l13))))
(push)
(assert (not (= true (distinct0 (map0 f_10 (filter f_20 l13))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l14 () Inductive)
(declare-fun x_1 () Inductive)
(declare-fun x_2 () Inductive)
(declare-fun f4 () Inductive)
(declare-fun currentThread56 () Int)
(push)
(push)
; Assume: (= false (mem x_1 (map0 f4 l14)))
(assert (= false (mem x_1 (map0 f4 l14))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l14 nil)
(assert (= l14 nil))
(check-sat)
; Query: (= false (mem x_1 (map0 f4 (remove x_2 l14))))
(push)
(assert (not (= false (mem x_1 (map0 f4 (remove x_2 l14))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h48 () Inductive)
(declare-fun t48 () Inductive)
(push)
(push)
; Assume: (= l14 (cons h48 t48))
(assert (= l14 (cons h48 t48)))
(check-sat)
(push)
(push)
; Assume: (not (= h48 x_2))
(assert (not (= h48 x_2)))
(check-sat)
(push)
(push)
; Query: (= false (mem x_1 (map0 f4 t48)))
(push)
(assert (not (= false (mem x_1 (map0 f4 t48)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem x_1 (map0 f4 (remove x_2 t48))))
(assert (= false (mem x_1 (map0 f4 (remove x_2 t48)))))
(check-sat)
; Query: (= false (mem x_1 (map0 f4 (remove x_2 l14))))
(push)
(assert (not (= false (mem x_1 (map0 f4 (remove x_2 l14))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h48 x_2)))
(assert (not (not (= h48 x_2))))
(check-sat)
(push)
; Query: (= false (mem x_1 (map0 f4 (remove x_2 l14))))
(push)
(assert (not (= false (mem x_1 (map0 f4 (remove x_2 l14))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l15 () Inductive)
(declare-fun f5 () Inductive)
(declare-fun x10 () Inductive)
(declare-fun currentThread57 () Int)
(push)
(push)
; Assume: (= true (distinct0 (map0 f5 l15)))
(assert (= true (distinct0 (map0 f5 l15))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l15 nil)
(assert (= l15 nil))
(check-sat)
; Query: (= true (distinct0 (map0 f5 (remove x10 l15))))
(push)
(assert (not (= true (distinct0 (map0 f5 (remove x10 l15))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h49 () Inductive)
(declare-fun t49 () Inductive)
(push)
(push)
; Assume: (= l15 (cons h49 t49))
(assert (= l15 (cons h49 t49)))
(check-sat)
(push)
(push)
; Assume: (not (= x10 h49))
(assert (not (= x10 h49)))
(check-sat)
(push)
(push)
; Query: (= false (mem (_@ f5 h49) (map0 f5 t49)))
(push)
(assert (not (= false (mem (_@ f5 h49) (map0 f5 t49)))))
(check-sat)
(pop 1)
; Query: (= false (mem (_@ f5 h49) (map0 f5 t49)))
(push)
(assert (not (= false (mem (_@ f5 h49) (map0 f5 t49)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem (_@ f5 h49) (map0 f5 (remove x10 t49))))
(assert (= false (mem (_@ f5 h49) (map0 f5 (remove x10 t49)))))
(check-sat)
; Query: (= false (mem (_@ f5 h49) (map0 f5 (remove x10 t49))))
(push)
(assert (not (= false (mem (_@ f5 h49) (map0 f5 (remove x10 t49))))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 (map0 f5 t49)))
(push)
(assert (not (= true (distinct0 (map0 f5 t49)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 (map0 f5 (remove x10 t49))))
(assert (= true (distinct0 (map0 f5 (remove x10 t49)))))
(check-sat)
; Query: (= true (distinct0 (map0 f5 (remove x10 l15))))
(push)
(assert (not (= true (distinct0 (map0 f5 (remove x10 l15))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= x10 h49)))
(assert (not (not (= x10 h49))))
(check-sat)
(push)
; Query: (= true (distinct0 (map0 f5 (remove x10 l15))))
(push)
(assert (not (= true (distinct0 (map0 f5 (remove x10 l15))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f_11 () Inductive)
(declare-fun f_21 () Inductive)
(declare-fun l16 () Inductive)
(declare-fun currentThread58 () Int)
(push)
(push)
; Assume: (= true (forall0 l16 f_11))
(assert (= true (forall0 l16 f_11)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l16 nil)
(assert (= l16 nil))
(check-sat)
; Query: (= true (forall0 (filter f_21 l16) f_11))
(push)
(assert (not (= true (forall0 (filter f_21 l16) f_11))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h50 () Inductive)
(declare-fun t50 () Inductive)
(push)
(push)
; Assume: (= l16 (cons h50 t50))
(assert (= l16 (cons h50 t50)))
(check-sat)
; Query: (= true (forall0 t50 f_11))
(push)
(assert (not (= true (forall0 t50 f_11))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (filter f_21 t50) f_11))
(assert (= true (forall0 (filter f_21 t50) f_11)))
(check-sat)
; Query: (= true (forall0 (filter f_21 l16) f_11))
(push)
(assert (not (= true (forall0 (filter f_21 l16) f_11))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_14 () Inductive)
(declare-fun l_24 () Inductive)
(declare-fun f6 () Inductive)
(declare-fun currentThread59 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_14 nil)
(assert (= l_14 nil))
(check-sat)
; Query: (= (filter f6 (append l_14 l_24)) (append (filter f6 l_14) (filter f6 l_24)))
(push)
(assert
   (not
      (= (filter f6 (append l_14 l_24))
         (append (filter f6 l_14) (filter f6 l_24)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h51 () Inductive)
(declare-fun t51 () Inductive)
(push)
(push)
; Assume: (= l_14 (cons h51 t51))
(assert (= l_14 (cons h51 t51)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (filter f6 (append t51 l_24)) (append (filter f6 t51) (filter f6 l_24)))
(assert
   (= (filter f6 (append t51 l_24))
      (append (filter f6 t51) (filter f6 l_24))))
(check-sat)
; Query: (= (filter f6 (append l_14 l_24)) (append (filter f6 l_14) (filter f6 l_24)))
(push)
(assert
   (not
      (= (filter f6 (append l_14 l_24))
         (append (filter f6 l_14) (filter f6 l_24)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f7 () Inductive)
(declare-fun l17 () Inductive)
(declare-fun currentThread60 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l17 nil)
(assert (= l17 nil))
(check-sat)
; Query: (= (= true (= l17 (filter f7 l17))) (forall0 l17 f7))
(push)
(assert (not (= (= true (= l17 (filter f7 l17))) (forall0 l17 f7))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (filter f7 l17) f7))
(push)
(assert (not (= true (forall0 (filter f7 l17) f7))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h52 () Inductive)
(declare-fun t52 () Inductive)
(push)
(push)
; Assume: (= l17 (cons h52 t52))
(assert (= l17 (cons h52 t52)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (= true (= t52 (filter f7 t52))) (forall0 t52 f7))
(assert (= (= true (= t52 (filter f7 t52))) (forall0 t52 f7)))
(check-sat)
(push)
; Assume: (= true (forall0 (filter f7 t52) f7))
(assert (= true (forall0 (filter f7 t52) f7)))
(check-sat)
(push)
(push)
; Assume: (unbox_bool (_@ f7 h52))
(assert (unbox_bool (_@ f7 h52)))
(check-sat)
(push)
(push)
; Query: (= (= true (= l17 (filter f7 l17))) (forall0 l17 f7))
(push)
(assert (not (= (= true (= l17 (filter f7 l17))) (forall0 l17 f7))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (filter f7 l17) f7))
(push)
(assert (not (= true (forall0 (filter f7 l17) f7))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (unbox_bool (_@ f7 h52)))
(assert (not (unbox_bool (_@ f7 h52))))
(check-sat)
(push)
(push)
; Query: (= false (forall0 l17 f7))
(push)
(assert (not (= false (forall0 l17 f7))))
(check-sat)
(pop 1)
; Query: (= (filter f7 l17) (filter f7 t52))
(push)
(assert (not (= (filter f7 l17) (filter f7 t52))))
(check-sat)
(pop 1)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= (length (filter f7 t52)) (length t52))
(assert (<= (length (filter f7 t52)) (length t52)))
(check-sat)
; Query: (< (length (filter f7 l17)) (length l17))
(push)
(assert (not (< (length (filter f7 l17)) (length l17))))
(check-sat)
(pop 1)
; Query: (not (= l17 (filter f7 l17)))
(push)
(assert (not (not (= l17 (filter f7 l17)))))
(check-sat)
(pop 1)
; Query: (= (= true (= l17 (filter f7 l17))) (forall0 l17 f7))
(push)
(assert (not (= (= true (= l17 (filter f7 l17))) (forall0 l17 f7))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (filter f7 l17) f7))
(push)
(assert (not (= true (forall0 (filter f7 l17) f7))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_15 () Inductive)
(declare-fun l_25 () Inductive)
(declare-fun x11 () Inductive)
(declare-fun currentThread61 () Int)
(push)
(push)
; Assume: (= true (mem x11 l_15))
(assert (= true (mem x11 l_15)))
(check-sat)
(push)
; Assume: (= true (mem x11 l_25))
(assert (= true (mem x11 l_25)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_15 nil)
(assert (= l_15 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h53 () Inductive)
(declare-fun t53 () Inductive)
(push)
(push)
; Assume: (= l_15 (cons h53 t53))
(assert (= l_15 (cons h53 t53)))
(check-sat)
(push)
(push)
; Assume: (= h53 x11)
(assert (= h53 x11))
(check-sat)
(push)
(push)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem x11 (append t53 l_25)) (or (mem x11 t53) (mem x11 l_25)))
(assert (= (mem x11 (append t53 l_25)) (or (mem x11 t53) (mem x11 l_25))))
(check-sat)
; Query: (= false (distinct0 (append l_15 l_25)))
(push)
(assert (not (= false (distinct0 (append l_15 l_25)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h53 x11))
(assert (not (= h53 x11)))
(check-sat)
(push)
(push)
; Query: (= true (mem x11 t53))
(push)
(assert (not (= true (mem x11 t53))))
(check-sat)
(pop 1)
; Query: (= true (mem x11 l_25))
(push)
(assert (not (= true (mem x11 l_25))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (distinct0 (append t53 l_25)))
(assert (= false (distinct0 (append t53 l_25))))
(check-sat)
; Query: (= false (distinct0 (append l_15 l_25)))
(push)
(assert (not (= false (distinct0 (append l_15 l_25)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_16 () Inductive)
(declare-fun l_26 () Inductive)
(declare-fun el2 () Inductive)
(declare-fun currentThread62 () Int)
(push)
(push)
; Assume: (= true (mem el2 l_16))
(assert (= true (mem el2 l_16)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_16 nil)
(assert (= l_16 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h54 () Inductive)
(declare-fun t54 () Inductive)
(push)
(push)
; Assume: (= l_16 (cons h54 t54))
(assert (= l_16 (cons h54 t54)))
(check-sat)
(push)
(push)
; Assume: (not (= h54 el2))
(assert (not (= h54 el2)))
(check-sat)
(push)
; Query: (= true (mem el2 t54))
(push)
(assert (not (= true (mem el2 t54))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el2 (append t54 l_26)) (append (remove el2 t54) l_26))
(assert (= (remove el2 (append t54 l_26)) (append (remove el2 t54) l_26)))
(check-sat)
; Query: (= (remove el2 (append l_16 l_26)) (append (remove el2 l_16) l_26))
(push)
(assert
   (not (= (remove el2 (append l_16 l_26)) (append (remove el2 l_16) l_26))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h54 el2)))
(assert (not (not (= h54 el2))))
(check-sat)
(push)
; Query: (= (remove el2 (append l_16 l_26)) (append (remove el2 l_16) l_26))
(push)
(assert
   (not (= (remove el2 (append l_16 l_26)) (append (remove el2 l_16) l_26))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun ks () Inductive)
(declare-fun k3 () Inductive)
(declare-fun i7 () Int)
(declare-fun currentThread63 () Int)
(push)
(push)
; Assume: (= false (mem (some k3) ks))
(assert (= false (mem (some k3) ks)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= ks nil)
(assert (= ks nil))
(check-sat)
; Query: (= false (mem (some k3) (update i7 none ks)))
(push)
(assert (not (= false (mem (some k3) (update i7 none ks)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h55 () Inductive)
(declare-fun t55 () Inductive)
(push)
(push)
; Assume: (= ks (cons h55 t55))
(assert (= ks (cons h55 t55)))
(check-sat)
(push)
(push)
; Assume: (= i7 0)
(assert (= i7 0))
(check-sat)
(push)
(push)
; Query: (= false (mem (some k3) (update i7 none ks)))
(push)
(assert (not (= false (mem (some k3) (update i7 none ks)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= i7 0))
(assert (not (= i7 0)))
(check-sat)
(push)
(push)
; Query: (= false (mem (some k3) t55))
(push)
(assert (not (= false (mem (some k3) t55))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem (some k3) (update (- i7 1) none t55)))
(assert (= false (mem (some k3) (update (- i7 1) none t55))))
(check-sat)
; Query: (= false (mem (some k3) (update i7 none ks)))
(push)
(assert (not (= false (mem (some k3) (update i7 none ks)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_17 () Inductive)
(declare-fun l_27 () Inductive)
(declare-fun currentThread64 () Int)
(push)
(push)
; Assume: (= true (distinct0 (append l_17 l_27)))
(assert (= true (distinct0 (append l_17 l_27))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_17 nil)
(assert (= l_17 nil))
(check-sat)
; Query: (= true (distinct0 l_17))
(push)
(assert (not (= true (distinct0 l_17))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_27))
(push)
(assert (not (= true (distinct0 l_27))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_27 l_17))
(push)
(assert (not (= true (disjoint l_27 l_17))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h56 () Inductive)
(declare-fun t56 () Inductive)
(push)
(push)
; Assume: (= l_17 (cons h56 t56))
(assert (= l_17 (cons h56 t56)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h56 (append t56 l_27)) (or (mem h56 t56) (mem h56 l_27)))
(assert (= (mem h56 (append t56 l_27)) (or (mem h56 t56) (mem h56 l_27))))
(check-sat)
; Query: (= true (distinct0 (append t56 l_27)))
(push)
(assert (not (= true (distinct0 (append t56 l_27)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 t56))
(assert (= true (distinct0 t56)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_27))
(assert (= true (distinct0 l_27)))
(check-sat)
(push)
; Assume: (= true (disjoint l_27 t56))
(assert (= true (disjoint l_27 t56)))
(check-sat)
; Query: (= true (distinct0 l_17))
(push)
(assert (not (= true (distinct0 l_17))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_27))
(push)
(assert (not (= true (distinct0 l_27))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_27 l_17))
(push)
(assert (not (= true (disjoint l_27 l_17))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_18 () Inductive)
(declare-fun l_28 () Inductive)
(declare-fun x12 () Inductive)
(declare-fun currentThread65 () Int)
(push)
(push)
; Assume: (= true (disjoint l_18 l_28))
(assert (= true (disjoint l_18 l_28)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_28 nil)
(assert (= l_28 nil))
(check-sat)
(push)
(push)
; Assume: (mem x12 l_18)
(assert (mem x12 l_18))
(check-sat)
; Query: (not (mem x12 l_28))
(push)
(assert (not (not (mem x12 l_28))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem x12 l_18))
(assert (not (mem x12 l_18)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h57 () Inductive)
(declare-fun t57 () Inductive)
(push)
(push)
; Assume: (= l_28 (cons h57 t57))
(assert (= l_28 (cons h57 t57)))
(check-sat)
(push)
(push)
; Assume: (= h57 x12)
(assert (= h57 x12))
(check-sat)
(push)
(push)
; Query: (= false (mem x12 l_18))
(push)
(assert (not (= false (mem x12 l_18))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (mem x12 l_18)
(assert (mem x12 l_18))
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem x12 l_18))
(assert (not (mem x12 l_18)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h57 x12))
(assert (not (= h57 x12)))
(check-sat)
(push)
(push)
; Query: (= true (disjoint l_18 t57))
(push)
(assert (not (= true (disjoint l_18 t57))))
(check-sat)
(pop 1)
(push)
(push)
(push)
; Assume: (mem x12 l_18)
(assert (mem x12 l_18))
(check-sat)
(push)
; Assume: (not (mem x12 t57))
(assert (not (mem x12 t57)))
(check-sat)
(push)
(push)
; Assume: (mem x12 l_18)
(assert (mem x12 l_18))
(check-sat)
; Query: (not (mem x12 l_28))
(push)
(assert (not (not (mem x12 l_28))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem x12 l_18))
(assert (not (mem x12 l_18)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem x12 l_18))
(assert (not (mem x12 l_18)))
(check-sat)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
; Assume: (mem x12 l_18)
(assert (mem x12 l_18))
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem x12 l_18))
(assert (not (mem x12 l_18)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el3 () Inductive)
(declare-fun l_19 () Inductive)
(declare-fun l_29 () Inductive)
(declare-fun currentThread66 () Int)
(push)
(push)
; Assume: (= true (disjoint (cons el3 l_19) l_29))
(assert (= true (disjoint (cons el3 l_19) l_29)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_29 nil)
(assert (= l_29 nil))
(check-sat)
; Query: (= false (mem el3 l_29))
(push)
(assert (not (= false (mem el3 l_29))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_19 l_29))
(push)
(assert (not (= true (disjoint l_19 l_29))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h58 () Inductive)
(declare-fun t58 () Inductive)
(push)
(push)
; Assume: (= l_29 (cons h58 t58))
(assert (= l_29 (cons h58 t58)))
(check-sat)
; Query: (= true (disjoint (cons el3 l_19) t58))
(push)
(assert (not (= true (disjoint (cons el3 l_19) t58))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem el3 t58))
(assert (= false (mem el3 t58)))
(check-sat)
(push)
; Assume: (= true (disjoint l_19 t58))
(assert (= true (disjoint l_19 t58)))
(check-sat)
; Query: (= false (mem el3 l_29))
(push)
(assert (not (= false (mem el3 l_29))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_19 l_29))
(push)
(assert (not (= true (disjoint l_19 l_29))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_110 () Inductive)
(declare-fun l_210 () Inductive)
(declare-fun el4 () Inductive)
(declare-fun currentThread67 () Int)
(push)
(push)
; Assume: (= true (disjoint l_110 l_210))
(assert (= true (disjoint l_110 l_210)))
(check-sat)
(push)
; Assume: (= false (mem el4 l_210))
(assert (= false (mem el4 l_210)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_210 nil)
(assert (= l_210 nil))
(check-sat)
; Query: (= true (disjoint (cons el4 l_110) l_210))
(push)
(assert (not (= true (disjoint (cons el4 l_110) l_210))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h59 () Inductive)
(declare-fun t59 () Inductive)
(push)
(push)
; Assume: (= l_210 (cons h59 t59))
(assert (= l_210 (cons h59 t59)))
(check-sat)
; Query: (= true (disjoint l_110 t59))
(push)
(assert (not (= true (disjoint l_110 t59))))
(check-sat)
(pop 1)
; Query: (= false (mem el4 t59))
(push)
(assert (not (= false (mem el4 t59))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint (cons el4 l_110) t59))
(assert (= true (disjoint (cons el4 l_110) t59)))
(check-sat)
; Query: (= true (disjoint (cons el4 l_110) l_210))
(push)
(assert (not (= true (disjoint (cons el4 l_110) l_210))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_111 () Inductive)
(declare-fun l_211 () Inductive)
(declare-fun currentThread68 () Int)
(push)
(push)
; Assume: (= true (distinct0 l_111))
(assert (= true (distinct0 l_111)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_211))
(assert (= true (distinct0 l_211)))
(check-sat)
(push)
; Assume: (= true (disjoint l_111 l_211))
(assert (= true (disjoint l_111 l_211)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_111 nil)
(assert (= l_111 nil))
(check-sat)
; Query: (= true (distinct0 (append l_111 l_211)))
(push)
(assert (not (= true (distinct0 (append l_111 l_211)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h60 () Inductive)
(declare-fun t60 () Inductive)
(push)
(push)
; Assume: (= l_111 (cons h60 t60))
(assert (= l_111 (cons h60 t60)))
(check-sat)
; Query: (= true (disjoint (cons h60 t60) l_211))
(push)
(assert (not (= true (disjoint (cons h60 t60) l_211))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem h60 l_211))
(assert (= false (mem h60 l_211)))
(check-sat)
(push)
; Assume: (= true (disjoint t60 l_211))
(assert (= true (disjoint t60 l_211)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h60 (append t60 l_211)) (or (mem h60 t60) (mem h60 l_211)))
(assert (= (mem h60 (append t60 l_211)) (or (mem h60 t60) (mem h60 l_211))))
(check-sat)
; Query: (= true (distinct0 t60))
(push)
(assert (not (= true (distinct0 t60))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_211))
(push)
(assert (not (= true (distinct0 l_211))))
(check-sat)
(pop 1)
; Query: (= true (disjoint t60 l_211))
(push)
(assert (not (= true (disjoint t60 l_211))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 (append t60 l_211)))
(assert (= true (distinct0 (append t60 l_211))))
(check-sat)
; Query: (= true (distinct0 (append l_111 l_211)))
(push)
(assert (not (= true (distinct0 (append l_111 l_211)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_112 () Inductive)
(declare-fun l_212 () Inductive)
(declare-fun l_30 () Inductive)
(declare-fun currentThread69 () Int)
(push)
(push)
; Assume: (= true (disjoint (append l_112 l_212) l_30))
(assert (= true (disjoint (append l_112 l_212) l_30)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_30 nil)
(assert (= l_30 nil))
(check-sat)
; Query: (= true (disjoint l_112 l_30))
(push)
(assert (not (= true (disjoint l_112 l_30))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_212 l_30))
(push)
(assert (not (= true (disjoint l_212 l_30))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h61 () Inductive)
(declare-fun t61 () Inductive)
(push)
(push)
; Assume: (= l_30 (cons h61 t61))
(assert (= l_30 (cons h61 t61)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h61 (append l_112 l_212)) (or (mem h61 l_112) (mem h61 l_212)))
(assert
   (= (mem h61 (append l_112 l_212)) (or (mem h61 l_112) (mem h61 l_212))))
(check-sat)
; Query: (= true (disjoint (append l_112 l_212) t61))
(push)
(assert (not (= true (disjoint (append l_112 l_212) t61))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint l_112 t61))
(assert (= true (disjoint l_112 t61)))
(check-sat)
(push)
; Assume: (= true (disjoint l_212 t61))
(assert (= true (disjoint l_212 t61)))
(check-sat)
; Query: (= true (disjoint l_112 l_30))
(push)
(assert (not (= true (disjoint l_112 l_30))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_212 l_30))
(push)
(assert (not (= true (disjoint l_212 l_30))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_113 () Inductive)
(declare-fun l_213 () Inductive)
(declare-fun l_31 () Inductive)
(declare-fun l_4 () Inductive)
(declare-fun currentThread70 () Int)
(push)
(push)
; Assume: (= true (disjoint (append l_113 l_213) (append l_31 l_4)))
(assert (= true (disjoint (append l_113 l_213) (append l_31 l_4))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_31 nil)
(assert (= l_31 nil))
(check-sat)
; Query: (= true (disjoint (append l_113 l_213) l_4))
(push)
(assert (not (= true (disjoint (append l_113 l_213) l_4))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint l_113 l_4))
(assert (= true (disjoint l_113 l_4)))
(check-sat)
(push)
; Assume: (= true (disjoint l_213 l_4))
(assert (= true (disjoint l_213 l_4)))
(check-sat)
; Query: (= true (disjoint l_113 l_31))
(push)
(assert (not (= true (disjoint l_113 l_31))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_113 l_4))
(push)
(assert (not (= true (disjoint l_113 l_4))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_213 l_31))
(push)
(assert (not (= true (disjoint l_213 l_31))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_213 l_4))
(push)
(assert (not (= true (disjoint l_213 l_4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h62 () Inductive)
(declare-fun t62 () Inductive)
(push)
(push)
; Assume: (= l_31 (cons h62 t62))
(assert (= l_31 (cons h62 t62)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h62 (append l_113 l_213)) (or (mem h62 l_113) (mem h62 l_213)))
(assert
   (= (mem h62 (append l_113 l_213)) (or (mem h62 l_113) (mem h62 l_213))))
(check-sat)
; Query: (= true (disjoint (append l_113 l_213) (append t62 l_4)))
(push)
(assert (not (= true (disjoint (append l_113 l_213) (append t62 l_4)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint l_113 t62))
(assert (= true (disjoint l_113 t62)))
(check-sat)
(push)
; Assume: (= true (disjoint l_113 l_4))
(assert (= true (disjoint l_113 l_4)))
(check-sat)
(push)
; Assume: (= true (disjoint l_213 t62))
(assert (= true (disjoint l_213 t62)))
(check-sat)
(push)
; Assume: (= true (disjoint l_213 l_4))
(assert (= true (disjoint l_213 l_4)))
(check-sat)
; Query: (= true (disjoint l_113 l_31))
(push)
(assert (not (= true (disjoint l_113 l_31))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_113 l_4))
(push)
(assert (not (= true (disjoint l_113 l_4))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_213 l_31))
(push)
(assert (not (= true (disjoint l_213 l_31))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_213 l_4))
(push)
(assert (not (= true (disjoint l_213 l_4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_114 () Inductive)
(declare-fun l_214 () Inductive)
(declare-fun currentThread71 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_114 nil)
(assert (= l_114 nil))
(check-sat)
; Query: (= true (= (disjoint l_114 l_214) (disjoint l_214 l_114)))
(push)
(assert (not (= true (= (disjoint l_114 l_214) (disjoint l_214 l_114)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h63 () Inductive)
(declare-fun t63 () Inductive)
(push)
(push)
; Assume: (= l_114 (cons h63 t63))
(assert (= l_114 (cons h63 t63)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (= (disjoint t63 l_214) (disjoint l_214 t63)))
(assert (= true (= (disjoint t63 l_214) (disjoint l_214 t63))))
(check-sat)
(push)
(push)
; Assume: (disjoint l_114 l_214)
(assert (disjoint l_114 l_214))
(check-sat)
(push)
(push)
; Query: (= true (disjoint (cons h63 t63) l_214))
(push)
(assert (not (= true (disjoint (cons h63 t63) l_214))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem h63 l_214))
(assert (= false (mem h63 l_214)))
(check-sat)
(push)
; Assume: (= true (disjoint t63 l_214))
(assert (= true (disjoint t63 l_214)))
(check-sat)
; Query: (= false (mem h63 l_214))
(push)
(assert (not (= false (mem h63 l_214))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_214 t63))
(push)
(assert (not (= true (disjoint l_214 t63))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (disjoint l_214 l_114)
(assert (disjoint l_214 l_114))
(check-sat)
(push)
(push)
; Query: (= false (mem h63 l_214))
(push)
(assert (not (= false (mem h63 l_214))))
(check-sat)
(pop 1)
; Query: (= true (disjoint t63 l_214))
(push)
(assert (not (= true (disjoint t63 l_214))))
(check-sat)
(pop 1)
; Query: (= true (disjoint t63 l_214))
(push)
(assert (not (= true (disjoint t63 l_214))))
(check-sat)
(pop 1)
; Query: (= false (mem h63 l_214))
(push)
(assert (not (= false (mem h63 l_214))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint (cons h63 t63) l_214))
(assert (= true (disjoint (cons h63 t63) l_214)))
(check-sat)
; Query: (= true (= (disjoint l_114 l_214) (disjoint l_214 l_114)))
(push)
(assert (not (= true (= (disjoint l_114 l_214) (disjoint l_214 l_114)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (disjoint l_214 l_114))
(assert (not (disjoint l_214 l_114)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (disjoint l_114 l_214))
(assert (not (disjoint l_114 l_214)))
(check-sat)
(push)
(push)
(push)
; Assume: (disjoint l_214 l_114)
(assert (disjoint l_214 l_114))
(check-sat)
(push)
(push)
; Query: (= false (mem h63 l_214))
(push)
(assert (not (= false (mem h63 l_214))))
(check-sat)
(pop 1)
; Query: (= true (disjoint t63 l_214))
(push)
(assert (not (= true (disjoint t63 l_214))))
(check-sat)
(pop 1)
; Query: (= true (disjoint t63 l_214))
(push)
(assert (not (= true (disjoint t63 l_214))))
(check-sat)
(pop 1)
; Query: (= false (mem h63 l_214))
(push)
(assert (not (= false (mem h63 l_214))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint (cons h63 t63) l_214))
(assert (= true (disjoint (cons h63 t63) l_214)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (disjoint l_214 l_114))
(assert (not (disjoint l_214 l_114)))
(check-sat)
(push)
; Query: (= true (= (disjoint l_114 l_214) (disjoint l_214 l_114)))
(push)
(assert (not (= true (= (disjoint l_114 l_214) (disjoint l_214 l_114)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_115 () Inductive)
(declare-fun l_215 () Inductive)
(declare-fun l_32 () Inductive)
(declare-fun currentThread72 () Int)
(push)
(push)
; Assume: (= true (disjoint l_115 l_32))
(assert (= true (disjoint l_115 l_32)))
(check-sat)
(push)
; Assume: (= true (disjoint l_215 l_32))
(assert (= true (disjoint l_215 l_32)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_32 nil)
(assert (= l_32 nil))
(check-sat)
; Query: (= true (disjoint (append l_115 l_215) l_32))
(push)
(assert (not (= true (disjoint (append l_115 l_215) l_32))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h64 () Inductive)
(declare-fun t64 () Inductive)
(push)
(push)
; Assume: (= l_32 (cons h64 t64))
(assert (= l_32 (cons h64 t64)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h64 (append l_115 l_215)) (or (mem h64 l_115) (mem h64 l_215)))
(assert
   (= (mem h64 (append l_115 l_215)) (or (mem h64 l_115) (mem h64 l_215))))
(check-sat)
; Query: (= true (disjoint l_115 t64))
(push)
(assert (not (= true (disjoint l_115 t64))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_215 t64))
(push)
(assert (not (= true (disjoint l_215 t64))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint (append l_115 l_215) t64))
(assert (= true (disjoint (append l_115 l_215) t64)))
(check-sat)
; Query: (= true (disjoint (append l_115 l_215) l_32))
(push)
(assert (not (= true (disjoint (append l_115 l_215) l_32))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_116 () Inductive)
(declare-fun l_216 () Inductive)
(declare-fun l_33 () Inductive)
(declare-fun l_40 () Inductive)
(declare-fun currentThread73 () Int)
(push)
(push)
; Assume: (= true (disjoint l_116 l_33))
(assert (= true (disjoint l_116 l_33)))
(check-sat)
(push)
; Assume: (= true (disjoint l_116 l_40))
(assert (= true (disjoint l_116 l_40)))
(check-sat)
(push)
; Assume: (= true (disjoint l_216 l_33))
(assert (= true (disjoint l_216 l_33)))
(check-sat)
(push)
; Assume: (= true (disjoint l_216 l_40))
(assert (= true (disjoint l_216 l_40)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_33 nil)
(assert (= l_33 nil))
(check-sat)
; Query: (= true (disjoint l_116 l_40))
(push)
(assert (not (= true (disjoint l_116 l_40))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_216 l_40))
(push)
(assert (not (= true (disjoint l_216 l_40))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint (append l_116 l_216) l_40))
(assert (= true (disjoint (append l_116 l_216) l_40)))
(check-sat)
; Query: (= true (disjoint (append l_116 l_216) (append l_33 l_40)))
(push)
(assert (not (= true (disjoint (append l_116 l_216) (append l_33 l_40)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h65 () Inductive)
(declare-fun t65 () Inductive)
(push)
(push)
; Assume: (= l_33 (cons h65 t65))
(assert (= l_33 (cons h65 t65)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h65 (append l_116 l_216)) (or (mem h65 l_116) (mem h65 l_216)))
(assert
   (= (mem h65 (append l_116 l_216)) (or (mem h65 l_116) (mem h65 l_216))))
(check-sat)
; Query: (= true (disjoint l_116 t65))
(push)
(assert (not (= true (disjoint l_116 t65))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_116 l_40))
(push)
(assert (not (= true (disjoint l_116 l_40))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_216 t65))
(push)
(assert (not (= true (disjoint l_216 t65))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_216 l_40))
(push)
(assert (not (= true (disjoint l_216 l_40))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint (append l_116 l_216) (append t65 l_40)))
(assert (= true (disjoint (append l_116 l_216) (append t65 l_40))))
(check-sat)
; Query: (= true (disjoint (append l_116 l_216) (append l_33 l_40)))
(push)
(assert (not (= true (disjoint (append l_116 l_216) (append l_33 l_40)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst23 () Inductive)
(declare-fun f8 () Inductive)
(declare-fun currentThread74 () Int)
(push)
(push)
; Assume: (= true (distinct0 (map0 f8 lst23)))
(assert (= true (distinct0 (map0 f8 lst23))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst23 nil)
(assert (= lst23 nil))
(check-sat)
; Query: (= true (distinct0 lst23))
(push)
(assert (not (= true (distinct0 lst23))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h66 () Inductive)
(declare-fun t66 () Inductive)
(push)
(push)
; Assume: (= lst23 (cons h66 t66))
(assert (= lst23 (cons h66 t66)))
(check-sat)
(push)
(push)
; Assume: (mem h66 t66)
(assert (mem h66 t66))
(check-sat)
(push)
(push)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem h66 t66) true)
(push)
(assert (not (= (mem h66 t66) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f8 h66) (map0 f8 t66)) true)
(assert (= (mem (_@ f8 h66) (map0 f8 t66)) true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem h66 t66))
(assert (not (mem h66 t66)))
(check-sat)
(push)
; Query: (= true (distinct0 (map0 f8 t66)))
(push)
(assert (not (= true (distinct0 (map0 f8 t66)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 t66))
(assert (= true (distinct0 t66)))
(check-sat)
; Query: (= true (distinct0 lst23))
(push)
(assert (not (= true (distinct0 lst23))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f9 () Inductive)
(declare-fun x13 () Inductive)
(declare-fun l18 () Inductive)
(declare-fun currentThread75 () Int)
(push)
(push)
; Assume: (= true (distinct0 (map0 f9 l18)))
(assert (= true (distinct0 (map0 f9 l18))))
(check-sat)
(push)
; Assume: (= true (mem x13 l18))
(assert (= true (mem x13 l18)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l18 nil)
(assert (= l18 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h67 () Inductive)
(declare-fun t67 () Inductive)
(push)
(push)
; Assume: (= l18 (cons h67 t67))
(assert (= l18 (cons h67 t67)))
(check-sat)
(push)
(push)
; Assume: (= (_@ f9 h67) (_@ f9 x13))
(assert (= (_@ f9 h67) (_@ f9 x13)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (not (= h67 x13))
(assert (not (= h67 x13)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem x13 t67) true)
(push)
(assert (not (= (mem x13 t67) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f9 x13) (map0 f9 t67)) true)
(assert (= (mem (_@ f9 x13) (map0 f9 t67)) true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h67 x13)))
(assert (not (not (= h67 x13))))
(check-sat)
(push)
; Query: (= h67 x13)
(push)
(assert (not (= h67 x13)))
(check-sat)
(pop 1)
; Query: (= (map0 f9 (remove x13 l18)) (remove (_@ f9 x13) (map0 f9 l18)))
(push)
(assert
   (not (= (map0 f9 (remove x13 l18)) (remove (_@ f9 x13) (map0 f9 l18)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (_@ f9 h67) (_@ f9 x13)))
(assert (not (= (_@ f9 h67) (_@ f9 x13))))
(check-sat)
(push)
(push)
; Query: (= true (distinct0 (map0 f9 t67)))
(push)
(assert (not (= true (distinct0 (map0 f9 t67)))))
(check-sat)
(pop 1)
; Query: (= true (mem x13 t67))
(push)
(assert (not (= true (mem x13 t67))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (map0 f9 (remove x13 t67)) (remove (_@ f9 x13) (map0 f9 t67)))
(assert (= (map0 f9 (remove x13 t67)) (remove (_@ f9 x13) (map0 f9 t67))))
(check-sat)
; Query: (= (map0 f9 (remove x13 l18)) (remove (_@ f9 x13) (map0 f9 l18)))
(push)
(assert
   (not (= (map0 f9 (remove x13 l18)) (remove (_@ f9 x13) (map0 f9 l18)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x14 () Inductive)
(declare-fun l_117 () Inductive)
(declare-fun l_217 () Inductive)
(declare-fun currentThread76 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_117 nil)
(assert (= l_117 nil))
(check-sat)
; Query: (= (remove x14 (append l_117 l_217)) (ite (mem x14 l_117) (append (remove x14 l_117) l_217) (append l_117 (remove x14 l_217))))
(push)
(assert
   (not
      (= (remove x14 (append l_117 l_217))
         (ite (mem x14 l_117) (append (remove x14 l_117) l_217)
            (append l_117 (remove x14 l_217))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h68 () Inductive)
(declare-fun t68 () Inductive)
(push)
(push)
; Assume: (= l_117 (cons h68 t68))
(assert (= l_117 (cons h68 t68)))
(check-sat)
(push)
(push)
; Assume: (not (= h68 x14))
(assert (not (= h68 x14)))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove x14 (append t68 l_217)) (ite (mem x14 t68) (append (remove x14 t68) l_217) (append t68 (remove x14 l_217))))
(assert
   (= (remove x14 (append t68 l_217))
      (ite (mem x14 t68) (append (remove x14 t68) l_217)
         (append t68 (remove x14 l_217)))))
(check-sat)
; Query: (= (remove x14 (append l_117 l_217)) (ite (mem x14 l_117) (append (remove x14 l_117) l_217) (append l_117 (remove x14 l_217))))
(push)
(assert
   (not
      (= (remove x14 (append l_117 l_217))
         (ite (mem x14 l_117) (append (remove x14 l_117) l_217)
            (append l_117 (remove x14 l_217))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h68 x14)))
(assert (not (not (= h68 x14))))
(check-sat)
(push)
; Query: (= (remove x14 (append l_117 l_217)) (ite (mem x14 l_117) (append (remove x14 l_117) l_217) (append l_117 (remove x14 l_217))))
(push)
(assert
   (not
      (= (remove x14 (append l_117 l_217))
         (ite (mem x14 l_117) (append (remove x14 l_117) l_217)
            (append l_117 (remove x14 l_217))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f10 () Inductive)
(declare-fun l19 () Inductive)
(declare-fun x_10 () Inductive)
(declare-fun x_20 () Inductive)
(declare-fun currentThread77 () Int)
(push)
(push)
; Assume: (= false (mem (_@ f10 x_10) (remove (_@ f10 x_10) (map0 f10 l19))))
(assert (= false (mem (_@ f10 x_10) (remove (_@ f10 x_10) (map0 f10 l19)))))
(check-sat)
(push)
; Assume: (= true (mem x_10 l19))
(assert (= true (mem x_10 l19)))
(check-sat)
(push)
; Assume: (= true (mem x_20 l19))
(assert (= true (mem x_20 l19)))
(check-sat)
(push)
; Assume: (= (_@ f10 x_10) (_@ f10 x_20))
(assert (= (_@ f10 x_10) (_@ f10 x_20)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l19 nil)
(assert (= l19 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h69 () Inductive)
(declare-fun t69 () Inductive)
(push)
(push)
; Assume: (= l19 (cons h69 t69))
(assert (= l19 (cons h69 t69)))
(check-sat)
(push)
(push)
; Assume: (= h69 x_10)
(assert (= h69 x_10))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (not (= h69 x_20))
(assert (not (= h69 x_20)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem x_20 t69) true)
(push)
(assert (not (= (mem x_20 t69) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f10 x_20) (map0 f10 t69)) true)
(assert (= (mem (_@ f10 x_20) (map0 f10 t69)) true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h69 x_20)))
(assert (not (not (= h69 x_20))))
(check-sat)
(push)
; Query: (= h69 x_20)
(push)
(assert (not (= h69 x_20)))
(check-sat)
(pop 1)
; Query: (= x_10 x_20)
(push)
(assert (not (= x_10 x_20)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h69 x_10))
(assert (not (= h69 x_10)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= h69 x_20)
(assert (= h69 x_20))
(check-sat)
(push)
(push)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem x_10 t69) true)
(push)
(assert (not (= (mem x_10 t69) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f10 x_10) (map0 f10 t69)) true)
(assert (= (mem (_@ f10 x_10) (map0 f10 t69)) true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h69 x_20))
(assert (not (= h69 x_20)))
(check-sat)
(push)
; Query: (not (= h69 x_20))
(push)
(assert (not (not (= h69 x_20))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (_@ f10 h69) (_@ f10 x_10))
(assert (= (_@ f10 h69) (_@ f10 x_10)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem x_10 t69) true)
(push)
(assert (not (= (mem x_10 t69) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f10 x_10) (map0 f10 t69)) true)
(assert (= (mem (_@ f10 x_10) (map0 f10 t69)) true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (_@ f10 h69) (_@ f10 x_10)))
(assert (not (= (_@ f10 h69) (_@ f10 x_10))))
(check-sat)
(push)
; Query: (= false (mem (_@ f10 x_10) (remove (_@ f10 x_10) (map0 f10 t69))))
(push)
(assert
   (not (= false (mem (_@ f10 x_10) (remove (_@ f10 x_10) (map0 f10 t69))))))
(check-sat)
(pop 1)
; Query: (= true (mem x_10 t69))
(push)
(assert (not (= true (mem x_10 t69))))
(check-sat)
(pop 1)
; Query: (= true (mem x_20 t69))
(push)
(assert (not (= true (mem x_20 t69))))
(check-sat)
(pop 1)
; Query: (= (_@ f10 x_10) (_@ f10 x_20))
(push)
(assert (not (= (_@ f10 x_10) (_@ f10 x_20))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= x_10 x_20)
(assert (= x_10 x_20))
(check-sat)
; Query: (= x_10 x_20)
(push)
(assert (not (= x_10 x_20)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f11 () Inductive)
(declare-fun l20 () Inductive)
(declare-fun x_11 () Inductive)
(declare-fun x_21 () Inductive)
(declare-fun currentThread78 () Int)
(push)
(push)
; Assume: (= true (distinct0 (map0 f11 l20)))
(assert (= true (distinct0 (map0 f11 l20))))
(check-sat)
(push)
; Assume: (= true (mem x_11 l20))
(assert (= true (mem x_11 l20)))
(check-sat)
(push)
; Assume: (= true (mem x_21 l20))
(assert (= true (mem x_21 l20)))
(check-sat)
(push)
; Assume: (= (_@ f11 x_11) (_@ f11 x_21))
(assert (= (_@ f11 x_11) (_@ f11 x_21)))
(check-sat)
(push)
(push)
; Query: (= true (distinct0 (map0 f11 l20)))
(push)
(assert (not (= true (distinct0 (map0 f11 l20)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem (_@ f11 x_11) (remove (_@ f11 x_11) (map0 f11 l20))))
(assert (= false (mem (_@ f11 x_11) (remove (_@ f11 x_11) (map0 f11 l20)))))
(check-sat)
; Query: (= false (mem (_@ f11 x_11) (remove (_@ f11 x_11) (map0 f11 l20))))
(push)
(assert
   (not (= false (mem (_@ f11 x_11) (remove (_@ f11 x_11) (map0 f11 l20))))))
(check-sat)
(pop 1)
; Query: (= true (mem x_11 l20))
(push)
(assert (not (= true (mem x_11 l20))))
(check-sat)
(pop 1)
; Query: (= true (mem x_21 l20))
(push)
(assert (not (= true (mem x_21 l20))))
(check-sat)
(pop 1)
; Query: (= (_@ f11 x_11) (_@ f11 x_21))
(push)
(assert (not (= (_@ f11 x_11) (_@ f11 x_21))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= x_11 x_21)
(assert (= x_11 x_21))
(check-sat)
; Query: (= x_11 x_21)
(push)
(assert (not (= x_11 x_21)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f_12 () Inductive)
(declare-fun f_22 () Inductive)
(declare-fun l21 () Inductive)
(declare-fun currentThread79 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l21 nil)
(assert (= l21 nil))
(check-sat)
; Query: (= (filter f_12 (filter f_22 l21)) (filter f_22 (filter f_12 l21)))
(push)
(assert
   (not (= (filter f_12 (filter f_22 l21)) (filter f_22 (filter f_12 l21)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h70 () Inductive)
(declare-fun t70 () Inductive)
(push)
(push)
; Assume: (= l21 (cons h70 t70))
(assert (= l21 (cons h70 t70)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (filter f_12 (filter f_22 t70)) (filter f_22 (filter f_12 t70)))
(assert (= (filter f_12 (filter f_22 t70)) (filter f_22 (filter f_12 t70))))
(check-sat)
; Query: (= (filter f_12 (filter f_22 l21)) (filter f_22 (filter f_12 l21)))
(push)
(assert
   (not (= (filter f_12 (filter f_22 l21)) (filter f_22 (filter f_12 l21)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el5 () Inductive)
(declare-fun l22 () Inductive)
(declare-fun f12 () Inductive)
(declare-fun currentThread80 () Int)
(push)
(push)
; Assume: (= true (mem el5 l22))
(assert (= true (mem el5 l22)))
(check-sat)
(push)
; Assume: (= true (unbox_bool (_@ f12 el5)))
(assert (= true (unbox_bool (_@ f12 el5))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l22 nil)
(assert (= l22 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h71 () Inductive)
(declare-fun t71 () Inductive)
(push)
(push)
; Assume: (= l22 (cons h71 t71))
(assert (= l22 (cons h71 t71)))
(check-sat)
(push)
(push)
; Assume: (not (= h71 el5))
(assert (not (= h71 el5)))
(check-sat)
(push)
(push)
; Query: (= true (mem el5 t71))
(push)
(assert (not (= true (mem el5 t71))))
(check-sat)
(pop 1)
; Query: (= true (unbox_bool (_@ f12 el5)))
(push)
(assert (not (= true (unbox_bool (_@ f12 el5)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem el5 (filter f12 t71)))
(assert (= true (mem el5 (filter f12 t71))))
(check-sat)
; Query: (= true (mem el5 (filter f12 l22)))
(push)
(assert (not (= true (mem el5 (filter f12 l22)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h71 el5)))
(assert (not (not (= h71 el5))))
(check-sat)
(push)
; Query: (= true (mem el5 (filter f12 l22)))
(push)
(assert (not (= true (mem el5 (filter f12 l22)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el6 () Inductive)
(declare-fun i8 () Int)
(declare-fun l23 () Inductive)
(declare-fun currentThread81 () Int)
(push)
(push)
; Assume: (<= 0 i8)
(assert (<= 0 i8))
(check-sat)
(push)
; Assume: (< i8 (length l23))
(assert (< i8 (length l23)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l23 nil)
(assert (= l23 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h72 () Inductive)
(declare-fun t72 () Inductive)
(push)
(push)
; Assume: (= l23 (cons h72 t72))
(assert (= l23 (cons h72 t72)))
(check-sat)
(push)
(push)
; Assume: (not (= i8 0))
(assert (not (= i8 0)))
(check-sat)
(push)
; Query: (<= 0 (- i8 1))
(push)
(assert (not (<= 0 (- i8 1))))
(check-sat)
(pop 1)
; Query: (< (- i8 1) (length t72))
(push)
(assert (not (< (- i8 1) (length t72))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem el6 (update (- i8 1) el6 t72)))
(assert (= true (mem el6 (update (- i8 1) el6 t72))))
(check-sat)
; Query: (= true (mem el6 (update i8 el6 l23)))
(push)
(assert (not (= true (mem el6 (update i8 el6 l23)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= i8 0)))
(assert (not (not (= i8 0))))
(check-sat)
(push)
; Query: (= true (mem el6 (update i8 el6 l23)))
(push)
(assert (not (= true (mem el6 (update i8 el6 l23)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el7 () Inductive)
(declare-fun l24 () Inductive)
(declare-fun f13 () Inductive)
(declare-fun currentThread82 () Int)
(push)
(push)
; Assume: (= false (unbox_bool (_@ f13 el7)))
(assert (= false (unbox_bool (_@ f13 el7))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l24 nil)
(assert (= l24 nil))
(check-sat)
; Query: (= false (mem el7 (filter f13 l24)))
(push)
(assert (not (= false (mem el7 (filter f13 l24)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h73 () Inductive)
(declare-fun t73 () Inductive)
(push)
(push)
; Assume: (= l24 (cons h73 t73))
(assert (= l24 (cons h73 t73)))
(check-sat)
; Query: (= false (unbox_bool (_@ f13 el7)))
(push)
(assert (not (= false (unbox_bool (_@ f13 el7)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem el7 (filter f13 t73)))
(assert (= false (mem el7 (filter f13 t73))))
(check-sat)
; Query: (= false (mem el7 (filter f13 l24)))
(push)
(assert (not (= false (mem el7 (filter f13 l24)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f14 () Inductive)
(declare-fun el8 () Inductive)
(declare-fun l25 () Inductive)
(declare-fun currentThread83 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l25 nil)
(assert (= l25 nil))
(check-sat)
; Query: (= (remove el8 (filter f14 l25)) (filter f14 (remove el8 l25)))
(push)
(assert
   (not (= (remove el8 (filter f14 l25)) (filter f14 (remove el8 l25)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h74 () Inductive)
(declare-fun t74 () Inductive)
(push)
(push)
; Assume: (= l25 (cons h74 t74))
(assert (= l25 (cons h74 t74)))
(check-sat)
(push)
(push)
; Assume: (not (= h74 el8))
(assert (not (= h74 el8)))
(check-sat)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el8 (filter f14 t74)) (filter f14 (remove el8 t74)))
(assert (= (remove el8 (filter f14 t74)) (filter f14 (remove el8 t74))))
(check-sat)
; Query: (= (remove el8 (filter f14 l25)) (filter f14 (remove el8 l25)))
(push)
(assert
   (not (= (remove el8 (filter f14 l25)) (filter f14 (remove el8 l25)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h74 el8)))
(assert (not (not (= h74 el8))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (not (unbox_bool (_@ f14 el8)))
(assert (not (unbox_bool (_@ f14 el8))))
(check-sat)
(push)
(push)
; Query: (= false (unbox_bool (_@ f14 el8)))
(push)
(assert (not (= false (unbox_bool (_@ f14 el8)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem el8 (filter f14 t74)))
(assert (= false (mem el8 (filter f14 t74))))
(check-sat)
; Query: (= false (mem el8 (filter f14 t74)))
(push)
(assert (not (= false (mem el8 (filter f14 t74)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el8 (filter f14 t74)) (filter f14 t74))
(assert (= (remove el8 (filter f14 t74)) (filter f14 t74)))
(check-sat)
; Query: (= (remove el8 (filter f14 l25)) (filter f14 (remove el8 l25)))
(push)
(assert
   (not (= (remove el8 (filter f14 l25)) (filter f14 (remove el8 l25)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (unbox_bool (_@ f14 el8))))
(assert (not (not (unbox_bool (_@ f14 el8)))))
(check-sat)
(push)
; Query: (= (remove el8 (filter f14 l25)) (filter f14 (remove el8 l25)))
(push)
(assert
   (not (= (remove el8 (filter f14 l25)) (filter f14 (remove el8 l25)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el9 () Inductive)
(declare-fun l26 () Inductive)
(declare-fun currentThread84 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l26 nil)
(assert (= l26 nil))
(check-sat)
; Query: (<= 0 (index_of el9 l26))
(push)
(assert (not (<= 0 (index_of el9 l26))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h75 () Inductive)
(declare-fun t75 () Inductive)
(push)
(push)
; Assume: (= l26 (cons h75 t75))
(assert (= l26 (cons h75 t75)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= 0 (index_of el9 t75))
(assert (<= 0 (index_of el9 t75)))
(check-sat)
; Query: (<= 0 (index_of el9 l26))
(push)
(assert (not (<= 0 (index_of el9 l26))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun i9 () Int)
(declare-fun el10 () Inductive)
(declare-fun l27 () Inductive)
(declare-fun currentThread85 () Int)
(push)
(push)
; Assume: (<= 0 i9)
(assert (<= 0 i9))
(check-sat)
(push)
; Assume: (= true (mem el10 l27))
(assert (= true (mem el10 l27)))
(check-sat)
(push)
; Assume: (not (= (index_of el10 l27) i9))
(assert (not (= (index_of el10 l27) i9)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l27 nil)
(assert (= l27 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h76 () Inductive)
(declare-fun t76 () Inductive)
(push)
(push)
; Assume: (= l27 (cons h76 t76))
(assert (= l27 (cons h76 t76)))
(check-sat)
(push)
(push)
; Assume: (not (= i9 0))
(assert (not (= i9 0)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (not (= h76 el10))
(assert (not (= h76 el10)))
(check-sat)
(push)
(push)
; Query: (<= 0 (- i9 1))
(push)
(assert (not (<= 0 (- i9 1))))
(check-sat)
(pop 1)
; Query: (= true (mem el10 t76))
(push)
(assert (not (= true (mem el10 t76))))
(check-sat)
(pop 1)
; Query: (not (= (index_of el10 t76) (- i9 1)))
(push)
(assert (not (not (= (index_of el10 t76) (- i9 1)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (nth (- i9 1) t76) (ite (< (index_of el10 t76) (- i9 1)) (nth (- (- i9 1) 1) (remove el10 t76)) (nth (- i9 1) (remove el10 t76))))
(assert
   (= (nth (- i9 1) t76)
      (ite (< (index_of el10 t76) (- i9 1))
         (nth (- (- i9 1) 1) (remove el10 t76))
         (nth (- i9 1) (remove el10 t76)))))
(check-sat)
(push)
(push)
; Assume: (< (index_of el10 l27) i9)
(assert (< (index_of el10 l27) i9))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= 0 (index_of el10 t76))
(assert (<= 0 (index_of el10 t76)))
(check-sat)
; Query: (= (nth i9 l27) (ite (< (index_of el10 l27) i9) (nth (- i9 1) (remove el10 l27)) (nth i9 (remove el10 l27))))
(push)
(assert
   (not
      (= (nth i9 l27)
         (ite (< (index_of el10 l27) i9) (nth (- i9 1) (remove el10 l27))
            (nth i9 (remove el10 l27))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (< (index_of el10 l27) i9))
(assert (not (< (index_of el10 l27) i9)))
(check-sat)
(push)
; Query: (= (nth i9 l27) (ite (< (index_of el10 l27) i9) (nth (- i9 1) (remove el10 l27)) (nth i9 (remove el10 l27))))
(push)
(assert
   (not
      (= (nth i9 l27)
         (ite (< (index_of el10 l27) i9) (nth (- i9 1) (remove el10 l27))
            (nth i9 (remove el10 l27))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h76 el10)))
(assert (not (not (= h76 el10))))
(check-sat)
(push)
; Query: (= (nth i9 l27) (ite (< (index_of el10 l27) i9) (nth (- i9 1) (remove el10 l27)) (nth i9 (remove el10 l27))))
(push)
(assert
   (not
      (= (nth i9 l27)
         (ite (< (index_of el10 l27) i9) (nth (- i9 1) (remove el10 l27))
            (nth i9 (remove el10 l27))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= i9 0)))
(assert (not (not (= i9 0))))
(check-sat)
(push)
; Query: (= (nth i9 l27) (ite (< (index_of el10 l27) i9) (nth (- i9 1) (remove el10 l27)) (nth i9 (remove el10 l27))))
(push)
(assert
   (not
      (= (nth i9 l27)
         (ite (< (index_of el10 l27) i9) (nth (- i9 1) (remove el10 l27))
            (nth i9 (remove el10 l27))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun i10 () Int)
(declare-fun el_1 () Inductive)
(declare-fun el_2 () Inductive)
(declare-fun l28 () Inductive)
(declare-fun currentThread86 () Int)
(push)
(push)
; Assume: (<= 0 i10)
(assert (<= 0 i10))
(check-sat)
(push)
; Assume: (not (= el_1 el_2))
(assert (not (= el_1 el_2)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l28 nil)
(assert (= l28 nil))
(check-sat)
(push)
(push)
; Assume: (<= (index_of el_2 l28) i10)
(assert (<= (index_of el_2 l28) i10))
(check-sat)
; Query: (= (update i10 el_1 (remove el_2 l28)) (remove el_2 (update (+ i10 1) el_1 l28)))
(push)
(assert
   (not
      (= (update i10 el_1 (remove el_2 l28))
         (remove el_2 (update (+ i10 1) el_1 l28)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= (index_of el_2 l28) i10))
(assert (not (<= (index_of el_2 l28) i10)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h77 () Inductive)
(declare-fun t77 () Inductive)
(push)
(push)
; Assume: (= l28 (cons h77 t77))
(assert (= l28 (cons h77 t77)))
(check-sat)
(push)
(push)
; Assume: (not (= i10 0))
(assert (not (= i10 0)))
(check-sat)
(push)
(push)
; Query: (<= 0 (- i10 1))
(push)
(assert (not (<= 0 (- i10 1))))
(check-sat)
(pop 1)
; Query: (not (= el_1 el_2))
(push)
(assert (not (not (= el_1 el_2))))
(check-sat)
(pop 1)
(push)
(push)
(push)
; Assume: (<= (index_of el_2 t77) (- i10 1))
(assert (<= (index_of el_2 t77) (- i10 1)))
(check-sat)
(push)
; Assume: (= (update (- i10 1) el_1 (remove el_2 t77)) (remove el_2 (update (+ (- i10 1) 1) el_1 t77)))
(assert
   (= (update (- i10 1) el_1 (remove el_2 t77))
      (remove el_2 (update (+ (- i10 1) 1) el_1 t77))))
(check-sat)
(push)
(push)
; Assume: (<= (index_of el_2 l28) i10)
(assert (<= (index_of el_2 l28) i10))
(check-sat)
; Query: (= (update i10 el_1 (remove el_2 l28)) (remove el_2 (update (+ i10 1) el_1 l28)))
(push)
(assert
   (not
      (= (update i10 el_1 (remove el_2 l28))
         (remove el_2 (update (+ i10 1) el_1 l28)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= (index_of el_2 l28) i10))
(assert (not (<= (index_of el_2 l28) i10)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= (index_of el_2 t77) (- i10 1)))
(assert (not (<= (index_of el_2 t77) (- i10 1))))
(check-sat)
(push)
; Assume: (= (update (- i10 1) el_1 (remove el_2 t77)) (remove el_2 (update (- i10 1) el_1 t77)))
(assert
   (= (update (- i10 1) el_1 (remove el_2 t77))
      (remove el_2 (update (- i10 1) el_1 t77))))
(check-sat)
(push)
(push)
; Assume: (<= (index_of el_2 l28) i10)
(assert (<= (index_of el_2 l28) i10))
(check-sat)
; Query: (= (update i10 el_1 (remove el_2 l28)) (remove el_2 (update (+ i10 1) el_1 l28)))
(push)
(assert
   (not
      (= (update i10 el_1 (remove el_2 l28))
         (remove el_2 (update (+ i10 1) el_1 l28)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= (index_of el_2 l28) i10))
(assert (not (<= (index_of el_2 l28) i10)))
(check-sat)
; Query: (= (update i10 el_1 (remove el_2 l28)) (remove el_2 (update i10 el_1 l28)))
(push)
(assert
   (not
      (= (update i10 el_1 (remove el_2 l28))
         (remove el_2 (update i10 el_1 l28)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= i10 0)))
(assert (not (not (= i10 0))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (not (= h77 el_2))
(assert (not (= h77 el_2)))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= 0 (index_of el_2 t77))
(assert (<= 0 (index_of el_2 t77)))
(check-sat)
(push)
(push)
; Assume: (<= (index_of el_2 l28) i10)
(assert (<= (index_of el_2 l28) i10))
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= (index_of el_2 l28) i10))
(assert (not (<= (index_of el_2 l28) i10)))
(check-sat)
; Query: (= (update i10 el_1 (remove el_2 l28)) (remove el_2 (update i10 el_1 l28)))
(push)
(assert
   (not
      (= (update i10 el_1 (remove el_2 l28))
         (remove el_2 (update i10 el_1 l28)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h77 el_2)))
(assert (not (not (= h77 el_2))))
(check-sat)
(push)
(push)
(push)
; Assume: (<= (index_of el_2 l28) i10)
(assert (<= (index_of el_2 l28) i10))
(check-sat)
; Query: (= (update i10 el_1 (remove el_2 l28)) (remove el_2 (update (+ i10 1) el_1 l28)))
(push)
(assert
   (not
      (= (update i10 el_1 (remove el_2 l28))
         (remove el_2 (update (+ i10 1) el_1 l28)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (<= (index_of el_2 l28) i10))
(assert (not (<= (index_of el_2 l28) i10)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el11 () Inductive)
(declare-fun f15 () Inductive)
(declare-fun l29 () Inductive)
(declare-fun currentThread87 () Int)
(push)
(push)
; Assume: (= true (mem el11 (filter f15 l29)))
(assert (= true (mem el11 (filter f15 l29))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l29 nil)
(assert (= l29 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h78 () Inductive)
(declare-fun t78 () Inductive)
(push)
(push)
; Assume: (= l29 (cons h78 t78))
(assert (= l29 (cons h78 t78)))
(check-sat)
(push)
(push)
; Assume: (not (= h78 el11))
(assert (not (= h78 el11)))
(check-sat)
(push)
; Query: (= true (mem el11 (filter f15 t78)))
(push)
(assert (not (= true (mem el11 (filter f15 t78)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem el11 t78))
(assert (= true (mem el11 t78)))
(check-sat)
; Query: (= true (mem el11 l29))
(push)
(assert (not (= true (mem el11 l29))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h78 el11)))
(assert (not (not (= h78 el11))))
(check-sat)
(push)
; Query: (= true (mem el11 l29))
(push)
(assert (not (= true (mem el11 l29))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el_10 () Inductive)
(declare-fun index1 () Int)
(declare-fun el_20 () Inductive)
(declare-fun l30 () Inductive)
(declare-fun currentThread88 () Int)
(push)
(push)
; Assume: (= true (mem el_10 l30))
(assert (= true (mem el_10 l30)))
(check-sat)
(push)
; Assume: (not (= (index_of el_10 l30) index1))
(assert (not (= (index_of el_10 l30) index1)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l30 nil)
(assert (= l30 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h79 () Inductive)
(declare-fun t79 () Inductive)
(push)
(push)
; Assume: (= l30 (cons h79 t79))
(assert (= l30 (cons h79 t79)))
(check-sat)
(push)
(push)
; Assume: (not (= h79 el_10))
(assert (not (= h79 el_10)))
(check-sat)
(push)
; Query: (= true (mem el_10 t79))
(push)
(assert (not (= true (mem el_10 t79))))
(check-sat)
(pop 1)
; Query: (not (= (index_of el_10 t79) (- index1 1)))
(push)
(assert (not (not (= (index_of el_10 t79) (- index1 1)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem el_10 (update (- index1 1) el_20 t79)))
(assert (= true (mem el_10 (update (- index1 1) el_20 t79))))
(check-sat)
; Query: (= true (mem el_10 (update index1 el_20 l30)))
(push)
(assert (not (= true (mem el_10 (update index1 el_20 l30)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h79 el_10)))
(assert (not (not (= h79 el_10))))
(check-sat)
(push)
; Query: (= true (mem el_10 (update index1 el_20 l30)))
(push)
(assert (not (= true (mem el_10 (update index1 el_20 l30)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el_11 () Inductive)
(declare-fun index2 () Int)
(declare-fun el_21 () Inductive)
(declare-fun l31 () Inductive)
(declare-fun currentThread89 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l31 nil)
(assert (= l31 nil))
(check-sat)
; Query: (= (update index2 el_11 (update index2 el_21 l31)) (update index2 el_11 l31))
(push)
(assert
   (not
      (= (update index2 el_11 (update index2 el_21 l31))
         (update index2 el_11 l31))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h80 () Inductive)
(declare-fun t80 () Inductive)
(push)
(push)
; Assume: (= l31 (cons h80 t80))
(assert (= l31 (cons h80 t80)))
(check-sat)
(push)
(push)
; Assume: (not (= index2 0))
(assert (not (= index2 0)))
(check-sat)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (update (- index2 1) el_11 (update (- index2 1) el_21 t80)) (update (- index2 1) el_11 t80))
(assert
   (= (update (- index2 1) el_11 (update (- index2 1) el_21 t80))
      (update (- index2 1) el_11 t80)))
(check-sat)
; Query: (= (update index2 el_11 (update index2 el_21 l31)) (update index2 el_11 l31))
(push)
(assert
   (not
      (= (update index2 el_11 (update index2 el_21 l31))
         (update index2 el_11 l31))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= index2 0)))
(assert (not (not (= index2 0))))
(check-sat)
(push)
; Query: (= (update index2 el_11 (update index2 el_21 l31)) (update index2 el_11 l31))
(push)
(assert
   (not
      (= (update index2 el_11 (update index2 el_21 l31))
         (update index2 el_11 l31))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(assert
   (forall ((var Inductive) (var0 Int) (var1 Inductive) (var2 Inductive))
      (!
         (=> true
            (= (update var0 var (update var0 var1 var2))
               (update var0 var var2)))
         :pattern ((update var0 var (update var0 var1 var2))))))
(declare-fun set_eq (Inductive Inductive) Bool)
(declare-fun _@set_eq () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@set_eq var) var0)) (set_eq var var0))
         :pattern ((_@ (_@ _@set_eq var) var0)))))
(declare-fun subset_remove () Int)
(declare-fun remove_subset () Int)
(declare-fun remove_both_subset () Int)
(declare-fun subset_remove_unrelevant () Int)
(declare-fun subset_append () Int)
(declare-fun subset_append_2 () Int)
(declare-fun subset_append_3 () Int)
(declare-fun remove_extra_preserves_subset () Int)
(declare-fun add_extra_preserves_subset () Int)
(declare-fun subset_unremove () Int)
(declare-fun subset_mem_trans () Int)
(declare-fun subset_disjoint () Int)
(declare-fun distinct_2_subset_sublen () Int)
(declare-fun distinct_superset () Int)
(declare-fun distinct_subset_sublen () Int)
(declare-fun subset_push_to_the_end () Int)
(declare-fun push_to_the_end_subset () Int)
(declare-fun subset_forall () Int)
(declare-fun subset_append_distinct () Int)
(declare-fun subset_map () Int)
(declare-fun filter_subset () Int)
(declare-fun append_both_subset () Int)
(declare-fun set_eq_remove_uniq_both () Int)
(declare-fun set_eq_remove_both () Int)
(declare-fun subset_nil_nil () Int)
(declare-fun set_eq_distinct_same_len () Int)
(declare-fun set_eq_forall_both () Int)
(declare-fun content_eq_map () Int)
(declare-fun distinct_shorter_than_nondistinct () Int)
(declare-fun set_eq_same_len_distinct_both () Int)
(declare-fun intersection_subset () Int)
(declare-fun subset_unremove_outer () Int)
(declare-fun set_eq_trans () Int)
(declare-fun set_eq_cons () Int)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (set_eq var var0) (and (subset0 var var0) (subset0 var0 var)))
         :pattern ((set_eq var var0)))))
; Assert: (= (func_rank subset_remove) 306)
(assert (= (func_rank subset_remove) 306))
; Assert: (= (func_rank remove_subset) 307)
(assert (= (func_rank remove_subset) 307))
; Assert: (= (func_rank remove_both_subset) 308)
(assert (= (func_rank remove_both_subset) 308))
; Assert: (= (func_rank subset_remove_unrelevant) 309)
(assert (= (func_rank subset_remove_unrelevant) 309))
; Assert: (= (func_rank subset_append) 310)
(assert (= (func_rank subset_append) 310))
; Assert: (= (func_rank subset_append_2) 311)
(assert (= (func_rank subset_append_2) 311))
; Assert: (= (func_rank subset_append_3) 312)
(assert (= (func_rank subset_append_3) 312))
; Assert: (= (func_rank remove_extra_preserves_subset) 313)
(assert (= (func_rank remove_extra_preserves_subset) 313))
; Assert: (= (func_rank add_extra_preserves_subset) 314)
(assert (= (func_rank add_extra_preserves_subset) 314))
; Assert: (= (func_rank subset_unremove) 315)
(assert (= (func_rank subset_unremove) 315))
; Assert: (= (func_rank subset_mem_trans) 316)
(assert (= (func_rank subset_mem_trans) 316))
; Assert: (= (func_rank subset_disjoint) 317)
(assert (= (func_rank subset_disjoint) 317))
; Assert: (= (func_rank distinct_2_subset_sublen) 318)
(assert (= (func_rank distinct_2_subset_sublen) 318))
; Assert: (= (func_rank distinct_superset) 319)
(assert (= (func_rank distinct_superset) 319))
; Assert: (= (func_rank distinct_subset_sublen) 320)
(assert (= (func_rank distinct_subset_sublen) 320))
; Assert: (= (func_rank subset_push_to_the_end) 321)
(assert (= (func_rank subset_push_to_the_end) 321))
; Assert: (= (func_rank push_to_the_end_subset) 322)
(assert (= (func_rank push_to_the_end_subset) 322))
; Assert: (= (func_rank subset_forall) 323)
(assert (= (func_rank subset_forall) 323))
; Assert: (= (func_rank subset_append_distinct) 324)
(assert (= (func_rank subset_append_distinct) 324))
; Assert: (= (func_rank subset_map) 325)
(assert (= (func_rank subset_map) 325))
; Assert: (= (func_rank filter_subset) 326)
(assert (= (func_rank filter_subset) 326))
; Assert: (= (func_rank append_both_subset) 327)
(assert (= (func_rank append_both_subset) 327))
; Assert: (= (func_rank set_eq_remove_uniq_both) 328)
(assert (= (func_rank set_eq_remove_uniq_both) 328))
; Assert: (= (func_rank set_eq_remove_both) 329)
(assert (= (func_rank set_eq_remove_both) 329))
; Assert: (= (func_rank subset_nil_nil) 330)
(assert (= (func_rank subset_nil_nil) 330))
; Assert: (= (func_rank set_eq_distinct_same_len) 331)
(assert (= (func_rank set_eq_distinct_same_len) 331))
; Assert: (= (func_rank set_eq_forall_both) 332)
(assert (= (func_rank set_eq_forall_both) 332))
; Assert: (= (func_rank content_eq_map) 333)
(assert (= (func_rank content_eq_map) 333))
; Assert: (= (func_rank distinct_shorter_than_nondistinct) 334)
(assert (= (func_rank distinct_shorter_than_nondistinct) 334))
; Assert: (= (func_rank set_eq_same_len_distinct_both) 335)
(assert (= (func_rank set_eq_same_len_distinct_both) 335))
; Assert: (= (func_rank intersection_subset) 336)
(assert (= (func_rank intersection_subset) 336))
; Assert: (= (func_rank subset_unremove_outer) 337)
(assert (= (func_rank subset_unremove_outer) 337))
; Assert: (= (func_rank set_eq_trans) 338)
(assert (= (func_rank set_eq_trans) 338))
; Assert: (= (func_rank set_eq_cons) 339)
(assert (= (func_rank set_eq_cons) 339))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(push)
(declare-fun xs2 () Inductive)
(declare-fun ys () Inductive)
(declare-fun el12 () Inductive)
(declare-fun currentThread90 () Int)
(push)
(push)
; Assume: (= true (subset0 xs2 ys))
(assert (= true (subset0 xs2 ys)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs2 nil)
(assert (= xs2 nil))
(check-sat)
; Query: (= true (subset0 (remove el12 xs2) ys))
(push)
(assert (not (= true (subset0 (remove el12 xs2) ys))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h81 () Inductive)
(declare-fun t81 () Inductive)
(push)
(push)
; Assume: (= xs2 (cons h81 t81))
(assert (= xs2 (cons h81 t81)))
(check-sat)
(push)
(push)
; Assume: (not (= h81 el12))
(assert (not (= h81 el12)))
(check-sat)
(push)
; Query: (= true (subset0 t81 ys))
(push)
(assert (not (= true (subset0 t81 ys))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (remove el12 t81) ys))
(assert (= true (subset0 (remove el12 t81) ys)))
(check-sat)
; Query: (= true (subset0 (remove el12 xs2) ys))
(push)
(assert (not (= true (subset0 (remove el12 xs2) ys))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h81 el12)))
(assert (not (not (= h81 el12))))
(check-sat)
(push)
; Query: (= true (subset0 (remove el12 xs2) ys))
(push)
(assert (not (= true (subset0 (remove el12 xs2) ys))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs3 () Inductive)
(declare-fun el13 () Inductive)
(declare-fun ys0 () Inductive)
(declare-fun currentThread91 () Int)
(push)
(push)
; Assume: (= true (subset0 xs3 ys0))
(assert (= true (subset0 xs3 ys0)))
(check-sat)
(push)
; Assume: (= false (mem el13 xs3))
(assert (= false (mem el13 xs3)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs3 nil)
(assert (= xs3 nil))
(check-sat)
; Query: (= true (subset0 xs3 (remove el13 ys0)))
(push)
(assert (not (= true (subset0 xs3 (remove el13 ys0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h82 () Inductive)
(declare-fun t82 () Inductive)
(push)
(push)
; Assume: (= xs3 (cons h82 t82))
(assert (= xs3 (cons h82 t82)))
(check-sat)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h82 el13))
(push)
(assert (not (not (= h82 el13))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h82 (remove el13 ys0)) (mem h82 ys0))
(assert (= (mem h82 (remove el13 ys0)) (mem h82 ys0)))
(check-sat)
; Query: (= true (subset0 t82 ys0))
(push)
(assert (not (= true (subset0 t82 ys0))))
(check-sat)
(pop 1)
; Query: (= false (mem el13 t82))
(push)
(assert (not (= false (mem el13 t82))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t82 (remove el13 ys0)))
(assert (= true (subset0 t82 (remove el13 ys0))))
(check-sat)
; Query: (= true (subset0 xs3 (remove el13 ys0)))
(push)
(assert (not (= true (subset0 xs3 (remove el13 ys0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el14 () Inductive)
(declare-fun xs4 () Inductive)
(declare-fun ys1 () Inductive)
(declare-fun currentThread92 () Int)
(push)
(push)
; Assume: (= true (subset0 xs4 ys1))
(assert (= true (subset0 xs4 ys1)))
(check-sat)
(push)
; Assume: (= false (mem el14 (remove el14 xs4)))
(assert (= false (mem el14 (remove el14 xs4))))
(check-sat)
(push)
(push)
; Query: (= true (subset0 xs4 ys1))
(push)
(assert (not (= true (subset0 xs4 ys1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (remove el14 xs4) ys1))
(assert (= true (subset0 (remove el14 xs4) ys1)))
(check-sat)
; Query: (= true (subset0 (remove el14 xs4) ys1))
(push)
(assert (not (= true (subset0 (remove el14 xs4) ys1))))
(check-sat)
(pop 1)
; Query: (= false (mem el14 (remove el14 xs4)))
(push)
(assert (not (= false (mem el14 (remove el14 xs4)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (remove el14 xs4) (remove el14 ys1)))
(assert (= true (subset0 (remove el14 xs4) (remove el14 ys1))))
(check-sat)
; Query: (= true (subset0 (remove el14 xs4) (remove el14 ys1)))
(push)
(assert (not (= true (subset0 (remove el14 xs4) (remove el14 ys1)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs5 () Inductive)
(declare-fun ys2 () Inductive)
(declare-fun el15 () Inductive)
(declare-fun currentThread93 () Int)
(push)
(push)
; Assume: (= true (subset0 xs5 ys2))
(assert (= true (subset0 xs5 ys2)))
(check-sat)
(push)
; Assume: (= false (mem el15 xs5))
(assert (= false (mem el15 xs5)))
(check-sat)
(push)
(push)
; Query: (= false (mem el15 xs5))
(push)
(assert (not (= false (mem el15 xs5))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el15 xs5) xs5)
(assert (= (remove el15 xs5) xs5))
(check-sat)
; Query: (= true (subset0 xs5 ys2))
(push)
(assert (not (= true (subset0 xs5 ys2))))
(check-sat)
(pop 1)
; Query: (= false (mem el15 (remove el15 xs5)))
(push)
(assert (not (= false (mem el15 (remove el15 xs5)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (remove el15 xs5) (remove el15 ys2)))
(assert (= true (subset0 (remove el15 xs5) (remove el15 ys2))))
(check-sat)
; Query: (= true (subset0 xs5 (remove el15 ys2)))
(push)
(assert (not (= true (subset0 xs5 (remove el15 ys2)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs6 () Inductive)
(declare-fun ys3 () Inductive)
(declare-fun zs () Inductive)
(declare-fun currentThread94 () Int)
(push)
(push)
; Assume: (= true (subset0 xs6 zs))
(assert (= true (subset0 xs6 zs)))
(check-sat)
(push)
; Assume: (= true (subset0 ys3 zs))
(assert (= true (subset0 ys3 zs)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs6 nil)
(assert (= xs6 nil))
(check-sat)
; Query: (= true (subset0 (append xs6 ys3) zs))
(push)
(assert (not (= true (subset0 (append xs6 ys3) zs))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h83 () Inductive)
(declare-fun t83 () Inductive)
(push)
(push)
; Assume: (= xs6 (cons h83 t83))
(assert (= xs6 (cons h83 t83)))
(check-sat)
; Query: (= true (subset0 t83 zs))
(push)
(assert (not (= true (subset0 t83 zs))))
(check-sat)
(pop 1)
; Query: (= true (subset0 ys3 zs))
(push)
(assert (not (= true (subset0 ys3 zs))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (append t83 ys3) zs))
(assert (= true (subset0 (append t83 ys3) zs)))
(check-sat)
; Query: (= true (subset0 (append xs6 ys3) zs))
(push)
(assert (not (= true (subset0 (append xs6 ys3) zs))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs7 () Inductive)
(declare-fun ys4 () Inductive)
(declare-fun zs0 () Inductive)
(declare-fun currentThread95 () Int)
(push)
(push)
; Assume: (= true (subset0 xs7 ys4))
(assert (= true (subset0 xs7 ys4)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs7 nil)
(assert (= xs7 nil))
(check-sat)
; Query: (= true (subset0 xs7 (append ys4 zs0)))
(push)
(assert (not (= true (subset0 xs7 (append ys4 zs0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h84 () Inductive)
(declare-fun t84 () Inductive)
(push)
(push)
; Assume: (= xs7 (cons h84 t84))
(assert (= xs7 (cons h84 t84)))
(check-sat)
; Query: (= true (subset0 t84 ys4))
(push)
(assert (not (= true (subset0 t84 ys4))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t84 (append ys4 zs0)))
(assert (= true (subset0 t84 (append ys4 zs0))))
(check-sat)
; Query: (= true (subset0 xs7 (append ys4 zs0)))
(push)
(assert (not (= true (subset0 xs7 (append ys4 zs0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs8 () Inductive)
(declare-fun ys5 () Inductive)
(declare-fun zs1 () Inductive)
(declare-fun currentThread96 () Int)
(push)
(push)
; Assume: (= true (subset0 xs8 zs1))
(assert (= true (subset0 xs8 zs1)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs8 nil)
(assert (= xs8 nil))
(check-sat)
; Query: (= true (subset0 xs8 (append ys5 zs1)))
(push)
(assert (not (= true (subset0 xs8 (append ys5 zs1)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h85 () Inductive)
(declare-fun t85 () Inductive)
(push)
(push)
; Assume: (= xs8 (cons h85 t85))
(assert (= xs8 (cons h85 t85)))
(check-sat)
; Query: (= true (subset0 t85 zs1))
(push)
(assert (not (= true (subset0 t85 zs1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t85 (append ys5 zs1)))
(assert (= true (subset0 t85 (append ys5 zs1))))
(check-sat)
; Query: (= true (subset0 xs8 (append ys5 zs1)))
(push)
(assert (not (= true (subset0 xs8 (append ys5 zs1)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs9 () Inductive)
(declare-fun ys6 () Inductive)
(declare-fun el16 () Inductive)
(declare-fun currentThread97 () Int)
(push)
(push)
; Assume: (= true (subset0 xs9 ys6))
(assert (= true (subset0 xs9 ys6)))
(check-sat)
(push)
; Assume: (= true (mem el16 (remove el16 ys6)))
(assert (= true (mem el16 (remove el16 ys6))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs9 nil)
(assert (= xs9 nil))
(check-sat)
; Query: (= true (subset0 xs9 (remove el16 ys6)))
(push)
(assert (not (= true (subset0 xs9 (remove el16 ys6)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h86 () Inductive)
(declare-fun t86 () Inductive)
(push)
(push)
; Assume: (= xs9 (cons h86 t86))
(assert (= xs9 (cons h86 t86)))
(check-sat)
(push)
(push)
; Assume: (not (= h86 el16))
(assert (not (= h86 el16)))
(check-sat)
(push)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h86 el16))
(push)
(assert (not (not (= h86 el16))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h86 (remove el16 ys6)) (mem h86 ys6))
(assert (= (mem h86 (remove el16 ys6)) (mem h86 ys6)))
(check-sat)
; Query: (= true (subset0 t86 ys6))
(push)
(assert (not (= true (subset0 t86 ys6))))
(check-sat)
(pop 1)
; Query: (= true (mem el16 (remove el16 ys6)))
(push)
(assert (not (= true (mem el16 (remove el16 ys6)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t86 (remove el16 ys6)))
(assert (= true (subset0 t86 (remove el16 ys6))))
(check-sat)
; Query: (= true (subset0 xs9 (remove el16 ys6)))
(push)
(assert (not (= true (subset0 xs9 (remove el16 ys6)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h86 el16)))
(assert (not (not (= h86 el16))))
(check-sat)
(push)
; Query: (= true (subset0 t86 ys6))
(push)
(assert (not (= true (subset0 t86 ys6))))
(check-sat)
(pop 1)
; Query: (= true (mem el16 (remove el16 ys6)))
(push)
(assert (not (= true (mem el16 (remove el16 ys6)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t86 (remove el16 ys6)))
(assert (= true (subset0 t86 (remove el16 ys6))))
(check-sat)
; Query: (= true (subset0 xs9 (remove el16 ys6)))
(push)
(assert (not (= true (subset0 xs9 (remove el16 ys6)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs10 () Inductive)
(declare-fun ys7 () Inductive)
(declare-fun el17 () Inductive)
(declare-fun currentThread98 () Int)
(push)
(push)
; Assume: (= true (subset0 xs10 ys7))
(assert (= true (subset0 xs10 ys7)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs10 nil)
(assert (= xs10 nil))
(check-sat)
; Query: (= true (subset0 xs10 (cons el17 ys7)))
(push)
(assert (not (= true (subset0 xs10 (cons el17 ys7)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h87 () Inductive)
(declare-fun t87 () Inductive)
(push)
(push)
; Assume: (= xs10 (cons h87 t87))
(assert (= xs10 (cons h87 t87)))
(check-sat)
; Query: (= true (subset0 t87 ys7))
(push)
(assert (not (= true (subset0 t87 ys7))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t87 (cons el17 ys7)))
(assert (= true (subset0 t87 (cons el17 ys7))))
(check-sat)
; Query: (= true (subset0 xs10 (cons el17 ys7)))
(push)
(assert (not (= true (subset0 xs10 (cons el17 ys7)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs11 () Inductive)
(declare-fun ys8 () Inductive)
(declare-fun el18 () Inductive)
(declare-fun currentThread99 () Int)
(push)
(push)
; Assume: (= true (subset0 (remove el18 xs11) ys8))
(assert (= true (subset0 (remove el18 xs11) ys8)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs11 nil)
(assert (= xs11 nil))
(check-sat)
; Query: (= true (subset0 xs11 (cons el18 ys8)))
(push)
(assert (not (= true (subset0 xs11 (cons el18 ys8)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h88 () Inductive)
(declare-fun t88 () Inductive)
(push)
(push)
; Assume: (= xs11 (cons h88 t88))
(assert (= xs11 (cons h88 t88)))
(check-sat)
(push)
(push)
; Assume: (not (= h88 el18))
(assert (not (= h88 el18)))
(check-sat)
(push)
; Query: (= true (subset0 (remove el18 t88) ys8))
(push)
(assert (not (= true (subset0 (remove el18 t88) ys8))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t88 (cons el18 ys8)))
(assert (= true (subset0 t88 (cons el18 ys8))))
(check-sat)
; Query: (= true (subset0 xs11 (cons el18 ys8)))
(push)
(assert (not (= true (subset0 xs11 (cons el18 ys8)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h88 el18)))
(assert (not (not (= h88 el18))))
(check-sat)
(push)
; Query: (= true (subset0 t88 ys8))
(push)
(assert (not (= true (subset0 t88 ys8))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t88 (cons el18 ys8)))
(assert (= true (subset0 t88 (cons el18 ys8))))
(check-sat)
; Query: (= true (subset0 xs11 (cons el18 ys8)))
(push)
(assert (not (= true (subset0 xs11 (cons el18 ys8)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs12 () Inductive)
(declare-fun ys9 () Inductive)
(declare-fun el19 () Inductive)
(declare-fun currentThread100 () Int)
(push)
(push)
; Assume: (= true (subset0 xs12 ys9))
(assert (= true (subset0 xs12 ys9)))
(check-sat)
(push)
; Assume: (= true (mem el19 xs12))
(assert (= true (mem el19 xs12)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs12 nil)
(assert (= xs12 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h89 () Inductive)
(declare-fun t89 () Inductive)
(push)
(push)
; Assume: (= xs12 (cons h89 t89))
(assert (= xs12 (cons h89 t89)))
(check-sat)
(push)
(push)
; Assume: (not (= h89 el19))
(assert (not (= h89 el19)))
(check-sat)
(push)
; Query: (= true (subset0 t89 ys9))
(push)
(assert (not (= true (subset0 t89 ys9))))
(check-sat)
(pop 1)
; Query: (= true (mem el19 t89))
(push)
(assert (not (= true (mem el19 t89))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem el19 ys9))
(assert (= true (mem el19 ys9)))
(check-sat)
; Query: (= true (mem el19 ys9))
(push)
(assert (not (= true (mem el19 ys9))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h89 el19)))
(assert (not (not (= h89 el19))))
(check-sat)
(push)
; Query: (= true (mem el19 ys9))
(push)
(assert (not (= true (mem el19 ys9))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_118 () Inductive)
(declare-fun l_218 () Inductive)
(declare-fun l_34 () Inductive)
(declare-fun currentThread101 () Int)
(push)
(push)
; Assume: (= true (subset0 l_118 l_218))
(assert (= true (subset0 l_118 l_218)))
(check-sat)
(push)
; Assume: (= true (disjoint l_218 l_34))
(assert (= true (disjoint l_218 l_34)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_34 nil)
(assert (= l_34 nil))
(check-sat)
; Query: (= true (disjoint l_118 l_34))
(push)
(assert (not (= true (disjoint l_118 l_34))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h90 () Inductive)
(declare-fun t90 () Inductive)
(push)
(push)
; Assume: (= l_34 (cons h90 t90))
(assert (= l_34 (cons h90 t90)))
(check-sat)
(push)
(push)
; Assume: (mem h90 l_118)
(assert (mem h90 l_118))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_118 l_218))
(push)
(assert (not (= true (subset0 l_118 l_218))))
(check-sat)
(pop 1)
; Query: (= true (mem h90 l_118))
(push)
(assert (not (= true (mem h90 l_118))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem h90 l_218))
(assert (= true (mem h90 l_218)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem h90 l_118))
(assert (not (mem h90 l_118)))
(check-sat)
(push)
; Query: (= true (subset0 l_118 l_218))
(push)
(assert (not (= true (subset0 l_118 l_218))))
(check-sat)
(pop 1)
; Query: (= true (disjoint l_218 t90))
(push)
(assert (not (= true (disjoint l_218 t90))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint l_118 t90))
(assert (= true (disjoint l_118 t90)))
(check-sat)
; Query: (= true (disjoint l_118 l_34))
(push)
(assert (not (= true (disjoint l_118 l_34))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs13 () Inductive)
(declare-fun ys10 () Inductive)
(declare-fun currentThread102 () Int)
(push)
(push)
; Assume: (= true (distinct0 xs13))
(assert (= true (distinct0 xs13)))
(check-sat)
(push)
; Assume: (= true (subset0 xs13 ys10))
(assert (= true (subset0 xs13 ys10)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs13 nil)
(assert (= xs13 nil))
(check-sat)
; Query: (<= (length xs13) (length ys10))
(push)
(assert (not (<= (length xs13) (length ys10))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h91 () Inductive)
(declare-fun t91 () Inductive)
(push)
(push)
; Assume: (= xs13 (cons h91 t91))
(assert (= xs13 (cons h91 t91)))
(check-sat)
; Query: (= true (subset0 t91 ys10))
(push)
(assert (not (= true (subset0 t91 ys10))))
(check-sat)
(pop 1)
; Query: (= false (mem h91 t91))
(push)
(assert (not (= false (mem h91 t91))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t91 (remove h91 ys10)))
(assert (= true (subset0 t91 (remove h91 ys10))))
(check-sat)
; Query: (= true (distinct0 t91))
(push)
(assert (not (= true (distinct0 t91))))
(check-sat)
(pop 1)
; Query: (= true (subset0 t91 (remove h91 ys10)))
(push)
(assert (not (= true (subset0 t91 (remove h91 ys10)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= (length t91) (length (remove h91 ys10)))
(assert (<= (length t91) (length (remove h91 ys10))))
(check-sat)
; Query: (<= (length xs13) (length ys10))
(push)
(assert (not (<= (length xs13) (length ys10))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs14 () Inductive)
(declare-fun ys11 () Inductive)
(declare-fun currentThread103 () Int)
(push)
(push)
; Assume: (= true (subset0 xs14 ys11))
(assert (= true (subset0 xs14 ys11)))
(check-sat)
(push)
; Assume: (= true (distinct0 xs14))
(assert (= true (distinct0 xs14)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= ys11 nil)
(assert (= ys11 nil))
(check-sat)
; Query: (= true (subset0 xs14 nil))
(push)
(assert (not (= true (subset0 xs14 nil))))
(check-sat)
(pop 1)
; Query: (= true (subset0 nil ys11))
(push)
(assert (not (= true (subset0 nil ys11))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 nil))
(push)
(assert (not (= true (distinct0 nil))))
(check-sat)
(pop 1)
; Query: (<= (length nil) (length ys11))
(push)
(assert (not (<= (length nil) (length ys11))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h92 () Inductive)
(declare-fun t92 () Inductive)
(push)
(push)
; Assume: (= ys11 (cons h92 t92))
(assert (= ys11 (cons h92 t92)))
(check-sat)
(push)
(push)
; Assume: (mem h92 t92)
(assert (mem h92 t92))
(check-sat)
(push)
(push)
; Query: (= true (subset0 xs14 ys11))
(push)
(assert (not (= true (subset0 xs14 ys11))))
(check-sat)
(pop 1)
; Query: (= true (mem h92 (remove h92 ys11)))
(push)
(assert (not (= true (mem h92 (remove h92 ys11)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 xs14 (remove h92 ys11)))
(assert (= true (subset0 xs14 (remove h92 ys11))))
(check-sat)
; Query: (= true (subset0 xs14 t92))
(push)
(assert (not (= true (subset0 xs14 t92))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 xs14))
(push)
(assert (not (= true (distinct0 xs14))))
(check-sat)
(pop 1)
(declare-fun rez () Inductive)
(push)
(push)
; Assume: (= true (subset0 xs14 rez))
(assert (= true (subset0 xs14 rez)))
(check-sat)
(push)
; Assume: (= true (subset0 rez t92))
(assert (= true (subset0 rez t92)))
(check-sat)
(push)
; Assume: (= true (distinct0 rez))
(assert (= true (distinct0 rez)))
(check-sat)
(push)
; Assume: (<= (length rez) (length t92))
(assert (<= (length rez) (length t92)))
(check-sat)
; Query: (= true (subset0 rez t92))
(push)
(assert (not (= true (subset0 rez t92))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 rez (cons h92 t92)))
(assert (= true (subset0 rez (cons h92 t92))))
(check-sat)
; Query: (= true (subset0 xs14 rez))
(push)
(assert (not (= true (subset0 xs14 rez))))
(check-sat)
(pop 1)
; Query: (= true (subset0 rez ys11))
(push)
(assert (not (= true (subset0 rez ys11))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 rez))
(push)
(assert (not (= true (distinct0 rez))))
(check-sat)
(pop 1)
; Query: (<= (length rez) (length ys11))
(push)
(assert (not (<= (length rez) (length ys11))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem h92 t92))
(assert (not (mem h92 t92)))
(check-sat)
(push)
(push)
; Query: (= true (distinct0 xs14))
(push)
(assert (not (= true (distinct0 xs14))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem h92 (remove h92 xs14)))
(assert (= false (mem h92 (remove h92 xs14))))
(check-sat)
; Query: (= true (subset0 xs14 ys11))
(push)
(assert (not (= true (subset0 xs14 ys11))))
(check-sat)
(pop 1)
; Query: (= false (mem h92 (remove h92 xs14)))
(push)
(assert (not (= false (mem h92 (remove h92 xs14)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (remove h92 xs14) (remove h92 ys11)))
(assert (= true (subset0 (remove h92 xs14) (remove h92 ys11))))
(check-sat)
; Assert: (< (func_rank distinct_remove) 0)
(assert (< (func_rank distinct_remove) 0))
; Query: (= (distinct0 xs14) true)
(push)
(assert (not (= (distinct0 xs14) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (distinct0 (remove h92 xs14)) true)
(assert (= (distinct0 (remove h92 xs14)) true))
(check-sat)
; Query: (= true (subset0 (remove h92 xs14) t92))
(push)
(assert (not (= true (subset0 (remove h92 xs14) t92))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 (remove h92 xs14)))
(push)
(assert (not (= true (distinct0 (remove h92 xs14)))))
(check-sat)
(pop 1)
(declare-fun t_rez () Inductive)
(push)
(push)
; Assume: (= true (subset0 (remove h92 xs14) t_rez))
(assert (= true (subset0 (remove h92 xs14) t_rez)))
(check-sat)
(push)
; Assume: (= true (subset0 t_rez t92))
(assert (= true (subset0 t_rez t92)))
(check-sat)
(push)
; Assume: (= true (distinct0 t_rez))
(assert (= true (distinct0 t_rez)))
(check-sat)
(push)
; Assume: (<= (length t_rez) (length t92))
(assert (<= (length t_rez) (length t92)))
(check-sat)
; Query: (= true (subset0 (remove h92 xs14) t_rez))
(push)
(assert (not (= true (subset0 (remove h92 xs14) t_rez))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 xs14 (cons h92 t_rez)))
(assert (= true (subset0 xs14 (cons h92 t_rez))))
(check-sat)
; Query: (= true (subset0 t_rez t92))
(push)
(assert (not (= true (subset0 t_rez t92))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t_rez (cons h92 t92)))
(assert (= true (subset0 t_rez (cons h92 t92))))
(check-sat)
(push)
(push)
; Assume: (= true (mem h92 t_rez))
(assert (= true (mem h92 t_rez)))
(check-sat)
(push)
(push)
; Query: (= true (subset0 t_rez t92))
(push)
(assert (not (= true (subset0 t_rez t92))))
(check-sat)
(pop 1)
; Query: (= true (mem h92 t_rez))
(push)
(assert (not (= true (mem h92 t_rez))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem h92 t92))
(assert (= true (mem h92 t92)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= true (mem h92 t_rez)))
(assert (not (= true (mem h92 t_rez))))
(check-sat)
(push)
; Query: (= false (mem h92 t_rez))
(push)
(assert (not (= false (mem h92 t_rez))))
(check-sat)
(pop 1)
; Query: (= true (subset0 xs14 (cons h92 t_rez)))
(push)
(assert (not (= true (subset0 xs14 (cons h92 t_rez)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (cons h92 t_rez) ys11))
(push)
(assert (not (= true (subset0 (cons h92 t_rez) ys11))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 (cons h92 t_rez)))
(push)
(assert (not (= true (distinct0 (cons h92 t_rez)))))
(check-sat)
(pop 1)
; Query: (<= (length (cons h92 t_rez)) (length ys11))
(push)
(assert (not (<= (length (cons h92 t_rez)) (length ys11))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs15 () Inductive)
(declare-fun ys12 () Inductive)
(declare-fun currentThread104 () Int)
(push)
(push)
; Assume: (= true (distinct0 xs15))
(assert (= true (distinct0 xs15)))
(check-sat)
(push)
; Assume: (= true (subset0 xs15 ys12))
(assert (= true (subset0 xs15 ys12)))
(check-sat)
(push)
(push)
; Query: (= true (subset0 xs15 ys12))
(push)
(assert (not (= true (subset0 xs15 ys12))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 xs15))
(push)
(assert (not (= true (distinct0 xs15))))
(check-sat)
(pop 1)
(declare-fun result3 () Inductive)
(push)
(push)
; Assume: (= true (subset0 xs15 result3))
(assert (= true (subset0 xs15 result3)))
(check-sat)
(push)
; Assume: (= true (subset0 result3 ys12))
(assert (= true (subset0 result3 ys12)))
(check-sat)
(push)
; Assume: (= true (distinct0 result3))
(assert (= true (distinct0 result3)))
(check-sat)
(push)
; Assume: (<= (length result3) (length ys12))
(assert (<= (length result3) (length ys12)))
(check-sat)
; Query: (= true (distinct0 xs15))
(push)
(assert (not (= true (distinct0 xs15))))
(check-sat)
(pop 1)
; Query: (= true (subset0 xs15 result3))
(push)
(assert (not (= true (subset0 xs15 result3))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= (length xs15) (length result3))
(assert (<= (length xs15) (length result3)))
(check-sat)
; Query: (<= (length xs15) (length ys12))
(push)
(assert (not (<= (length xs15) (length ys12))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs16 () Inductive)
(declare-fun ys13 () Inductive)
(declare-fun el20 () Inductive)
(declare-fun currentThread105 () Int)
(push)
(push)
; Assume: (= true (subset0 xs16 ys13))
(assert (= true (subset0 xs16 ys13)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs16 nil)
(assert (= xs16 nil))
(check-sat)
; Query: (= true (subset0 xs16 (append (remove el20 ys13) (cons el20 nil))))
(push)
(assert
   (not (= true (subset0 xs16 (append (remove el20 ys13) (cons el20 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h93 () Inductive)
(declare-fun t93 () Inductive)
(push)
(push)
; Assume: (= xs16 (cons h93 t93))
(assert (= xs16 (cons h93 t93)))
(check-sat)
(push)
(push)
; Assume: (= h93 el20)
(assert (= h93 el20))
(check-sat)
(push)
(push)
; Query: (= true (subset0 t93 ys13))
(push)
(assert (not (= true (subset0 t93 ys13))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t93 (append (remove el20 ys13) (cons el20 nil))))
(assert (= true (subset0 t93 (append (remove el20 ys13) (cons el20 nil)))))
(check-sat)
; Query: (= true (subset0 xs16 (append (remove el20 ys13) (cons el20 nil))))
(push)
(assert
   (not (= true (subset0 xs16 (append (remove el20 ys13) (cons el20 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h93 el20))
(assert (not (= h93 el20)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h93 el20))
(push)
(assert (not (not (= h93 el20))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h93 (remove el20 ys13)) (mem h93 ys13))
(assert (= (mem h93 (remove el20 ys13)) (mem h93 ys13)))
(check-sat)
; Query: (= true (subset0 t93 ys13))
(push)
(assert (not (= true (subset0 t93 ys13))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t93 (append (remove el20 ys13) (cons el20 nil))))
(assert (= true (subset0 t93 (append (remove el20 ys13) (cons el20 nil)))))
(check-sat)
; Query: (= true (subset0 xs16 (append (remove el20 ys13) (cons el20 nil))))
(push)
(assert
   (not (= true (subset0 xs16 (append (remove el20 ys13) (cons el20 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs17 () Inductive)
(declare-fun ys14 () Inductive)
(declare-fun el21 () Inductive)
(declare-fun currentThread106 () Int)
(push)
(push)
; Assume: (= true (subset0 xs17 ys14))
(assert (= true (subset0 xs17 ys14)))
(check-sat)
(push)
; Assume: (= true (mem el21 ys14))
(assert (= true (mem el21 ys14)))
(check-sat)
(push)
(push)
; Query: (= true (subset0 xs17 ys14))
(push)
(assert (not (= true (subset0 xs17 ys14))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (remove el21 xs17) ys14))
(assert (= true (subset0 (remove el21 xs17) ys14)))
(check-sat)
; Query: (= true (subset0 (remove el21 xs17) ys14))
(push)
(assert (not (= true (subset0 (remove el21 xs17) ys14))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (cons el21 nil) ys14))
(push)
(assert (not (= true (subset0 (cons el21 nil) ys14))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (append (remove el21 xs17) (cons el21 nil)) ys14))
(assert (= true (subset0 (append (remove el21 xs17) (cons el21 nil)) ys14)))
(check-sat)
; Query: (= true (subset0 (append (remove el21 xs17) (cons el21 nil)) ys14))
(push)
(assert
   (not (= true (subset0 (append (remove el21 xs17) (cons el21 nil)) ys14))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs18 () Inductive)
(declare-fun ys15 () Inductive)
(declare-fun prop0 () Inductive)
(declare-fun currentThread107 () Int)
(push)
(push)
; Assume: (= true (subset0 xs18 ys15))
(assert (= true (subset0 xs18 ys15)))
(check-sat)
(push)
; Assume: (= true (forall0 ys15 prop0))
(assert (= true (forall0 ys15 prop0)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs18 nil)
(assert (= xs18 nil))
(check-sat)
; Query: (= true (forall0 xs18 prop0))
(push)
(assert (not (= true (forall0 xs18 prop0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h94 () Inductive)
(declare-fun t94 () Inductive)
(push)
(push)
; Assume: (= xs18 (cons h94 t94))
(assert (= xs18 (cons h94 t94)))
(check-sat)
; Assert: (< (func_rank forall_mem) 0)
(assert (< (func_rank forall_mem) 0))
; Query: (and (= (forall0 ys15 prop0) true) (= (mem h94 ys15) true))
(push)
(assert (not (and (= (forall0 ys15 prop0) true) (= (mem h94 ys15) true))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (unbox_bool (_@ prop0 h94)) true)
(assert (= (unbox_bool (_@ prop0 h94)) true))
(check-sat)
; Query: (= true (subset0 t94 ys15))
(push)
(assert (not (= true (subset0 t94 ys15))))
(check-sat)
(pop 1)
; Query: (= true (forall0 ys15 prop0))
(push)
(assert (not (= true (forall0 ys15 prop0))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 t94 prop0))
(assert (= true (forall0 t94 prop0)))
(check-sat)
; Query: (= true (forall0 xs18 prop0))
(push)
(assert (not (= true (forall0 xs18 prop0))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs19 () Inductive)
(declare-fun ys16 () Inductive)
(declare-fun zs2 () Inductive)
(declare-fun currentThread108 () Int)
(push)
(push)
; Assume: (= true (subset0 xs19 ys16))
(assert (= true (subset0 xs19 ys16)))
(check-sat)
(push)
; Assume: (= true (distinct0 xs19))
(assert (= true (distinct0 xs19)))
(check-sat)
(push)
; Assume: (= true (distinct0 (append ys16 zs2)))
(assert (= true (distinct0 (append ys16 zs2))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs19 nil)
(assert (= xs19 nil))
(check-sat)
; Query: (= true (distinct0 (append ys16 zs2)))
(push)
(assert (not (= true (distinct0 (append ys16 zs2)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 ys16))
(assert (= true (distinct0 ys16)))
(check-sat)
(push)
; Assume: (= true (distinct0 zs2))
(assert (= true (distinct0 zs2)))
(check-sat)
(push)
; Assume: (= true (disjoint zs2 ys16))
(assert (= true (disjoint zs2 ys16)))
(check-sat)
; Query: (= true (distinct0 (append xs19 zs2)))
(push)
(assert (not (= true (distinct0 (append xs19 zs2)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h95 () Inductive)
(declare-fun t95 () Inductive)
(push)
(push)
; Assume: (= xs19 (cons h95 t95))
(assert (= xs19 (cons h95 t95)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h95 (append t95 zs2)) (or (mem h95 t95) (mem h95 zs2)))
(assert (= (mem h95 (append t95 zs2)) (or (mem h95 t95) (mem h95 zs2))))
(check-sat)
(push)
(push)
; Assume: (mem h95 zs2)
(assert (mem h95 zs2))
(check-sat)
(push)
(push)
; Query: (= true (mem h95 ys16))
(push)
(assert (not (= true (mem h95 ys16))))
(check-sat)
(pop 1)
; Query: (= true (mem h95 ys16))
(push)
(assert (not (= true (mem h95 ys16))))
(check-sat)
(pop 1)
; Query: (= true (mem h95 zs2))
(push)
(assert (not (= true (mem h95 zs2))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (distinct0 (append ys16 zs2)))
(assert (= false (distinct0 (append ys16 zs2))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem h95 zs2))
(assert (not (mem h95 zs2)))
(check-sat)
(push)
; Query: (= true (subset0 t95 ys16))
(push)
(assert (not (= true (subset0 t95 ys16))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 t95))
(push)
(assert (not (= true (distinct0 t95))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 (append ys16 zs2)))
(push)
(assert (not (= true (distinct0 (append ys16 zs2)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 (append t95 zs2)))
(assert (= true (distinct0 (append t95 zs2))))
(check-sat)
; Query: (= true (distinct0 (append xs19 zs2)))
(push)
(assert (not (= true (distinct0 (append xs19 zs2)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_119 () Inductive)
(declare-fun l_219 () Inductive)
(declare-fun f16 () Inductive)
(declare-fun currentThread109 () Int)
(push)
(push)
; Assume: (= true (subset0 l_119 l_219))
(assert (= true (subset0 l_119 l_219)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_119 nil)
(assert (= l_119 nil))
(check-sat)
; Query: (= true (subset0 (map0 f16 l_119) (map0 f16 l_219)))
(push)
(assert (not (= true (subset0 (map0 f16 l_119) (map0 f16 l_219)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h96 () Inductive)
(declare-fun t96 () Inductive)
(push)
(push)
; Assume: (= l_119 (cons h96 t96))
(assert (= l_119 (cons h96 t96)))
(check-sat)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem h96 l_219) true)
(push)
(assert (not (= (mem h96 l_219) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f16 h96) (map0 f16 l_219)) true)
(assert (= (mem (_@ f16 h96) (map0 f16 l_219)) true))
(check-sat)
; Query: (= true (subset0 t96 l_219))
(push)
(assert (not (= true (subset0 t96 l_219))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (map0 f16 t96) (map0 f16 l_219)))
(assert (= true (subset0 (map0 f16 t96) (map0 f16 l_219))))
(check-sat)
; Query: (= true (subset0 (map0 f16 l_119) (map0 f16 l_219)))
(push)
(assert (not (= true (subset0 (map0 f16 l_119) (map0 f16 l_219)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f17 () Inductive)
(declare-fun l32 () Inductive)
(declare-fun currentThread110 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l32 nil)
(assert (= l32 nil))
(check-sat)
; Query: (= true (subset0 (filter f17 l32) l32))
(push)
(assert (not (= true (subset0 (filter f17 l32) l32))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h97 () Inductive)
(declare-fun t97 () Inductive)
(push)
(push)
; Assume: (= l32 (cons h97 t97))
(assert (= l32 (cons h97 t97)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (filter f17 t97) t97))
(assert (= true (subset0 (filter f17 t97) t97)))
(check-sat)
(push)
(push)
; Assume: (unbox_bool (_@ f17 h97))
(assert (unbox_bool (_@ f17 h97)))
(check-sat)
(push)
(push)
; Query: (= (remove h97 (filter f17 l32)) (filter f17 t97))
(push)
(assert (not (= (remove h97 (filter f17 l32)) (filter f17 t97))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (remove h97 (filter f17 l32)) t97))
(push)
(assert (not (= true (subset0 (remove h97 (filter f17 l32)) t97))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (filter f17 l32) (cons h97 t97)))
(assert (= true (subset0 (filter f17 l32) (cons h97 t97))))
(check-sat)
; Query: (= true (subset0 (filter f17 l32) l32))
(push)
(assert (not (= true (subset0 (filter f17 l32) l32))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (unbox_bool (_@ f17 h97)))
(assert (not (unbox_bool (_@ f17 h97))))
(check-sat)
(push)
(push)
; Query: (= true (subset0 (filter f17 l32) t97))
(push)
(assert (not (= true (subset0 (filter f17 l32) t97))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (filter f17 l32) (cons h97 t97)))
(assert (= true (subset0 (filter f17 l32) (cons h97 t97))))
(check-sat)
; Query: (= true (subset0 (filter f17 l32) l32))
(push)
(assert (not (= true (subset0 (filter f17 l32) l32))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs20 () Inductive)
(declare-fun ys17 () Inductive)
(declare-fun zs3 () Inductive)
(declare-fun currentThread111 () Int)
(push)
(push)
; Assume: (= true (subset0 xs20 zs3))
(assert (= true (subset0 xs20 zs3)))
(check-sat)
(push)
(push)
; Query: (= true (subset0 xs20 zs3))
(push)
(assert (not (= true (subset0 xs20 zs3))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 xs20 (append zs3 ys17)))
(assert (= true (subset0 xs20 (append zs3 ys17))))
(check-sat)
; Query: (= true (subset0 xs20 zs3))
(push)
(assert (not (= true (subset0 xs20 zs3))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 xs20 (append ys17 zs3)))
(assert (= true (subset0 xs20 (append ys17 zs3))))
(check-sat)
; Assert: (< (func_rank subset_refl) 0)
(assert (< (func_rank subset_refl) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (subset0 ys17 ys17) true)
(assert (= (subset0 ys17 ys17) true))
(check-sat)
; Query: (= true (subset0 ys17 ys17))
(push)
(assert (not (= true (subset0 ys17 ys17))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 ys17 (append zs3 ys17)))
(assert (= true (subset0 ys17 (append zs3 ys17))))
(check-sat)
; Query: (= true (subset0 ys17 ys17))
(push)
(assert (not (= true (subset0 ys17 ys17))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 ys17 (append ys17 zs3)))
(assert (= true (subset0 ys17 (append ys17 zs3))))
(check-sat)
; Query: (= true (subset0 xs20 (append zs3 ys17)))
(push)
(assert (not (= true (subset0 xs20 (append zs3 ys17)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 ys17 (append zs3 ys17)))
(push)
(assert (not (= true (subset0 ys17 (append zs3 ys17)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (append xs20 ys17) (append zs3 ys17)))
(assert (= true (subset0 (append xs20 ys17) (append zs3 ys17))))
(check-sat)
; Query: (= true (subset0 xs20 (append ys17 zs3)))
(push)
(assert (not (= true (subset0 xs20 (append ys17 zs3)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 ys17 (append ys17 zs3)))
(push)
(assert (not (= true (subset0 ys17 (append ys17 zs3)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (append xs20 ys17) (append ys17 zs3)))
(assert (= true (subset0 (append xs20 ys17) (append ys17 zs3))))
(check-sat)
; Query: (= true (subset0 ys17 (append zs3 ys17)))
(push)
(assert (not (= true (subset0 ys17 (append zs3 ys17)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 xs20 (append zs3 ys17)))
(push)
(assert (not (= true (subset0 xs20 (append zs3 ys17)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (append ys17 xs20) (append zs3 ys17)))
(assert (= true (subset0 (append ys17 xs20) (append zs3 ys17))))
(check-sat)
; Query: (= true (subset0 ys17 (append ys17 zs3)))
(push)
(assert (not (= true (subset0 ys17 (append ys17 zs3)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 xs20 (append ys17 zs3)))
(push)
(assert (not (= true (subset0 xs20 (append ys17 zs3)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (append ys17 xs20) (append ys17 zs3)))
(assert (= true (subset0 (append ys17 xs20) (append ys17 zs3))))
(check-sat)
; Query: (= true (subset0 (append xs20 ys17) (append zs3 ys17)))
(push)
(assert (not (= true (subset0 (append xs20 ys17) (append zs3 ys17)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (append xs20 ys17) (append ys17 zs3)))
(push)
(assert (not (= true (subset0 (append xs20 ys17) (append ys17 zs3)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (append ys17 xs20) (append zs3 ys17)))
(push)
(assert (not (= true (subset0 (append ys17 xs20) (append zs3 ys17)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (append ys17 xs20) (append ys17 zs3)))
(push)
(assert (not (= true (subset0 (append ys17 xs20) (append ys17 zs3)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_120 () Inductive)
(declare-fun l_220 () Inductive)
(declare-fun x15 () Inductive)
(declare-fun currentThread112 () Int)
(push)
(push)
; Assume: (= true (set_eq l_120 l_220))
(assert (= true (set_eq l_120 l_220)))
(check-sat)
(push)
; Assume: (= false (mem x15 (remove x15 l_120)))
(assert (= false (mem x15 (remove x15 l_120))))
(check-sat)
(push)
; Assume: (= false (mem x15 (remove x15 l_220)))
(assert (= false (mem x15 (remove x15 l_220))))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_120 l_220))
(push)
(assert (not (= true (subset0 l_120 l_220))))
(check-sat)
(pop 1)
; Query: (= false (mem x15 (remove x15 l_120)))
(push)
(assert (not (= false (mem x15 (remove x15 l_120)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (remove x15 l_120) (remove x15 l_220)))
(assert (= true (subset0 (remove x15 l_120) (remove x15 l_220))))
(check-sat)
; Query: (= true (subset0 l_220 l_120))
(push)
(assert (not (= true (subset0 l_220 l_120))))
(check-sat)
(pop 1)
; Query: (= false (mem x15 (remove x15 l_220)))
(push)
(assert (not (= false (mem x15 (remove x15 l_220)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (remove x15 l_220) (remove x15 l_120)))
(assert (= true (subset0 (remove x15 l_220) (remove x15 l_120))))
(check-sat)
; Query: (= true (set_eq (remove x15 l_120) (remove x15 l_220)))
(push)
(assert (not (= true (set_eq (remove x15 l_120) (remove x15 l_220)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_121 () Inductive)
(declare-fun l_221 () Inductive)
(declare-fun x16 () Inductive)
(declare-fun currentThread113 () Int)
(push)
(push)
; Assume: (= true (set_eq l_121 l_221))
(assert (= true (set_eq l_121 l_221)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_121))
(assert (= true (distinct0 l_121)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_221))
(assert (= true (distinct0 l_221)))
(check-sat)
(push)
(push)
; Query: (= true (distinct0 l_121))
(push)
(assert (not (= true (distinct0 l_121))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem x16 (remove x16 l_121)))
(assert (= false (mem x16 (remove x16 l_121))))
(check-sat)
; Query: (= true (distinct0 l_221))
(push)
(assert (not (= true (distinct0 l_221))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem x16 (remove x16 l_221)))
(assert (= false (mem x16 (remove x16 l_221))))
(check-sat)
; Query: (= true (set_eq l_121 l_221))
(push)
(assert (not (= true (set_eq l_121 l_221))))
(check-sat)
(pop 1)
; Query: (= false (mem x16 (remove x16 l_121)))
(push)
(assert (not (= false (mem x16 (remove x16 l_121)))))
(check-sat)
(pop 1)
; Query: (= false (mem x16 (remove x16 l_221)))
(push)
(assert (not (= false (mem x16 (remove x16 l_221)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (set_eq (remove x16 l_121) (remove x16 l_221)))
(assert (= true (set_eq (remove x16 l_121) (remove x16 l_221))))
(check-sat)
; Query: (= true (set_eq (remove x16 l_121) (remove x16 l_221)))
(push)
(assert (not (= true (set_eq (remove x16 l_121) (remove x16 l_221)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l33 () Inductive)
(declare-fun currentThread114 () Int)
(push)
(push)
; Assume: (= true (subset0 l33 nil))
(assert (= true (subset0 l33 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l33 nil)
(assert (= l33 nil))
(check-sat)
; Query: (= l33 nil)
(push)
(assert (not (= l33 nil)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h98 () Inductive)
(declare-fun t98 () Inductive)
(push)
(push)
; Assume: (= l33 (cons h98 t98))
(assert (= l33 (cons h98 t98)))
(check-sat)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_122 () Inductive)
(declare-fun l_222 () Inductive)
(declare-fun currentThread115 () Int)
(push)
(push)
; Assume: (= true (set_eq l_122 l_222))
(assert (= true (set_eq l_122 l_222)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_122))
(assert (= true (distinct0 l_122)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_222))
(assert (= true (distinct0 l_222)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_122 nil)
(assert (= l_122 nil))
(check-sat)
; Query: (= true (subset0 l_222 nil))
(push)
(assert (not (= true (subset0 l_222 nil))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= l_222 nil)
(assert (= l_222 nil))
(check-sat)
; Query: (= (length l_122) (length l_222))
(push)
(assert (not (= (length l_122) (length l_222))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h99 () Inductive)
(declare-fun t99 () Inductive)
(push)
(push)
; Assume: (= l_122 (cons h99 t99))
(assert (= l_122 (cons h99 t99)))
(check-sat)
; Query: (= true (set_eq l_122 l_222))
(push)
(assert (not (= true (set_eq l_122 l_222))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_122))
(push)
(assert (not (= true (distinct0 l_122))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_222))
(push)
(assert (not (= true (distinct0 l_222))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (set_eq (remove h99 l_122) (remove h99 l_222)))
(assert (= true (set_eq (remove h99 l_122) (remove h99 l_222))))
(check-sat)
; Assert: (< (func_rank distinct_remove) 0)
(assert (< (func_rank distinct_remove) 0))
; Query: (= (distinct0 l_222) true)
(push)
(assert (not (= (distinct0 l_222) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (distinct0 (remove h99 l_222)) true)
(assert (= (distinct0 (remove h99 l_222)) true))
(check-sat)
; Query: (= true (set_eq t99 (remove h99 l_222)))
(push)
(assert (not (= true (set_eq t99 (remove h99 l_222)))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 t99))
(push)
(assert (not (= true (distinct0 t99))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 (remove h99 l_222)))
(push)
(assert (not (= true (distinct0 (remove h99 l_222)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (length t99) (length (remove h99 l_222)))
(assert (= (length t99) (length (remove h99 l_222))))
(check-sat)
; Query: (= (length l_122) (length l_222))
(push)
(assert (not (= (length l_122) (length l_222))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_123 () Inductive)
(declare-fun l_223 () Inductive)
(declare-fun prop1 () Inductive)
(declare-fun currentThread116 () Int)
(push)
(push)
; Assume: (= true (set_eq l_123 l_223))
(assert (= true (set_eq l_123 l_223)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (forall0 l_123 prop1)
(assert (forall0 l_123 prop1))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_223 l_123))
(push)
(assert (not (= true (subset0 l_223 l_123))))
(check-sat)
(pop 1)
; Query: (= true (forall0 l_123 prop1))
(push)
(assert (not (= true (forall0 l_123 prop1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 l_223 prop1))
(assert (= true (forall0 l_223 prop1)))
(check-sat)
(push)
(push)
; Assume: (forall0 l_223 prop1)
(assert (forall0 l_223 prop1))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_123 l_223))
(push)
(assert (not (= true (subset0 l_123 l_223))))
(check-sat)
(pop 1)
; Query: (= true (forall0 l_223 prop1))
(push)
(assert (not (= true (forall0 l_223 prop1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 l_123 prop1))
(assert (= true (forall0 l_123 prop1)))
(check-sat)
; Query: (= (forall0 l_123 prop1) (forall0 l_223 prop1))
(push)
(assert (not (= (forall0 l_123 prop1) (forall0 l_223 prop1))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (forall0 l_223 prop1))
(assert (not (forall0 l_223 prop1)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (forall0 l_123 prop1))
(assert (not (forall0 l_123 prop1)))
(check-sat)
(push)
(push)
(push)
; Assume: (forall0 l_223 prop1)
(assert (forall0 l_223 prop1))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_123 l_223))
(push)
(assert (not (= true (subset0 l_123 l_223))))
(check-sat)
(pop 1)
; Query: (= true (forall0 l_223 prop1))
(push)
(assert (not (= true (forall0 l_223 prop1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 l_123 prop1))
(assert (= true (forall0 l_123 prop1)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (forall0 l_223 prop1))
(assert (not (forall0 l_223 prop1)))
(check-sat)
(push)
; Query: (= (forall0 l_123 prop1) (forall0 l_223 prop1))
(push)
(assert (not (= (forall0 l_123 prop1) (forall0 l_223 prop1))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_124 () Inductive)
(declare-fun l_224 () Inductive)
(declare-fun f18 () Inductive)
(declare-fun currentThread117 () Int)
(push)
(push)
; Assume: (= true (set_eq l_124 l_224))
(assert (= true (set_eq l_124 l_224)))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_124 l_224))
(push)
(assert (not (= true (subset0 l_124 l_224))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (map0 f18 l_124) (map0 f18 l_224)))
(assert (= true (subset0 (map0 f18 l_124) (map0 f18 l_224))))
(check-sat)
; Query: (= true (subset0 l_224 l_124))
(push)
(assert (not (= true (subset0 l_224 l_124))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (map0 f18 l_224) (map0 f18 l_124)))
(assert (= true (subset0 (map0 f18 l_224) (map0 f18 l_124))))
(check-sat)
; Query: (= true (set_eq (map0 f18 l_124) (map0 f18 l_224)))
(push)
(assert (not (= true (set_eq (map0 f18 l_124) (map0 f18 l_224)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_125 () Inductive)
(declare-fun l_225 () Inductive)
(declare-fun currentThread118 () Int)
(push)
(push)
; Assume: (= true (subset0 l_125 l_225))
(assert (= true (subset0 l_125 l_225)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_125))
(assert (= true (distinct0 l_125)))
(check-sat)
(push)
; Assume: (= false (distinct0 l_225))
(assert (= false (distinct0 l_225)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_125 nil)
(assert (= l_125 nil))
(check-sat)
(push)
(push)
; Assume: (= l_225 nil)
(assert (= l_225 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h100 () Inductive)
(declare-fun t100 () Inductive)
(push)
(push)
; Assume: (= l_225 (cons h100 t100))
(assert (= l_225 (cons h100 t100)))
(check-sat)
; Query: (< 0 (length l_225))
(push)
(assert (not (< 0 (length l_225))))
(check-sat)
(pop 1)
; Query: (< (length l_125) (length l_225))
(push)
(assert (not (< (length l_125) (length l_225))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h101 () Inductive)
(declare-fun t101 () Inductive)
(push)
(push)
; Assume: (= l_125 (cons h101 t101))
(assert (= l_125 (cons h101 t101)))
(check-sat)
; Query: (= true (subset0 t101 l_225))
(push)
(assert (not (= true (subset0 t101 l_225))))
(check-sat)
(pop 1)
; Query: (= false (mem h101 t101))
(push)
(assert (not (= false (mem h101 t101))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t101 (remove h101 l_225)))
(assert (= true (subset0 t101 (remove h101 l_225))))
(check-sat)
(push)
(push)
; Assume: (mem h101 (remove h101 l_225))
(assert (mem h101 (remove h101 l_225)))
(check-sat)
(push)
(push)
; Query: (= true (distinct0 l_125))
(push)
(assert (not (= true (distinct0 l_125))))
(check-sat)
(pop 1)
; Query: (= true (subset0 l_125 (remove h101 l_225)))
(push)
(assert (not (= true (subset0 l_125 (remove h101 l_225)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= (length l_125) (length (remove h101 l_225)))
(assert (<= (length l_125) (length (remove h101 l_225))))
(check-sat)
; Query: (< (length l_125) (length l_225))
(push)
(assert (not (< (length l_125) (length l_225))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem h101 (remove h101 l_225)))
(assert (not (mem h101 (remove h101 l_225))))
(check-sat)
(push)
(push)
; Query: (= false (mem h101 (remove h101 l_225)))
(push)
(assert (not (= false (mem h101 (remove h101 l_225)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (distinct0 l_225) (distinct0 (remove h101 l_225)))
(assert (= (distinct0 l_225) (distinct0 (remove h101 l_225))))
(check-sat)
; Query: (= true (subset0 t101 (remove h101 l_225)))
(push)
(assert (not (= true (subset0 t101 (remove h101 l_225)))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 t101))
(push)
(assert (not (= true (distinct0 t101))))
(check-sat)
(pop 1)
; Query: (= false (distinct0 (remove h101 l_225)))
(push)
(assert (not (= false (distinct0 (remove h101 l_225)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (< (length t101) (length (remove h101 l_225)))
(assert (< (length t101) (length (remove h101 l_225))))
(check-sat)
; Query: (< (length l_125) (length l_225))
(push)
(assert (not (< (length l_125) (length l_225))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_126 () Inductive)
(declare-fun l_226 () Inductive)
(declare-fun currentThread119 () Int)
(push)
(push)
; Assume: (= true (set_eq l_126 l_226))
(assert (= true (set_eq l_126 l_226)))
(check-sat)
(push)
; Assume: (= (length l_126) (length l_226))
(assert (= (length l_126) (length l_226)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (distinct0 l_126)
(assert (distinct0 l_126))
(check-sat)
(push)
(push)
; Assume: (not (distinct0 l_226))
(assert (not (distinct0 l_226)))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_126 l_226))
(push)
(assert (not (= true (subset0 l_126 l_226))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_126))
(push)
(assert (not (= true (distinct0 l_126))))
(check-sat)
(pop 1)
; Query: (= false (distinct0 l_226))
(push)
(assert (not (= false (distinct0 l_226))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (< (length l_126) (length l_226))
(assert (< (length l_126) (length l_226)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (distinct0 l_226)))
(assert (not (not (distinct0 l_226))))
(check-sat)
(push)
(push)
(push)
; Assume: (not (distinct0 l_126))
(assert (not (distinct0 l_126)))
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (distinct0 l_126)))
(assert (not (not (distinct0 l_126))))
(check-sat)
(push)
(push)
; Assume: false
(assert false)
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not false)
(assert (not false))
(check-sat)
(push)
; Query: (= (distinct0 l_126) (distinct0 l_226))
(push)
(assert (not (= (distinct0 l_126) (distinct0 l_226))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (distinct0 l_126))
(assert (not (distinct0 l_126)))
(check-sat)
(push)
(push)
; Assume: false
(assert false)
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not false)
(assert (not false))
(check-sat)
(push)
(push)
(push)
; Assume: (not (distinct0 l_126))
(assert (not (distinct0 l_126)))
(check-sat)
(push)
(push)
; Assume: (distinct0 l_226)
(assert (distinct0 l_226))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_226 l_126))
(push)
(assert (not (= true (subset0 l_226 l_126))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_226))
(push)
(assert (not (= true (distinct0 l_226))))
(check-sat)
(pop 1)
; Query: (= false (distinct0 l_126))
(push)
(assert (not (= false (distinct0 l_126))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (< (length l_226) (length l_126))
(assert (< (length l_226) (length l_126)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (distinct0 l_226))
(assert (not (distinct0 l_226)))
(check-sat)
(push)
; Query: (= (distinct0 l_126) (distinct0 l_226))
(push)
(assert (not (= (distinct0 l_126) (distinct0 l_226))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (distinct0 l_126)))
(assert (not (not (distinct0 l_126))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_127 () Inductive)
(declare-fun l_227 () Inductive)
(declare-fun currentThread120 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_227 nil)
(assert (= l_227 nil))
(check-sat)
; Query: (= true (subset0 (intersection0 l_127 l_227) l_127))
(push)
(assert (not (= true (subset0 (intersection0 l_127 l_227) l_127))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (intersection0 l_127 l_227) l_227))
(push)
(assert (not (= true (subset0 (intersection0 l_127 l_227) l_227))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h102 () Inductive)
(declare-fun t102 () Inductive)
(push)
(push)
; Assume: (= l_227 (cons h102 t102))
(assert (= l_227 (cons h102 t102)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (intersection0 l_127 t102) l_127))
(assert (= true (subset0 (intersection0 l_127 t102) l_127)))
(check-sat)
(push)
; Assume: (= true (subset0 (intersection0 l_127 t102) t102))
(assert (= true (subset0 (intersection0 l_127 t102) t102)))
(check-sat)
(push)
(push)
; Assume: (contains l_127 h102)
(assert (contains l_127 h102))
(check-sat)
(push)
(push)
; Query: (= true (subset0 (remove h102 (intersection0 l_127 l_227)) t102))
(push)
(assert
   (not (= true (subset0 (remove h102 (intersection0 l_127 l_227)) t102))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (intersection0 l_127 l_227) (cons h102 t102)))
(assert (= true (subset0 (intersection0 l_127 l_227) (cons h102 t102))))
(check-sat)
; Query: (= true (subset0 (intersection0 l_127 l_227) l_127))
(push)
(assert (not (= true (subset0 (intersection0 l_127 l_227) l_127))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (intersection0 l_127 l_227) l_227))
(push)
(assert (not (= true (subset0 (intersection0 l_127 l_227) l_227))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (contains l_127 h102))
(assert (not (contains l_127 h102)))
(check-sat)
(push)
(push)
; Query: (= true (subset0 (intersection0 l_127 l_227) t102))
(push)
(assert (not (= true (subset0 (intersection0 l_127 l_227) t102))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (intersection0 l_127 l_227) (cons h102 t102)))
(assert (= true (subset0 (intersection0 l_127 l_227) (cons h102 t102))))
(check-sat)
; Query: (= true (subset0 (intersection0 l_127 l_227) l_127))
(push)
(assert (not (= true (subset0 (intersection0 l_127 l_227) l_127))))
(check-sat)
(pop 1)
; Query: (= true (subset0 (intersection0 l_127 l_227) l_227))
(push)
(assert (not (= true (subset0 (intersection0 l_127 l_227) l_227))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs21 () Inductive)
(declare-fun ys18 () Inductive)
(declare-fun el22 () Inductive)
(declare-fun currentThread121 () Int)
(push)
(push)
; Assume: (= true (subset0 xs21 (remove el22 ys18)))
(assert (= true (subset0 xs21 (remove el22 ys18))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs21 nil)
(assert (= xs21 nil))
(check-sat)
; Query: (= true (subset0 xs21 ys18))
(push)
(assert (not (= true (subset0 xs21 ys18))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h103 () Inductive)
(declare-fun t103 () Inductive)
(push)
(push)
; Assume: (= xs21 (cons h103 t103))
(assert (= xs21 (cons h103 t103)))
(check-sat)
(push)
(push)
; Assume: (not (= h103 el22))
(assert (not (= h103 el22)))
(check-sat)
(push)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h103 el22))
(push)
(assert (not (not (= h103 el22))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h103 (remove el22 t103)) (mem h103 t103))
(assert (= (mem h103 (remove el22 t103)) (mem h103 t103)))
(check-sat)
; Query: (= true (subset0 t103 (remove el22 ys18)))
(push)
(assert (not (= true (subset0 t103 (remove el22 ys18)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t103 ys18))
(assert (= true (subset0 t103 ys18)))
(check-sat)
; Assert: (< (func_rank mem_remove_mem) 0)
(assert (< (func_rank mem_remove_mem) 0))
; Query: (= (mem h103 (remove el22 ys18)) true)
(push)
(assert (not (= (mem h103 (remove el22 ys18)) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h103 ys18) true)
(assert (= (mem h103 ys18) true))
(check-sat)
; Query: (= true (subset0 xs21 ys18))
(push)
(assert (not (= true (subset0 xs21 ys18))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h103 el22)))
(assert (not (not (= h103 el22))))
(check-sat)
(push)
; Query: (= true (subset0 t103 (remove el22 ys18)))
(push)
(assert (not (= true (subset0 t103 (remove el22 ys18)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t103 ys18))
(assert (= true (subset0 t103 ys18)))
(check-sat)
; Assert: (< (func_rank mem_remove_mem) 0)
(assert (< (func_rank mem_remove_mem) 0))
; Query: (= (mem h103 (remove el22 ys18)) true)
(push)
(assert (not (= (mem h103 (remove el22 ys18)) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h103 ys18) true)
(assert (= (mem h103 ys18) true))
(check-sat)
; Query: (= true (subset0 xs21 ys18))
(push)
(assert (not (= true (subset0 xs21 ys18))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun s_1 () Inductive)
(declare-fun s_2 () Inductive)
(declare-fun s_3 () Inductive)
(declare-fun currentThread122 () Int)
(push)
(push)
; Assume: (= true (set_eq s_1 s_2))
(assert (= true (set_eq s_1 s_2)))
(check-sat)
(push)
; Assume: (= true (set_eq s_2 s_3))
(assert (= true (set_eq s_2 s_3)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank subset_trans) 0)
(assert (< (func_rank subset_trans) 0))
; Query: (= (subset0 s_1 s_2) true)
(push)
(assert (not (= (subset0 s_1 s_2) true)))
(check-sat)
(pop 1)
; Query: (= (subset0 s_2 s_3) true)
(push)
(assert (not (= (subset0 s_2 s_3) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (subset0 s_1 s_3) true)
(assert (= (subset0 s_1 s_3) true))
(check-sat)
; Assert: (< (func_rank subset_trans) 0)
(assert (< (func_rank subset_trans) 0))
; Query: (= (subset0 s_3 s_2) true)
(push)
(assert (not (= (subset0 s_3 s_2) true)))
(check-sat)
(pop 1)
; Query: (= (subset0 s_2 s_1) true)
(push)
(assert (not (= (subset0 s_2 s_1) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (subset0 s_3 s_1) true)
(assert (= (subset0 s_3 s_1) true))
(check-sat)
; Query: (= true (set_eq s_1 s_3))
(push)
(assert (not (= true (set_eq s_1 s_3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_128 () Inductive)
(declare-fun l_228 () Inductive)
(declare-fun el23 () Inductive)
(declare-fun currentThread123 () Int)
(push)
(push)
; Assume: (= true (set_eq l_128 l_228))
(assert (= true (set_eq l_128 l_228)))
(check-sat)
(push)
(push)
; Query: (= true (subset0 l_128 (remove el23 (cons el23 l_228))))
(push)
(assert (not (= true (subset0 l_128 (remove el23 (cons el23 l_228))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 l_128 (cons el23 l_228)))
(assert (= true (subset0 l_128 (cons el23 l_228))))
(check-sat)
; Query: (= true (subset0 l_228 (remove el23 (cons el23 l_128))))
(push)
(assert (not (= true (subset0 l_228 (remove el23 (cons el23 l_128))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 l_228 (cons el23 l_128)))
(assert (= true (subset0 l_228 (cons el23 l_128))))
(check-sat)
; Query: (= true (set_eq (cons el23 l_128) (cons el23 l_228)))
(push)
(assert (not (= true (set_eq (cons el23 l_128) (cons el23 l_228)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(declare-fun msubset (Inductive Inductive) Bool)
(declare-fun _@msubset () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@msubset var) var0)) (msubset var var0))
         :pattern ((_@ (_@ _@msubset var) var0)))))
(declare-fun msubset_refl () Int)
(declare-fun msubset_of_nil () Int)
(declare-fun msubset_remove_cons_swap () Int)
(declare-fun msubset_remove () Int)
(declare-fun msubset_unremove () Int)
(declare-fun msubset_subset () Int)
(declare-fun msubset_trans () Int)
(declare-fun msubset_cons_preserves () Int)
(declare-fun filter_msubset () Int)
(declare-fun msubset_distinct () Int)
(declare-fun msubset_unremove_outer () Int)
(declare-fun msubset_remove_lesser () Int)
(declare-fun msubset_map_remove_swap () Int)
(declare-fun msubset_map () Int)
(declare-fun msubset_append_left () Int)
(declare-fun msubset_append_right () Int)
(declare-fun msubset_append () Int)
(declare-fun msubset_append_both () Int)
(declare-fun msubset_forall () Int)
(declare-fun msubset_lift_cons () Int)
(declare-fun msubset_bury_cons () Int)
(declare-fun msubset_move_cons_to_the_middle_keep () Int)
(declare-fun msubset_remove_append_cons_keep () Int)
(declare-fun msubset_append_swap () Int)
(declare-fun msubset_length () Int)
(declare-fun msubset_push_to_the_end_self () Int)
(declare-fun msubset_push_to_the_end () Int)
(declare-fun push_to_the_end_msubset () Int)
(declare-fun pull_to_start_msubset () Int)
(declare-fun pull_to_start_msubset_2 () Int)
(declare-fun msubset_filter () Int)
(declare-fun distinct_subset_msubset () Int)
(declare-fun msubset_same_len_eq () Int)
; set_fpclauses
; function msubset
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (msubset (cons var var0) var1)
            (and (= true (mem var var1)) (msubset var0 (remove var var1))))
         :pattern ((msubset (cons var var0) var1)))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (msubset nil var) true) :pattern ((msubset nil var)))))
; Assert: (= (func_rank msubset_refl) 340)
(assert (= (func_rank msubset_refl) 340))
; Assert: (= (func_rank msubset_of_nil) 341)
(assert (= (func_rank msubset_of_nil) 341))
; Assert: (= (func_rank msubset_remove_cons_swap) 342)
(assert (= (func_rank msubset_remove_cons_swap) 342))
; Assert: (= (func_rank msubset_remove) 343)
(assert (= (func_rank msubset_remove) 343))
; Assert: (= (func_rank msubset_unremove) 344)
(assert (= (func_rank msubset_unremove) 344))
; Assert: (= (func_rank msubset_subset) 345)
(assert (= (func_rank msubset_subset) 345))
; Assert: (= (func_rank msubset_trans) 346)
(assert (= (func_rank msubset_trans) 346))
; Assert: (= (func_rank msubset_cons_preserves) 347)
(assert (= (func_rank msubset_cons_preserves) 347))
; Assert: (= (func_rank filter_msubset) 348)
(assert (= (func_rank filter_msubset) 348))
; Assert: (= (func_rank msubset_distinct) 349)
(assert (= (func_rank msubset_distinct) 349))
; Assert: (= (func_rank msubset_unremove_outer) 350)
(assert (= (func_rank msubset_unremove_outer) 350))
; Assert: (= (func_rank msubset_remove_lesser) 351)
(assert (= (func_rank msubset_remove_lesser) 351))
; Assert: (= (func_rank msubset_map_remove_swap) 352)
(assert (= (func_rank msubset_map_remove_swap) 352))
; Assert: (= (func_rank msubset_map) 353)
(assert (= (func_rank msubset_map) 353))
; Assert: (= (func_rank msubset_append_left) 354)
(assert (= (func_rank msubset_append_left) 354))
; Assert: (= (func_rank msubset_append_right) 355)
(assert (= (func_rank msubset_append_right) 355))
; Assert: (= (func_rank msubset_append) 356)
(assert (= (func_rank msubset_append) 356))
; Assert: (= (func_rank msubset_append_both) 357)
(assert (= (func_rank msubset_append_both) 357))
; Assert: (= (func_rank msubset_forall) 358)
(assert (= (func_rank msubset_forall) 358))
; Assert: (= (func_rank msubset_lift_cons) 359)
(assert (= (func_rank msubset_lift_cons) 359))
; Assert: (= (func_rank msubset_bury_cons) 360)
(assert (= (func_rank msubset_bury_cons) 360))
; Assert: (= (func_rank msubset_move_cons_to_the_middle_keep) 361)
(assert (= (func_rank msubset_move_cons_to_the_middle_keep) 361))
; Assert: (= (func_rank msubset_remove_append_cons_keep) 362)
(assert (= (func_rank msubset_remove_append_cons_keep) 362))
; Assert: (= (func_rank msubset_append_swap) 363)
(assert (= (func_rank msubset_append_swap) 363))
; Assert: (= (func_rank msubset_length) 364)
(assert (= (func_rank msubset_length) 364))
; Assert: (= (func_rank msubset_push_to_the_end_self) 365)
(assert (= (func_rank msubset_push_to_the_end_self) 365))
; Assert: (= (func_rank msubset_push_to_the_end) 366)
(assert (= (func_rank msubset_push_to_the_end) 366))
; Assert: (= (func_rank push_to_the_end_msubset) 367)
(assert (= (func_rank push_to_the_end_msubset) 367))
; Assert: (= (func_rank pull_to_start_msubset) 368)
(assert (= (func_rank pull_to_start_msubset) 368))
; Assert: (= (func_rank pull_to_start_msubset_2) 369)
(assert (= (func_rank pull_to_start_msubset_2) 369))
; Assert: (= (func_rank msubset_filter) 370)
(assert (= (func_rank msubset_filter) 370))
; Assert: (= (func_rank distinct_subset_msubset) 371)
(assert (= (func_rank distinct_subset_msubset) 371))
; Assert: (= (func_rank msubset_same_len_eq) 372)
(assert (= (func_rank msubset_same_len_eq) 372))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(push)
(declare-fun l34 () Inductive)
(declare-fun currentThread124 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l34 nil)
(assert (= l34 nil))
(check-sat)
; Query: (= true (msubset l34 l34))
(push)
(assert (not (= true (msubset l34 l34))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h104 () Inductive)
(declare-fun t104 () Inductive)
(push)
(push)
; Assume: (= l34 (cons h104 t104))
(assert (= l34 (cons h104 t104)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t104 t104))
(assert (= true (msubset t104 t104)))
(check-sat)
; Query: (= true (msubset l34 l34))
(push)
(assert (not (= true (msubset l34 l34))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l35 () Inductive)
(declare-fun currentThread125 () Int)
(push)
(push)
; Assume: (= true (msubset l35 nil))
(assert (= true (msubset l35 nil)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l35 nil)
(assert (= l35 nil))
(check-sat)
; Query: (= l35 nil)
(push)
(assert (not (= l35 nil)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h105 () Inductive)
(declare-fun t105 () Inductive)
(push)
(push)
; Assume: (= l35 (cons h105 t105))
(assert (= l35 (cons h105 t105)))
(check-sat)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x17 () Inductive)
(declare-fun y0 () Inductive)
(declare-fun l36 () Inductive)
(declare-fun currentThread126 () Int)
(push)
(push)
; Assume: (= true (mem x17 l36))
(assert (= true (mem x17 l36)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l36 nil)
(assert (= l36 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h106 () Inductive)
(declare-fun t106 () Inductive)
(push)
(push)
; Assume: (= l36 (cons h106 t106))
(assert (= l36 (cons h106 t106)))
(check-sat)
(push)
(push)
; Assume: (not (= h106 x17))
(assert (not (= h106 x17)))
(check-sat)
(push)
(push)
; Query: (= true (mem x17 t106))
(push)
(assert (not (= true (mem x17 t106))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove x17 (cons y0 t106)) (cons y0 (remove x17 t106))))
(assert
   (= true (msubset (remove x17 (cons y0 t106)) (cons y0 (remove x17 t106)))))
(check-sat)
(push)
; Assume: (= true (msubset (cons y0 (remove x17 t106)) (remove x17 (cons y0 t106))))
(assert
   (= true (msubset (cons y0 (remove x17 t106)) (remove x17 (cons y0 t106)))))
(check-sat)
; Query: (= true (msubset (remove x17 (cons y0 l36)) (cons y0 (remove x17 l36))))
(push)
(assert
   (not
      (= true
         (msubset (remove x17 (cons y0 l36)) (cons y0 (remove x17 l36))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons y0 (remove x17 l36)) (remove x17 (cons y0 l36))))
(push)
(assert
   (not
      (= true
         (msubset (cons y0 (remove x17 l36)) (remove x17 (cons y0 l36))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h106 x17)))
(assert (not (not (= h106 x17))))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t106 t106))
(assert (= true (msubset t106 t106)))
(check-sat)
; Query: (= (remove x17 l36) t106)
(push)
(assert (not (= (remove x17 l36) t106)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= y0 x17)
(assert (= y0 x17))
(check-sat)
(push)
(push)
; Query: (= true (msubset (remove x17 (cons y0 l36)) (cons y0 (remove x17 l36))))
(push)
(assert
   (not
      (= true
         (msubset (remove x17 (cons y0 l36)) (cons y0 (remove x17 l36))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons y0 (remove x17 l36)) (remove x17 (cons y0 l36))))
(push)
(assert
   (not
      (= true
         (msubset (cons y0 (remove x17 l36)) (remove x17 (cons y0 l36))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= y0 x17))
(assert (not (= y0 x17)))
(check-sat)
(push)
(push)
; Query: (= true (msubset (remove x17 (cons y0 l36)) (cons y0 (remove x17 l36))))
(push)
(assert
   (not
      (= true
         (msubset (remove x17 (cons y0 l36)) (cons y0 (remove x17 l36))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons y0 (remove x17 l36)) (remove x17 (cons y0 l36))))
(push)
(assert
   (not
      (= true
         (msubset (cons y0 (remove x17 l36)) (remove x17 (cons y0 l36))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_129 () Inductive)
(declare-fun l_229 () Inductive)
(declare-fun x18 () Inductive)
(declare-fun currentThread127 () Int)
(push)
(push)
; Assume: (= true (msubset l_129 l_229))
(assert (= true (msubset l_129 l_229)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_129 nil)
(assert (= l_129 nil))
(check-sat)
; Query: (= true (msubset (remove x18 l_129) (remove x18 l_229)))
(push)
(assert (not (= true (msubset (remove x18 l_129) (remove x18 l_229)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h107 () Inductive)
(declare-fun t107 () Inductive)
(push)
(push)
; Assume: (= l_129 (cons h107 t107))
(assert (= l_129 (cons h107 t107)))
(check-sat)
(push)
(push)
; Assume: (= h107 x18)
(assert (= h107 x18))
(check-sat)
(push)
(push)
; Query: (= true (msubset (remove x18 l_129) (remove x18 l_229)))
(push)
(assert (not (= true (msubset (remove x18 l_129) (remove x18 l_229)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h107 x18))
(assert (not (= h107 x18)))
(check-sat)
(push)
(push)
; Query: (= true (msubset t107 (remove h107 l_229)))
(push)
(assert (not (= true (msubset t107 (remove h107 l_229)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove x18 t107) (remove x18 (remove h107 l_229))))
(assert
   (= true (msubset (remove x18 t107) (remove x18 (remove h107 l_229)))))
(check-sat)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h107 x18))
(push)
(assert (not (not (= h107 x18))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h107 (remove x18 l_229)) (mem h107 l_229))
(assert (= (mem h107 (remove x18 l_229)) (mem h107 l_229)))
(check-sat)
; Assert: (< (func_rank remove_commutes) 0)
(assert (< (func_rank remove_commutes) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h107 (remove x18 l_229)) (remove x18 (remove h107 l_229)))
(assert
   (= (remove h107 (remove x18 l_229)) (remove x18 (remove h107 l_229))))
(check-sat)
; Query: (= true (msubset (remove x18 l_129) (remove x18 l_229)))
(push)
(assert (not (= true (msubset (remove x18 l_129) (remove x18 l_229)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_130 () Inductive)
(declare-fun l_230 () Inductive)
(declare-fun x19 () Inductive)
(declare-fun currentThread128 () Int)
(push)
(push)
; Assume: (= true (mem x19 l_230))
(assert (= true (mem x19 l_230)))
(check-sat)
(push)
; Assume: (= true (msubset (remove x19 l_130) (remove x19 l_230)))
(assert (= true (msubset (remove x19 l_130) (remove x19 l_230))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_130 nil)
(assert (= l_130 nil))
(check-sat)
; Query: (= true (msubset l_130 l_230))
(push)
(assert (not (= true (msubset l_130 l_230))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h108 () Inductive)
(declare-fun t108 () Inductive)
(push)
(push)
; Assume: (= l_130 (cons h108 t108))
(assert (= l_130 (cons h108 t108)))
(check-sat)
(push)
(push)
; Assume: (= h108 x19)
(assert (= h108 x19))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_130 l_230))
(push)
(assert (not (= true (msubset l_130 l_230))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h108 x19))
(assert (not (= h108 x19)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= x19 h108))
(push)
(assert (not (not (= x19 h108))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem x19 (remove h108 l_230)) (mem x19 l_230))
(assert (= (mem x19 (remove h108 l_230)) (mem x19 l_230)))
(check-sat)
; Assert: (< (func_rank remove_commutes) 0)
(assert (< (func_rank remove_commutes) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h108 (remove x19 l_230)) (remove x19 (remove h108 l_230)))
(assert
   (= (remove h108 (remove x19 l_230)) (remove x19 (remove h108 l_230))))
(check-sat)
; Query: (= true (mem x19 (remove h108 l_230)))
(push)
(assert (not (= true (mem x19 (remove h108 l_230)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (remove x19 t108) (remove x19 (remove h108 l_230))))
(push)
(assert
   (not
      (= true (msubset (remove x19 t108) (remove x19 (remove h108 l_230))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t108 (remove h108 l_230)))
(assert (= true (msubset t108 (remove h108 l_230))))
(check-sat)
; Assert: (< (func_rank mem_remove_mem) 0)
(assert (< (func_rank mem_remove_mem) 0))
; Query: (= (mem h108 (remove x19 l_230)) true)
(push)
(assert (not (= (mem h108 (remove x19 l_230)) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h108 l_230) true)
(assert (= (mem h108 l_230) true))
(check-sat)
; Query: (= true (msubset l_130 l_230))
(push)
(assert (not (= true (msubset l_130 l_230))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_131 () Inductive)
(declare-fun l_231 () Inductive)
(declare-fun currentThread129 () Int)
(push)
(push)
; Assume: (= true (msubset l_131 l_231))
(assert (= true (msubset l_131 l_231)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_131 nil)
(assert (= l_131 nil))
(check-sat)
; Query: (= true (subset0 l_131 l_231))
(push)
(assert (not (= true (subset0 l_131 l_231))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h109 () Inductive)
(declare-fun t109 () Inductive)
(push)
(push)
; Assume: (= l_131 (cons h109 t109))
(assert (= l_131 (cons h109 t109)))
(check-sat)
; Query: (= true (msubset t109 (remove h109 l_231)))
(push)
(assert (not (= true (msubset t109 (remove h109 l_231)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t109 (remove h109 l_231)))
(assert (= true (subset0 t109 (remove h109 l_231))))
(check-sat)
; Query: (= true (subset0 t109 (remove h109 l_231)))
(push)
(assert (not (= true (subset0 t109 (remove h109 l_231)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t109 l_231))
(assert (= true (subset0 t109 l_231)))
(check-sat)
; Query: (= true (subset0 l_131 l_231))
(push)
(assert (not (= true (subset0 l_131 l_231))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_132 () Inductive)
(declare-fun l_232 () Inductive)
(declare-fun l_35 () Inductive)
(declare-fun currentThread130 () Int)
(push)
(push)
; Assume: (= true (msubset l_132 l_232))
(assert (= true (msubset l_132 l_232)))
(check-sat)
(push)
; Assume: (= true (msubset l_232 l_35))
(assert (= true (msubset l_232 l_35)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_132 nil)
(assert (= l_132 nil))
(check-sat)
; Query: (= true (msubset l_132 l_35))
(push)
(assert (not (= true (msubset l_132 l_35))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h110 () Inductive)
(declare-fun t110 () Inductive)
(push)
(push)
; Assume: (= l_132 (cons h110 t110))
(assert (= l_132 (cons h110 t110)))
(check-sat)
; Query: (= true (msubset l_232 l_35))
(push)
(assert (not (= true (msubset l_232 l_35))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove h110 l_232) (remove h110 l_35)))
(assert (= true (msubset (remove h110 l_232) (remove h110 l_35))))
(check-sat)
; Query: (= true (msubset t110 (remove h110 l_232)))
(push)
(assert (not (= true (msubset t110 (remove h110 l_232)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (remove h110 l_232) (remove h110 l_35)))
(push)
(assert (not (= true (msubset (remove h110 l_232) (remove h110 l_35)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t110 (remove h110 l_35)))
(assert (= true (msubset t110 (remove h110 l_35))))
(check-sat)
; Query: (= true (msubset l_232 l_35))
(push)
(assert (not (= true (msubset l_232 l_35))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 l_232 l_35))
(assert (= true (subset0 l_232 l_35)))
(check-sat)
; Query: (= true (subset0 l_232 l_35))
(push)
(assert (not (= true (subset0 l_232 l_35))))
(check-sat)
(pop 1)
; Query: (= true (mem h110 l_232))
(push)
(assert (not (= true (mem h110 l_232))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem h110 l_35))
(assert (= true (mem h110 l_35)))
(check-sat)
; Query: (= true (msubset l_132 l_35))
(push)
(assert (not (= true (msubset l_132 l_35))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_133 () Inductive)
(declare-fun l_233 () Inductive)
(declare-fun x20 () Inductive)
(declare-fun currentThread131 () Int)
(push)
(push)
; Assume: (= true (msubset l_133 l_233))
(assert (= true (msubset l_133 l_233)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_133 nil)
(assert (= l_133 nil))
(check-sat)
; Query: (= true (msubset l_133 (cons x20 l_233)))
(push)
(assert (not (= true (msubset l_133 (cons x20 l_233)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h111 () Inductive)
(declare-fun t111 () Inductive)
(push)
(push)
; Assume: (= l_133 (cons h111 t111))
(assert (= l_133 (cons h111 t111)))
(check-sat)
; Query: (= true (msubset t111 (remove h111 l_233)))
(push)
(assert (not (= true (msubset t111 (remove h111 l_233)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t111 (cons x20 (remove h111 l_233))))
(assert (= true (msubset t111 (cons x20 (remove h111 l_233)))))
(check-sat)
; Query: (= true (mem h111 l_233))
(push)
(assert (not (= true (mem h111 l_233))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove h111 (cons x20 l_233)) (cons x20 (remove h111 l_233))))
(assert
   (= true
      (msubset (remove h111 (cons x20 l_233)) (cons x20 (remove h111 l_233)))))
(check-sat)
(push)
; Assume: (= true (msubset (cons x20 (remove h111 l_233)) (remove h111 (cons x20 l_233))))
(assert
   (= true
      (msubset (cons x20 (remove h111 l_233)) (remove h111 (cons x20 l_233)))))
(check-sat)
; Query: (= true (msubset t111 (cons x20 (remove h111 l_233))))
(push)
(assert (not (= true (msubset t111 (cons x20 (remove h111 l_233))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons x20 (remove h111 l_233)) (remove h111 (cons x20 l_233))))
(push)
(assert
   (not
      (= true
         (msubset (cons x20 (remove h111 l_233))
            (remove h111 (cons x20 l_233))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t111 (remove h111 (cons x20 l_233))))
(assert (= true (msubset t111 (remove h111 (cons x20 l_233)))))
(check-sat)
; Query: (= true (mem h111 (cons x20 l_233)))
(push)
(assert (not (= true (mem h111 (cons x20 l_233)))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_133 (cons x20 l_233)))
(push)
(assert (not (= true (msubset l_133 (cons x20 l_233)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f19 () Inductive)
(declare-fun l37 () Inductive)
(declare-fun currentThread132 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l37 nil)
(assert (= l37 nil))
(check-sat)
; Query: (= true (msubset (filter f19 l37) l37))
(push)
(assert (not (= true (msubset (filter f19 l37) l37))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h112 () Inductive)
(declare-fun t112 () Inductive)
(push)
(push)
; Assume: (= l37 (cons h112 t112))
(assert (= l37 (cons h112 t112)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (filter f19 t112) t112))
(assert (= true (msubset (filter f19 t112) t112)))
(check-sat)
(push)
(push)
; Assume: (not (unbox_bool (_@ f19 h112)))
(assert (not (unbox_bool (_@ f19 h112))))
(check-sat)
(push)
(push)
; Query: (= true (msubset (filter f19 t112) t112))
(push)
(assert (not (= true (msubset (filter f19 t112) t112))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (filter f19 t112) (cons h112 t112)))
(assert (= true (msubset (filter f19 t112) (cons h112 t112))))
(check-sat)
; Query: (= true (msubset (filter f19 l37) l37))
(push)
(assert (not (= true (msubset (filter f19 l37) l37))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (unbox_bool (_@ f19 h112))))
(assert (not (not (unbox_bool (_@ f19 h112)))))
(check-sat)
(push)
; Query: (= true (msubset (filter f19 l37) l37))
(push)
(assert (not (= true (msubset (filter f19 l37) l37))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_134 () Inductive)
(declare-fun l_234 () Inductive)
(declare-fun currentThread133 () Int)
(push)
(push)
; Assume: (= true (msubset l_134 l_234))
(assert (= true (msubset l_134 l_234)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_234))
(assert (= true (distinct0 l_234)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_134 nil)
(assert (= l_134 nil))
(check-sat)
; Query: (= true (distinct0 l_134))
(push)
(assert (not (= true (distinct0 l_134))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h113 () Inductive)
(declare-fun t113 () Inductive)
(push)
(push)
; Assume: (= l_134 (cons h113 t113))
(assert (= l_134 (cons h113 t113)))
(check-sat)
; Query: (= true (distinct0 l_234))
(push)
(assert (not (= true (distinct0 l_234))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem h113 (remove h113 l_234)))
(assert (= false (mem h113 (remove h113 l_234))))
(check-sat)
; Query: (= true (distinct0 l_234))
(push)
(assert (not (= true (distinct0 l_234))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 (remove h113 l_234)))
(assert (= true (distinct0 (remove h113 l_234))))
(check-sat)
(push)
(push)
; Assume: (mem h113 t113)
(assert (mem h113 t113))
(check-sat)
(push)
(push)
; Query: (= true (msubset t113 (remove h113 l_234)))
(push)
(assert (not (= true (msubset t113 (remove h113 l_234)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t113 (remove h113 l_234)))
(assert (= true (subset0 t113 (remove h113 l_234))))
(check-sat)
; Query: (= true (subset0 t113 (remove h113 l_234)))
(push)
(assert (not (= true (subset0 t113 (remove h113 l_234)))))
(check-sat)
(pop 1)
; Query: (= true (mem h113 t113))
(push)
(assert (not (= true (mem h113 t113))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem h113 (remove h113 l_234)))
(assert (= true (mem h113 (remove h113 l_234))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem h113 t113))
(assert (not (mem h113 t113)))
(check-sat)
(push)
; Query: (= true (msubset t113 (remove h113 l_234)))
(push)
(assert (not (= true (msubset t113 (remove h113 l_234)))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 (remove h113 l_234)))
(push)
(assert (not (= true (distinct0 (remove h113 l_234)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 t113))
(assert (= true (distinct0 t113)))
(check-sat)
; Query: (= true (distinct0 l_134))
(push)
(assert (not (= true (distinct0 l_134))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_135 () Inductive)
(declare-fun l_235 () Inductive)
(declare-fun el24 () Inductive)
(declare-fun currentThread134 () Int)
(push)
(push)
; Assume: (= true (msubset l_135 (remove el24 l_235)))
(assert (= true (msubset l_135 (remove el24 l_235))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_135 nil)
(assert (= l_135 nil))
(check-sat)
; Query: (= true (msubset l_135 l_235))
(push)
(assert (not (= true (msubset l_135 l_235))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h114 () Inductive)
(declare-fun t114 () Inductive)
(push)
(push)
; Assume: (= l_135 (cons h114 t114))
(assert (= l_135 (cons h114 t114)))
(check-sat)
(push)
(push)
; Assume: (= h114 el24)
(assert (= h114 el24))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_135 (remove el24 l_235)))
(push)
(assert (not (= true (msubset l_135 (remove el24 l_235)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_135 (cons el24 (remove el24 l_235))))
(assert (= true (msubset l_135 (cons el24 (remove el24 l_235)))))
(check-sat)
; Assert: (< (func_rank mem_remove_mem) 0)
(assert (< (func_rank mem_remove_mem) 0))
; Query: (= (mem el24 (remove el24 l_235)) true)
(push)
(assert (not (= (mem el24 (remove el24 l_235)) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem el24 l_235) true)
(assert (= (mem el24 l_235) true))
(check-sat)
; Query: (= true (mem el24 l_235))
(push)
(assert (not (= true (mem el24 l_235))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove el24 (cons el24 l_235)) (cons el24 (remove el24 l_235))))
(assert
   (= true
      (msubset (remove el24 (cons el24 l_235))
         (cons el24 (remove el24 l_235)))))
(check-sat)
(push)
; Assume: (= true (msubset (cons el24 (remove el24 l_235)) (remove el24 (cons el24 l_235))))
(assert
   (= true
      (msubset (cons el24 (remove el24 l_235))
         (remove el24 (cons el24 l_235)))))
(check-sat)
; Query: (= true (msubset l_135 (cons el24 (remove el24 l_235))))
(push)
(assert (not (= true (msubset l_135 (cons el24 (remove el24 l_235))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons el24 (remove el24 l_235)) l_235))
(push)
(assert (not (= true (msubset (cons el24 (remove el24 l_235)) l_235))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_135 l_235))
(assert (= true (msubset l_135 l_235)))
(check-sat)
; Query: (= true (msubset l_135 l_235))
(push)
(assert (not (= true (msubset l_135 l_235))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h114 el24))
(assert (not (= h114 el24)))
(check-sat)
(push)
(push)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h114 el24))
(push)
(assert (not (not (= h114 el24))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h114 (remove el24 t114)) (mem h114 t114))
(assert (= (mem h114 (remove el24 t114)) (mem h114 t114)))
(check-sat)
; Assert: (< (func_rank remove_commutes) 0)
(assert (< (func_rank remove_commutes) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el24 (remove h114 l_235)) (remove h114 (remove el24 l_235)))
(assert
   (= (remove el24 (remove h114 l_235)) (remove h114 (remove el24 l_235))))
(check-sat)
; Query: (= true (msubset t114 (remove el24 (remove h114 l_235))))
(push)
(assert (not (= true (msubset t114 (remove el24 (remove h114 l_235))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t114 (remove h114 l_235)))
(assert (= true (msubset t114 (remove h114 l_235))))
(check-sat)
; Assert: (< (func_rank mem_remove_mem) 0)
(assert (< (func_rank mem_remove_mem) 0))
; Query: (= (mem h114 (remove el24 l_235)) true)
(push)
(assert (not (= (mem h114 (remove el24 l_235)) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h114 l_235) true)
(assert (= (mem h114 l_235) true))
(check-sat)
; Query: (= true (msubset l_135 l_235))
(push)
(assert (not (= true (msubset l_135 l_235))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_136 () Inductive)
(declare-fun l_236 () Inductive)
(declare-fun x21 () Inductive)
(declare-fun currentThread135 () Int)
(push)
(push)
; Assume: (= true (msubset l_136 l_236))
(assert (= true (msubset l_136 l_236)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_136 nil)
(assert (= l_136 nil))
(check-sat)
; Query: (= true (msubset (remove x21 l_136) l_236))
(push)
(assert (not (= true (msubset (remove x21 l_136) l_236))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h115 () Inductive)
(declare-fun t115 () Inductive)
(push)
(push)
; Assume: (= l_136 (cons h115 t115))
(assert (= l_136 (cons h115 t115)))
(check-sat)
(push)
(push)
; Assume: (= h115 x21)
(assert (= h115 x21))
(check-sat)
(push)
(push)
; Query: (= true (msubset t115 (remove x21 l_236)))
(push)
(assert (not (= true (msubset t115 (remove x21 l_236)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t115 l_236))
(assert (= true (msubset t115 l_236)))
(check-sat)
; Query: (= true (msubset (remove x21 l_136) l_236))
(push)
(assert (not (= true (msubset (remove x21 l_136) l_236))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h115 x21))
(assert (not (= h115 x21)))
(check-sat)
(push)
(push)
; Query: (= true (msubset t115 (remove h115 l_236)))
(push)
(assert (not (= true (msubset t115 (remove h115 l_236)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove x21 t115) (remove h115 l_236)))
(assert (= true (msubset (remove x21 t115) (remove h115 l_236))))
(check-sat)
; Query: (= true (msubset (remove x21 l_136) l_236))
(push)
(assert (not (= true (msubset (remove x21 l_136) l_236))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el25 () Inductive)
(declare-fun l38 () Inductive)
(declare-fun f20 () Inductive)
(declare-fun currentThread136 () Int)
(push)
(push)
; Assume: (= true (mem el25 l38))
(assert (= true (mem el25 l38)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l38 nil)
(assert (= l38 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h116 () Inductive)
(declare-fun t116 () Inductive)
(push)
(push)
; Assume: (= l38 (cons h116 t116))
(assert (= l38 (cons h116 t116)))
(check-sat)
(push)
(push)
; Assume: (= h116 el25)
(assert (= h116 el25))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (map0 f20 t116) (map0 f20 t116)))
(assert (= true (msubset (map0 f20 t116) (map0 f20 t116))))
(check-sat)
; Query: (= true (msubset (map0 f20 (remove el25 l38)) (remove (_@ f20 el25) (map0 f20 l38))))
(push)
(assert
   (not
      (= true
         (msubset (map0 f20 (remove el25 l38))
            (remove (_@ f20 el25) (map0 f20 l38))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h116 el25))
(assert (not (= h116 el25)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= (_@ f20 h116) (_@ f20 el25))
(assert (= (_@ f20 h116) (_@ f20 el25)))
(check-sat)
(push)
(push)
; Query: (= true (mem el25 t116))
(push)
(assert (not (= true (mem el25 t116))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (map0 f20 (remove el25 t116)) (remove (_@ f20 el25) (map0 f20 t116))))
(assert
   (= true
      (msubset (map0 f20 (remove el25 t116))
         (remove (_@ f20 el25) (map0 f20 t116)))))
(check-sat)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem el25 t116) true)
(push)
(assert (not (= (mem el25 t116) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f20 el25) (map0 f20 t116)) true)
(assert (= (mem (_@ f20 el25) (map0 f20 t116)) true))
(check-sat)
; Query: (= true (mem (_@ f20 el25) (map0 f20 t116)))
(push)
(assert (not (= true (mem (_@ f20 el25) (map0 f20 t116)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove (_@ f20 el25) (cons (_@ f20 el25) (map0 f20 t116))) (cons (_@ f20 el25) (remove (_@ f20 el25) (map0 f20 t116)))))
(assert
   (= true
      (msubset (remove (_@ f20 el25) (cons (_@ f20 el25) (map0 f20 t116)))
         (cons (_@ f20 el25) (remove (_@ f20 el25) (map0 f20 t116))))))
(check-sat)
(push)
; Assume: (= true (msubset (cons (_@ f20 el25) (remove (_@ f20 el25) (map0 f20 t116))) (remove (_@ f20 el25) (cons (_@ f20 el25) (map0 f20 t116)))))
(assert
   (= true
      (msubset (cons (_@ f20 el25) (remove (_@ f20 el25) (map0 f20 t116)))
         (remove (_@ f20 el25) (cons (_@ f20 el25) (map0 f20 t116))))))
(check-sat)
; Query: (= true (msubset (map0 f20 (remove el25 l38)) (cons (_@ f20 el25) (remove (_@ f20 el25) (map0 f20 t116)))))
(push)
(assert
   (not
      (= true
         (msubset (map0 f20 (remove el25 l38))
            (cons (_@ f20 el25) (remove (_@ f20 el25) (map0 f20 t116)))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons (_@ f20 el25) (remove (_@ f20 el25) (map0 f20 t116))) (map0 f20 t116)))
(push)
(assert
   (not
      (= true
         (msubset (cons (_@ f20 el25) (remove (_@ f20 el25) (map0 f20 t116)))
            (map0 f20 t116)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (map0 f20 (remove el25 l38)) (map0 f20 t116)))
(assert (= true (msubset (map0 f20 (remove el25 l38)) (map0 f20 t116))))
(check-sat)
; Query: (= true (msubset (map0 f20 (remove el25 l38)) (remove (_@ f20 el25) (map0 f20 l38))))
(push)
(assert
   (not
      (= true
         (msubset (map0 f20 (remove el25 l38))
            (remove (_@ f20 el25) (map0 f20 l38))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (_@ f20 h116) (_@ f20 el25)))
(assert (not (= (_@ f20 h116) (_@ f20 el25))))
(check-sat)
(push)
(push)
; Query: (= true (mem el25 t116))
(push)
(assert (not (= true (mem el25 t116))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (map0 f20 (remove el25 t116)) (remove (_@ f20 el25) (map0 f20 t116))))
(assert
   (= true
      (msubset (map0 f20 (remove el25 t116))
         (remove (_@ f20 el25) (map0 f20 t116)))))
(check-sat)
; Query: (= true (msubset (map0 f20 (remove el25 l38)) (remove (_@ f20 el25) (map0 f20 l38))))
(push)
(assert
   (not
      (= true
         (msubset (map0 f20 (remove el25 l38))
            (remove (_@ f20 el25) (map0 f20 l38))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f21 () Inductive)
(declare-fun l_137 () Inductive)
(declare-fun l_237 () Inductive)
(declare-fun currentThread137 () Int)
(push)
(push)
; Assume: (= true (msubset l_137 l_237))
(assert (= true (msubset l_137 l_237)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_137 nil)
(assert (= l_137 nil))
(check-sat)
; Query: (= true (msubset (map0 f21 l_137) (map0 f21 l_237)))
(push)
(assert (not (= true (msubset (map0 f21 l_137) (map0 f21 l_237)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h117 () Inductive)
(declare-fun t117 () Inductive)
(push)
(push)
; Assume: (= l_137 (cons h117 t117))
(assert (= l_137 (cons h117 t117)))
(check-sat)
; Query: (= true (msubset t117 (remove h117 l_237)))
(push)
(assert (not (= true (msubset t117 (remove h117 l_237)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (map0 f21 t117) (map0 f21 (remove h117 l_237))))
(assert (= true (msubset (map0 f21 t117) (map0 f21 (remove h117 l_237)))))
(check-sat)
; Query: (= true (mem h117 l_237))
(push)
(assert (not (= true (mem h117 l_237))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (map0 f21 (remove h117 l_237)) (remove (_@ f21 h117) (map0 f21 l_237))))
(assert
   (= true
      (msubset (map0 f21 (remove h117 l_237))
         (remove (_@ f21 h117) (map0 f21 l_237)))))
(check-sat)
; Query: (= true (msubset (map0 f21 t117) (map0 f21 (remove h117 l_237))))
(push)
(assert
   (not (= true (msubset (map0 f21 t117) (map0 f21 (remove h117 l_237))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (map0 f21 (remove h117 l_237)) (remove (_@ f21 h117) (map0 f21 l_237))))
(push)
(assert
   (not
      (= true
         (msubset (map0 f21 (remove h117 l_237))
            (remove (_@ f21 h117) (map0 f21 l_237))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (map0 f21 t117) (remove (_@ f21 h117) (map0 f21 l_237))))
(assert
   (= true (msubset (map0 f21 t117) (remove (_@ f21 h117) (map0 f21 l_237)))))
(check-sat)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem h117 l_237) true)
(push)
(assert (not (= (mem h117 l_237) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f21 h117) (map0 f21 l_237)) true)
(assert (= (mem (_@ f21 h117) (map0 f21 l_237)) true))
(check-sat)
; Query: (= true (msubset (map0 f21 l_137) (map0 f21 l_237)))
(push)
(assert (not (= true (msubset (map0 f21 l_137) (map0 f21 l_237)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_138 () Inductive)
(declare-fun l_238 () Inductive)
(declare-fun currentThread138 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_138 nil)
(assert (= l_138 nil))
(check-sat)
; Query: (= true (msubset l_138 (append l_138 l_238)))
(push)
(assert (not (= true (msubset l_138 (append l_138 l_238)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h118 () Inductive)
(declare-fun t118 () Inductive)
(push)
(push)
; Assume: (= l_138 (cons h118 t118))
(assert (= l_138 (cons h118 t118)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t118 (append t118 l_238)))
(assert (= true (msubset t118 (append t118 l_238))))
(check-sat)
; Query: (= true (msubset l_138 (append l_138 l_238)))
(push)
(assert (not (= true (msubset l_138 (append l_138 l_238)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_139 () Inductive)
(declare-fun l_239 () Inductive)
(declare-fun currentThread139 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_139 nil)
(assert (= l_139 nil))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_239 l_239))
(assert (= true (msubset l_239 l_239)))
(check-sat)
; Query: (= true (msubset l_239 (append l_139 l_239)))
(push)
(assert (not (= true (msubset l_239 (append l_139 l_239)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h119 () Inductive)
(declare-fun t119 () Inductive)
(push)
(push)
; Assume: (= l_139 (cons h119 t119))
(assert (= l_139 (cons h119 t119)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_239 (append t119 l_239)))
(assert (= true (msubset l_239 (append t119 l_239))))
(check-sat)
; Query: (= true (msubset l_239 (append t119 l_239)))
(push)
(assert (not (= true (msubset l_239 (append t119 l_239)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_239 (cons h119 (append t119 l_239))))
(assert (= true (msubset l_239 (cons h119 (append t119 l_239)))))
(check-sat)
; Query: (= true (msubset l_239 (append l_139 l_239)))
(push)
(assert (not (= true (msubset l_239 (append l_139 l_239)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_140 () Inductive)
(declare-fun l_240 () Inductive)
(declare-fun currentThread140 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_140 (append l_140 l_240)))
(assert (= true (msubset l_140 (append l_140 l_240))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_240 (append l_140 l_240)))
(assert (= true (msubset l_240 (append l_140 l_240))))
(check-sat)
; Query: (= true (msubset l_140 (append l_140 l_240)))
(push)
(assert (not (= true (msubset l_140 (append l_140 l_240)))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_240 (append l_140 l_240)))
(push)
(assert (not (= true (msubset l_240 (append l_140 l_240)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_141 () Inductive)
(declare-fun l_241 () Inductive)
(declare-fun l_36 () Inductive)
(declare-fun l_41 () Inductive)
(declare-fun currentThread141 () Int)
(push)
(push)
; Assume: (= true (msubset l_141 l_36))
(assert (= true (msubset l_141 l_36)))
(check-sat)
(push)
; Assume: (= true (msubset l_241 l_41))
(assert (= true (msubset l_241 l_41)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_141 nil)
(assert (= l_141 nil))
(check-sat)
; Query: (= true (msubset l_241 l_41))
(push)
(assert (not (= true (msubset l_241 l_41))))
(check-sat)
(pop 1)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_36 (append l_36 l_41)))
(assert (= true (msubset l_36 (append l_36 l_41))))
(check-sat)
(push)
; Assume: (= true (msubset l_41 (append l_36 l_41)))
(assert (= true (msubset l_41 (append l_36 l_41))))
(check-sat)
; Query: (= true (msubset l_241 l_41))
(push)
(assert (not (= true (msubset l_241 l_41))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_41 (append l_36 l_41)))
(push)
(assert (not (= true (msubset l_41 (append l_36 l_41)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_241 (append l_36 l_41)))
(assert (= true (msubset l_241 (append l_36 l_41))))
(check-sat)
; Query: (= true (msubset (append l_141 l_241) (append l_36 l_41)))
(push)
(assert (not (= true (msubset (append l_141 l_241) (append l_36 l_41)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h120 () Inductive)
(declare-fun t120 () Inductive)
(push)
(push)
; Assume: (= l_141 (cons h120 t120))
(assert (= l_141 (cons h120 t120)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h120 (append l_36 l_41)) (or (mem h120 l_36) (mem h120 l_41)))
(assert
   (= (mem h120 (append l_36 l_41)) (or (mem h120 l_36) (mem h120 l_41))))
(check-sat)
; Query: (= true (mem h120 l_36))
(push)
(assert (not (= true (mem h120 l_36))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h120 (append l_36 l_41)) (append (remove h120 l_36) l_41))
(assert
   (= (remove h120 (append l_36 l_41)) (append (remove h120 l_36) l_41)))
(check-sat)
; Query: (= true (msubset t120 (remove h120 l_36)))
(push)
(assert (not (= true (msubset t120 (remove h120 l_36)))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_241 l_41))
(push)
(assert (not (= true (msubset l_241 l_41))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append t120 l_241) (append (remove h120 l_36) l_41)))
(assert
   (= true (msubset (append t120 l_241) (append (remove h120 l_36) l_41))))
(check-sat)
; Query: (= true (msubset (append l_141 l_241) (append l_36 l_41)))
(push)
(assert (not (= true (msubset (append l_141 l_241) (append l_36 l_41)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_142 () Inductive)
(declare-fun l_242 () Inductive)
(declare-fun f22 () Inductive)
(declare-fun currentThread142 () Int)
(push)
(push)
; Assume: (= true (msubset l_142 l_242))
(assert (= true (msubset l_142 l_242)))
(check-sat)
(push)
; Assume: (= true (forall0 l_242 f22))
(assert (= true (forall0 l_242 f22)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_142 nil)
(assert (= l_142 nil))
(check-sat)
; Query: (= true (forall0 l_142 f22))
(push)
(assert (not (= true (forall0 l_142 f22))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h121 () Inductive)
(declare-fun t121 () Inductive)
(push)
(push)
; Assume: (= l_142 (cons h121 t121))
(assert (= l_142 (cons h121 t121)))
(check-sat)
; Query: (= true (forall0 l_242 f22))
(push)
(assert (not (= true (forall0 l_242 f22))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (remove h121 l_242) f22))
(assert (= true (forall0 (remove h121 l_242) f22)))
(check-sat)
; Assert: (< (func_rank forall_mem) 0)
(assert (< (func_rank forall_mem) 0))
; Query: (and (= (forall0 l_242 f22) true) (= (mem h121 l_242) true))
(push)
(assert (not (and (= (forall0 l_242 f22) true) (= (mem h121 l_242) true))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (unbox_bool (_@ f22 h121)) true)
(assert (= (unbox_bool (_@ f22 h121)) true))
(check-sat)
; Query: (= true (msubset t121 (remove h121 l_242)))
(push)
(assert (not (= true (msubset t121 (remove h121 l_242)))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (remove h121 l_242) f22))
(push)
(assert (not (= true (forall0 (remove h121 l_242) f22))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 t121 f22))
(assert (= true (forall0 t121 f22)))
(check-sat)
; Query: (= true (forall0 l_142 f22))
(push)
(assert (not (= true (forall0 l_142 f22))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_143 () Inductive)
(declare-fun l_243 () Inductive)
(declare-fun el26 () Inductive)
(declare-fun currentThread143 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_143 nil)
(assert (= l_143 nil))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (cons el26 l_243) (cons el26 l_243)))
(assert (= true (msubset (cons el26 l_243) (cons el26 l_243))))
(check-sat)
; Query: (= true (msubset (cons el26 (append l_143 l_243)) (append l_143 (cons el26 l_243))))
(push)
(assert
   (not
      (= true
         (msubset (cons el26 (append l_143 l_243))
            (append l_143 (cons el26 l_243))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h122 () Inductive)
(declare-fun t122 () Inductive)
(push)
(push)
; Assume: (= l_143 (cons h122 t122))
(assert (= l_143 (cons h122 t122)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (cons el26 (append t122 l_243)) (append t122 (cons el26 l_243))))
(assert
   (= true
      (msubset (cons el26 (append t122 l_243))
         (append t122 (cons el26 l_243)))))
(check-sat)
; Query: (= true (msubset (cons el26 (append l_143 l_243)) (append l_143 (cons el26 l_243))))
(push)
(assert
   (not
      (= true
         (msubset (cons el26 (append l_143 l_243))
            (append l_143 (cons el26 l_243))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_144 () Inductive)
(declare-fun l_244 () Inductive)
(declare-fun el27 () Inductive)
(declare-fun currentThread144 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_144 nil)
(assert (= l_144 nil))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (cons el27 l_244) (cons el27 l_244)))
(assert (= true (msubset (cons el27 l_244) (cons el27 l_244))))
(check-sat)
; Query: (= true (msubset (append l_144 (cons el27 l_244)) (cons el27 (append l_144 l_244))))
(push)
(assert
   (not
      (= true
         (msubset (append l_144 (cons el27 l_244))
            (cons el27 (append l_144 l_244))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h123 () Inductive)
(declare-fun t123 () Inductive)
(push)
(push)
; Assume: (= l_144 (cons h123 t123))
(assert (= l_144 (cons h123 t123)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append t123 (cons el27 l_244)) (cons el27 (append t123 l_244))))
(assert
   (= true
      (msubset (append t123 (cons el27 l_244))
         (cons el27 (append t123 l_244)))))
(check-sat)
; Query: (= true (msubset (append l_144 (cons el27 l_244)) (cons el27 (append l_144 l_244))))
(push)
(assert
   (not
      (= true
         (msubset (append l_144 (cons el27 l_244))
            (cons el27 (append l_144 l_244))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_145 () Inductive)
(declare-fun l_245 () Inductive)
(declare-fun l_37 () Inductive)
(declare-fun el28 () Inductive)
(declare-fun currentThread145 () Int)
(push)
(push)
; Assume: (= true (msubset l_145 (append (cons el28 l_245) l_37)))
(assert (= true (msubset l_145 (append (cons el28 l_245) l_37))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_145 nil)
(assert (= l_145 nil))
(check-sat)
; Query: (= true (msubset l_145 (append l_245 (cons el28 l_37))))
(push)
(assert (not (= true (msubset l_145 (append l_245 (cons el28 l_37))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h124 () Inductive)
(declare-fun t124 () Inductive)
(push)
(push)
; Assume: (= l_145 (cons h124 t124))
(assert (= l_145 (cons h124 t124)))
(check-sat)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h124 (append (cons el28 l_245) l_37)) (or (mem h124 (cons el28 l_245)) (mem h124 l_37)))
(assert
   (= (mem h124 (append (cons el28 l_245) l_37))
      (or (mem h124 (cons el28 l_245)) (mem h124 l_37))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h124 (append (cons el28 l_245) l_37)) (ite (mem h124 (cons el28 l_245)) (append (remove h124 (cons el28 l_245)) l_37) (append (cons el28 l_245) (remove h124 l_37))))
(assert
   (= (remove h124 (append (cons el28 l_245) l_37))
      (ite (mem h124 (cons el28 l_245))
         (append (remove h124 (cons el28 l_245)) l_37)
         (append (cons el28 l_245) (remove h124 l_37)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h124 (append l_245 (cons el28 l_37))) (ite (mem h124 l_245) (append (remove h124 l_245) (cons el28 l_37)) (append l_245 (remove h124 (cons el28 l_37)))))
(assert
   (= (remove h124 (append l_245 (cons el28 l_37)))
      (ite (mem h124 l_245) (append (remove h124 l_245) (cons el28 l_37))
         (append l_245 (remove h124 (cons el28 l_37))))))
(check-sat)
(push)
(push)
; Assume: (not (= h124 el28))
(assert (not (= h124 el28)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (mem h124 l_245)
(assert (mem h124 l_245))
(check-sat)
(push)
(push)
; Query: (= (remove h124 (append (cons el28 l_245) l_37)) (cons el28 (append (remove h124 l_245) l_37)))
(push)
(assert
   (not
      (= (remove h124 (append (cons el28 l_245) l_37))
         (cons el28 (append (remove h124 l_245) l_37)))))
(check-sat)
(pop 1)
; Query: (= true (msubset t124 (append (cons el28 (remove h124 l_245)) l_37)))
(push)
(assert
   (not
      (= true (msubset t124 (append (cons el28 (remove h124 l_245)) l_37)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t124 (append (remove h124 l_245) (cons el28 l_37))))
(assert
   (= true (msubset t124 (append (remove h124 l_245) (cons el28 l_37)))))
(check-sat)
; Query: (= true (msubset t124 (remove h124 (append l_245 (cons el28 l_37)))))
(push)
(assert
   (not
      (= true (msubset t124 (remove h124 (append l_245 (cons el28 l_37)))))))
(check-sat)
(pop 1)
; Query: (= true (mem h124 (append l_245 (cons el28 l_37))))
(push)
(assert (not (= true (mem h124 (append l_245 (cons el28 l_37))))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_145 (append l_245 (cons el28 l_37))))
(push)
(assert (not (= true (msubset l_145 (append l_245 (cons el28 l_37))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem h124 l_245))
(assert (not (mem h124 l_245)))
(check-sat)
(push)
(push)
; Query: (= true (mem h124 l_37))
(push)
(assert (not (= true (mem h124 l_37))))
(check-sat)
(pop 1)
; Query: (= true (msubset t124 (append (cons el28 l_245) (remove h124 l_37))))
(push)
(assert
   (not
      (= true (msubset t124 (append (cons el28 l_245) (remove h124 l_37))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t124 (append l_245 (cons el28 (remove h124 l_37)))))
(assert
   (= true (msubset t124 (append l_245 (cons el28 (remove h124 l_37))))))
(check-sat)
; Query: (= true (mem h124 (append l_245 (cons el28 l_37))))
(push)
(assert (not (= true (mem h124 (append l_245 (cons el28 l_37))))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_145 (append l_245 (cons el28 l_37))))
(push)
(assert (not (= true (msubset l_145 (append l_245 (cons el28 l_37))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h124 el28)))
(assert (not (not (= h124 el28))))
(check-sat)
(push)
(push)
; Query: (= true (msubset t124 (append l_245 l_37)))
(push)
(assert (not (= true (msubset t124 (append l_245 l_37)))))
(check-sat)
(pop 1)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (cons el28 (append l_245 l_37)) (append l_245 (cons el28 l_37))))
(assert
   (= true
      (msubset (cons el28 (append l_245 l_37))
         (append l_245 (cons el28 l_37)))))
(check-sat)
; Query: (= true (msubset l_145 (cons el28 (append l_245 l_37))))
(push)
(assert (not (= true (msubset l_145 (cons el28 (append l_245 l_37))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons el28 (append l_245 l_37)) (append l_245 (cons el28 l_37))))
(push)
(assert
   (not
      (= true
         (msubset (cons el28 (append l_245 l_37))
            (append l_245 (cons el28 l_37))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_145 (append l_245 (cons el28 l_37))))
(assert (= true (msubset l_145 (append l_245 (cons el28 l_37)))))
(check-sat)
; Query: (= true (msubset l_145 (append l_245 (cons el28 l_37))))
(push)
(assert (not (= true (msubset l_145 (append l_245 (cons el28 l_37))))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_145 (append l_245 (cons el28 l_37))))
(push)
(assert (not (= true (msubset l_145 (append l_245 (cons el28 l_37))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_146 () Inductive)
(declare-fun l_246 () Inductive)
(declare-fun l_38 () Inductive)
(declare-fun el29 () Inductive)
(declare-fun currentThread146 () Int)
(push)
(push)
; Assume: (= true (msubset l_146 (append l_246 l_38)))
(assert (= true (msubset l_146 (append l_246 l_38))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_246 nil)
(assert (= l_246 nil))
(check-sat)
; Query: (= true (msubset l_146 (remove el29 (append l_246 (cons el29 l_38)))))
(push)
(assert
   (not
      (= true (msubset l_146 (remove el29 (append l_246 (cons el29 l_38)))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h125 () Inductive)
(declare-fun t125 () Inductive)
(push)
(push)
; Assume: (= l_246 (cons h125 t125))
(assert (= l_246 (cons h125 t125)))
(check-sat)
(push)
(push)
; Assume: (= h125 el29)
(assert (= h125 el29))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_146 (append l_246 l_38)))
(push)
(assert (not (= true (msubset l_146 (append l_246 l_38)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove h125 l_146) (remove h125 (append l_246 l_38))))
(assert
   (= true (msubset (remove h125 l_146) (remove h125 (append l_246 l_38)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h125 (append l_246 l_38)) (ite (mem h125 l_246) (append (remove h125 l_246) l_38) (append l_246 (remove h125 l_38))))
(assert
   (= (remove h125 (append l_246 l_38))
      (ite (mem h125 l_246) (append (remove h125 l_246) l_38)
         (append l_246 (remove h125 l_38)))))
(check-sat)
; Query: (= true (msubset l_146 (append (cons el29 t125) l_38)))
(push)
(assert (not (= true (msubset l_146 (append (cons el29 t125) l_38)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_146 (append t125 (cons el29 l_38))))
(assert (= true (msubset l_146 (append t125 (cons el29 l_38)))))
(check-sat)
; Query: (= true (msubset l_146 (remove el29 (append l_246 (cons el29 l_38)))))
(push)
(assert
   (not
      (= true (msubset l_146 (remove el29 (append l_246 (cons el29 l_38)))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h125 el29))
(assert (not (= h125 el29)))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_146 (append l_246 l_38)))
(push)
(assert (not (= true (msubset l_146 (append l_246 l_38)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove h125 l_146) (remove h125 (append l_246 l_38))))
(assert
   (= true (msubset (remove h125 l_146) (remove h125 (append l_246 l_38)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h125 (append l_246 l_38)) (ite (mem h125 l_246) (append (remove h125 l_246) l_38) (append l_246 (remove h125 l_38))))
(assert
   (= (remove h125 (append l_246 l_38))
      (ite (mem h125 l_246) (append (remove h125 l_246) l_38)
         (append l_246 (remove h125 l_38)))))
(check-sat)
; Query: (= true (msubset (remove h125 l_146) (append t125 l_38)))
(push)
(assert (not (= true (msubset (remove h125 l_146) (append t125 l_38)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove h125 l_146) (remove el29 (append t125 (cons el29 l_38)))))
(assert
   (= true
      (msubset (remove h125 l_146)
         (remove el29 (append t125 (cons el29 l_38))))))
(check-sat)
; Assert: (< (func_rank remove_commutes) 0)
(assert (< (func_rank remove_commutes) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el29 (remove h125 (append l_246 (cons el29 l_38)))) (remove h125 (remove el29 (append l_246 (cons el29 l_38)))))
(assert
   (= (remove el29 (remove h125 (append l_246 (cons el29 l_38))))
      (remove h125 (remove el29 (append l_246 (cons el29 l_38))))))
(check-sat)
; Query: (= true (mem h125 (remove el29 (append l_246 (cons el29 l_38)))))
(push)
(assert
   (not (= true (mem h125 (remove el29 (append l_246 (cons el29 l_38)))))))
(check-sat)
(pop 1)
; Query: (= true (msubset (remove h125 l_146) (remove h125 (remove el29 (append l_246 (cons el29 l_38))))))
(push)
(assert
   (not
      (= true
         (msubset (remove h125 l_146)
            (remove h125 (remove el29 (append l_246 (cons el29 l_38))))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_146 (remove el29 (append l_246 (cons el29 l_38)))))
(assert
   (= true (msubset l_146 (remove el29 (append l_246 (cons el29 l_38))))))
(check-sat)
; Query: (= true (msubset l_146 (remove el29 (append l_246 (cons el29 l_38)))))
(push)
(assert
   (not
      (= true (msubset l_146 (remove el29 (append l_246 (cons el29 l_38)))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_147 () Inductive)
(declare-fun l_247 () Inductive)
(declare-fun currentThread147 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_147 nil)
(assert (= l_147 nil))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_247 l_247))
(assert (= true (msubset l_247 l_247)))
(check-sat)
; Query: (= true (msubset (append l_147 l_247) (append l_247 l_147)))
(push)
(assert (not (= true (msubset (append l_147 l_247) (append l_247 l_147)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h126 () Inductive)
(declare-fun t126 () Inductive)
(push)
(push)
; Assume: (= l_147 (cons h126 t126))
(assert (= l_147 (cons h126 t126)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append t126 l_247) (append l_247 t126)))
(assert (= true (msubset (append t126 l_247) (append l_247 t126))))
(check-sat)
; Query: (= true (msubset (append t126 l_247) (append l_247 t126)))
(push)
(assert (not (= true (msubset (append t126 l_247) (append l_247 t126)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (append t126 l_247) (append l_247 t126)))
(push)
(assert (not (= true (msubset (append t126 l_247) (append l_247 t126)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append t126 l_247) (remove h126 (append l_247 (cons h126 t126)))))
(assert
   (= true
      (msubset (append t126 l_247)
         (remove h126 (append l_247 (cons h126 t126))))))
(check-sat)
; Query: (= true (msubset (append t126 l_247) (remove h126 (append l_247 l_147))))
(push)
(assert
   (not
      (= true
         (msubset (append t126 l_247) (remove h126 (append l_247 l_147))))))
(check-sat)
(pop 1)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h126 (append l_247 l_147)) (or (mem h126 l_247) (mem h126 l_147)))
(assert
   (= (mem h126 (append l_247 l_147)) (or (mem h126 l_247) (mem h126 l_147))))
(check-sat)
; Query: (= true (msubset (append l_147 l_247) (append l_247 l_147)))
(push)
(assert (not (= true (msubset (append l_147 l_247) (append l_247 l_147)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_148 () Inductive)
(declare-fun l_248 () Inductive)
(declare-fun currentThread148 () Int)
(push)
(push)
; Assume: (= true (msubset l_148 l_248))
(assert (= true (msubset l_148 l_248)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_148 nil)
(assert (= l_148 nil))
(check-sat)
; Query: (<= (length l_148) (length l_248))
(push)
(assert (not (<= (length l_148) (length l_248))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h127 () Inductive)
(declare-fun t127 () Inductive)
(push)
(push)
; Assume: (= l_148 (cons h127 t127))
(assert (= l_148 (cons h127 t127)))
(check-sat)
; Query: (= true (msubset t127 (remove h127 l_248)))
(push)
(assert (not (= true (msubset t127 (remove h127 l_248)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= (length t127) (length (remove h127 l_248)))
(assert (<= (length t127) (length (remove h127 l_248))))
(check-sat)
; Query: (<= (length l_148) (length l_248))
(push)
(assert (not (<= (length l_148) (length l_248))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs22 () Inductive)
(declare-fun el30 () Inductive)
(declare-fun currentThread149 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs22 nil)
(assert (= xs22 nil))
(check-sat)
; Query: (= true (msubset xs22 (append (remove el30 xs22) (cons el30 nil))))
(push)
(assert
   (not (= true (msubset xs22 (append (remove el30 xs22) (cons el30 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h128 () Inductive)
(declare-fun t128 () Inductive)
(push)
(push)
; Assume: (= xs22 (cons h128 t128))
(assert (= xs22 (cons h128 t128)))
(check-sat)
(push)
(push)
; Assume: (= h128 el30)
(assert (= h128 el30))
(check-sat)
(push)
(push)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h128 (append (remove el30 xs22) (cons el30 nil))) (or (mem h128 (remove el30 xs22)) (mem h128 (cons el30 nil))))
(assert
   (= (mem h128 (append (remove el30 xs22) (cons el30 nil)))
      (or (mem h128 (remove el30 xs22)) (mem h128 (cons el30 nil)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t128 t128))
(assert (= true (msubset t128 t128)))
(check-sat)
(push)
(push)
; Assume: (mem el30 t128)
(assert (mem el30 t128))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t128 (append (remove el30 t128) (cons el30 nil))))
(assert (= true (msubset t128 (append (remove el30 t128) (cons el30 nil)))))
(check-sat)
; Query: (= true (mem el30 t128))
(push)
(assert (not (= true (mem el30 t128))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el30 (append t128 (cons el30 nil))) (append (remove el30 t128) (cons el30 nil)))
(assert
   (= (remove el30 (append t128 (cons el30 nil)))
      (append (remove el30 t128) (cons el30 nil))))
(check-sat)
; Query: (= true (msubset xs22 (append (remove el30 xs22) (cons el30 nil))))
(push)
(assert
   (not (= true (msubset xs22 (append (remove el30 xs22) (cons el30 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem el30 t128))
(assert (not (mem el30 t128)))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el30 (append t128 (cons el30 nil))) (ite (mem el30 t128) (append (remove el30 t128) (cons el30 nil)) (append t128 (remove el30 (cons el30 nil)))))
(assert
   (= (remove el30 (append t128 (cons el30 nil)))
      (ite (mem el30 t128) (append (remove el30 t128) (cons el30 nil))
         (append t128 (remove el30 (cons el30 nil))))))
(check-sat)
; Query: (= true (msubset xs22 (append (remove el30 xs22) (cons el30 nil))))
(push)
(assert
   (not (= true (msubset xs22 (append (remove el30 xs22) (cons el30 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h128 el30))
(assert (not (= h128 el30)))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t128 (append (remove el30 t128) (cons el30 nil))))
(assert (= true (msubset t128 (append (remove el30 t128) (cons el30 nil)))))
(check-sat)
; Query: (= true (msubset xs22 (append (remove el30 xs22) (cons el30 nil))))
(push)
(assert
   (not (= true (msubset xs22 (append (remove el30 xs22) (cons el30 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs23 () Inductive)
(declare-fun ys19 () Inductive)
(declare-fun el31 () Inductive)
(declare-fun currentThread150 () Int)
(push)
(push)
; Assume: (= true (msubset xs23 ys19))
(assert (= true (msubset xs23 ys19)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs23 nil)
(assert (= xs23 nil))
(check-sat)
; Query: (= true (msubset xs23 (append (remove el31 ys19) (cons el31 nil))))
(push)
(assert
   (not (= true (msubset xs23 (append (remove el31 ys19) (cons el31 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h129 () Inductive)
(declare-fun t129 () Inductive)
(push)
(push)
; Assume: (= xs23 (cons h129 t129))
(assert (= xs23 (cons h129 t129)))
(check-sat)
(push)
(push)
; Assume: (= h129 el31)
(assert (= h129 el31))
(check-sat)
(push)
(push)
; Assert: (< (func_rank mem_append) 0)
(assert (< (func_rank mem_append) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h129 (append (remove el31 ys19) (cons el31 nil))) (or (mem h129 (remove el31 ys19)) (mem h129 (cons el31 nil))))
(assert
   (= (mem h129 (append (remove el31 ys19) (cons el31 nil)))
      (or (mem h129 (remove el31 ys19)) (mem h129 (cons el31 nil)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset ys19 (append (remove el31 ys19) (cons el31 nil))))
(assert (= true (msubset ys19 (append (remove el31 ys19) (cons el31 nil)))))
(check-sat)
; Query: (= true (msubset ys19 (append (remove el31 ys19) (cons el31 nil))))
(push)
(assert
   (not (= true (msubset ys19 (append (remove el31 ys19) (cons el31 nil))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove h129 ys19) (remove h129 (append (remove el31 ys19) (cons el31 nil)))))
(assert
   (= true
      (msubset (remove h129 ys19)
         (remove h129 (append (remove el31 ys19) (cons el31 nil))))))
(check-sat)
; Query: (= true (msubset t129 (remove h129 ys19)))
(push)
(assert (not (= true (msubset t129 (remove h129 ys19)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (remove h129 ys19) (remove h129 (append (remove el31 ys19) (cons el31 nil)))))
(push)
(assert
   (not
      (= true
         (msubset (remove h129 ys19)
            (remove h129 (append (remove el31 ys19) (cons el31 nil)))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t129 (remove h129 (append (remove el31 ys19) (cons el31 nil)))))
(assert
   (= true
      (msubset t129
         (remove h129 (append (remove el31 ys19) (cons el31 nil))))))
(check-sat)
; Query: (= true (msubset xs23 (append (remove el31 ys19) (cons el31 nil))))
(push)
(assert
   (not (= true (msubset xs23 (append (remove el31 ys19) (cons el31 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h129 el31))
(assert (not (= h129 el31)))
(check-sat)
(push)
(push)
; Query: (= true (msubset t129 (remove h129 ys19)))
(push)
(assert (not (= true (msubset t129 (remove h129 ys19)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t129 (append (remove el31 (remove h129 ys19)) (cons el31 nil))))
(assert
   (= true
      (msubset t129
         (append (remove el31 (remove h129 ys19)) (cons el31 nil)))))
(check-sat)
; Assert: (< (func_rank remove_commutes) 0)
(assert (< (func_rank remove_commutes) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el31 (remove h129 ys19)) (remove h129 (remove el31 ys19)))
(assert
   (= (remove el31 (remove h129 ys19)) (remove h129 (remove el31 ys19))))
(check-sat)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h129 el31))
(push)
(assert (not (not (= h129 el31))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h129 (remove el31 ys19)) (mem h129 ys19))
(assert (= (mem h129 (remove el31 ys19)) (mem h129 ys19)))
(check-sat)
; Query: (= true (mem h129 (remove el31 ys19)))
(push)
(assert (not (= true (mem h129 (remove el31 ys19)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h129 (append (remove el31 ys19) (cons el31 nil))) (append (remove h129 (remove el31 ys19)) (cons el31 nil)))
(assert
   (= (remove h129 (append (remove el31 ys19) (cons el31 nil)))
      (append (remove h129 (remove el31 ys19)) (cons el31 nil))))
(check-sat)
; Query: (= true (msubset xs23 (append (remove el31 ys19) (cons el31 nil))))
(push)
(assert
   (not (= true (msubset xs23 (append (remove el31 ys19) (cons el31 nil))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs24 () Inductive)
(declare-fun ys20 () Inductive)
(declare-fun el32 () Inductive)
(declare-fun currentThread151 () Int)
(push)
(push)
; Assume: (= true (msubset xs24 ys20))
(assert (= true (msubset xs24 ys20)))
(check-sat)
(push)
; Assume: (= true (mem el32 xs24))
(assert (= true (mem el32 xs24)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs24 nil)
(assert (= xs24 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h130 () Inductive)
(declare-fun t130 () Inductive)
(push)
(push)
; Assume: (= xs24 (cons h130 t130))
(assert (= xs24 (cons h130 t130)))
(check-sat)
(push)
(push)
; Assume: (= el32 h130)
(assert (= el32 h130))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append t130 (cons el32 nil)) (cons el32 (append t130 nil))))
(assert
   (= true
      (msubset (append t130 (cons el32 nil)) (cons el32 (append t130 nil)))))
(check-sat)
; Query: (= true (msubset (append t130 (cons el32 nil)) (cons el32 t130)))
(push)
(assert
   (not (= true (msubset (append t130 (cons el32 nil)) (cons el32 t130)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons el32 t130) ys20))
(push)
(assert (not (= true (msubset (cons el32 t130) ys20))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append t130 (cons el32 nil)) ys20))
(assert (= true (msubset (append t130 (cons el32 nil)) ys20)))
(check-sat)
; Query: (= true (msubset (append (remove el32 xs24) (cons el32 nil)) ys20))
(push)
(assert
   (not (= true (msubset (append (remove el32 xs24) (cons el32 nil)) ys20))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= el32 h130))
(assert (not (= el32 h130)))
(check-sat)
(push)
(push)
; Query: (= true (msubset t130 (remove h130 ys20)))
(push)
(assert (not (= true (msubset t130 (remove h130 ys20)))))
(check-sat)
(pop 1)
; Query: (= true (mem el32 t130))
(push)
(assert (not (= true (mem el32 t130))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append (remove el32 t130) (cons el32 nil)) (remove h130 ys20)))
(assert
   (= true
      (msubset (append (remove el32 t130) (cons el32 nil))
         (remove h130 ys20))))
(check-sat)
; Query: (= true (msubset (append (remove el32 xs24) (cons el32 nil)) ys20))
(push)
(assert
   (not (= true (msubset (append (remove el32 xs24) (cons el32 nil)) ys20))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs25 () Inductive)
(declare-fun el33 () Inductive)
(declare-fun currentThread152 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs25 nil)
(assert (= xs25 nil))
(check-sat)
; Query: (= true (msubset xs25 (cons el33 (remove el33 xs25))))
(push)
(assert (not (= true (msubset xs25 (cons el33 (remove el33 xs25))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h131 () Inductive)
(declare-fun t131 () Inductive)
(push)
(push)
; Assume: (= xs25 (cons h131 t131))
(assert (= xs25 (cons h131 t131)))
(check-sat)
(push)
(push)
; Assume: (= h131 el33)
(assert (= h131 el33))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset xs25 xs25))
(assert (= true (msubset xs25 xs25)))
(check-sat)
; Query: (= true (msubset xs25 (cons el33 (remove el33 xs25))))
(push)
(assert (not (= true (msubset xs25 (cons el33 (remove el33 xs25))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h131 el33))
(assert (not (= h131 el33)))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t131 (cons el33 (remove el33 t131))))
(assert (= true (msubset t131 (cons el33 (remove el33 t131)))))
(check-sat)
; Query: (= true (msubset xs25 (cons el33 (remove el33 xs25))))
(push)
(assert (not (= true (msubset xs25 (cons el33 (remove el33 xs25))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs26 () Inductive)
(declare-fun el34 () Inductive)
(declare-fun currentThread153 () Int)
(push)
(push)
; Assume: (= true (mem el34 xs26))
(assert (= true (mem el34 xs26)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs26 nil)
(assert (= xs26 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h132 () Inductive)
(declare-fun t132 () Inductive)
(push)
(push)
; Assume: (= xs26 (cons h132 t132))
(assert (= xs26 (cons h132 t132)))
(check-sat)
(push)
(push)
; Assume: (= h132 el34)
(assert (= h132 el34))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset xs26 xs26))
(assert (= true (msubset xs26 xs26)))
(check-sat)
; Query: (= true (msubset (cons el34 (remove el34 xs26)) xs26))
(push)
(assert (not (= true (msubset (cons el34 (remove el34 xs26)) xs26))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h132 el34))
(assert (not (= h132 el34)))
(check-sat)
(push)
(push)
; Query: (= true (mem el34 t132))
(push)
(assert (not (= true (mem el34 t132))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (cons el34 (remove el34 t132)) t132))
(assert (= true (msubset (cons el34 (remove el34 t132)) t132)))
(check-sat)
; Query: (= true (msubset (cons el34 (remove el34 xs26)) xs26))
(push)
(assert (not (= true (msubset (cons el34 (remove el34 xs26)) xs26))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f23 () Inductive)
(declare-fun l_149 () Inductive)
(declare-fun l_249 () Inductive)
(declare-fun currentThread154 () Int)
(push)
(push)
; Assume: (= true (msubset l_149 l_249))
(assert (= true (msubset l_149 l_249)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_149 nil)
(assert (= l_149 nil))
(check-sat)
; Query: (= true (msubset (filter f23 l_149) (filter f23 l_249)))
(push)
(assert (not (= true (msubset (filter f23 l_149) (filter f23 l_249)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h133 () Inductive)
(declare-fun t133 () Inductive)
(push)
(push)
; Assume: (= l_149 (cons h133 t133))
(assert (= l_149 (cons h133 t133)))
(check-sat)
; Query: (= true (msubset t133 (remove h133 l_249)))
(push)
(assert (not (= true (msubset t133 (remove h133 l_249)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (filter f23 t133) (filter f23 (remove h133 l_249))))
(assert
   (= true (msubset (filter f23 t133) (filter f23 (remove h133 l_249)))))
(check-sat)
(push)
(push)
; Assume: (unbox_bool (_@ f23 h133))
(assert (unbox_bool (_@ f23 h133)))
(check-sat)
(push)
(push)
; Query: (= true (mem h133 l_249))
(push)
(assert (not (= true (mem h133 l_249))))
(check-sat)
(pop 1)
; Query: (= true (unbox_bool (_@ f23 h133)))
(push)
(assert (not (= true (unbox_bool (_@ f23 h133)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (mem h133 (filter f23 l_249)))
(assert (= true (mem h133 (filter f23 l_249))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h133 (filter f23 l_249)) (filter f23 (remove h133 l_249)))
(assert
   (= (remove h133 (filter f23 l_249)) (filter f23 (remove h133 l_249))))
(check-sat)
; Query: (= true (msubset (filter f23 l_149) (filter f23 l_249)))
(push)
(assert (not (= true (msubset (filter f23 l_149) (filter f23 l_249)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (unbox_bool (_@ f23 h133)))
(assert (not (unbox_bool (_@ f23 h133))))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h133 (filter f23 l_249)) (filter f23 (remove h133 l_249)))
(assert
   (= (remove h133 (filter f23 l_249)) (filter f23 (remove h133 l_249))))
(check-sat)
; Query: (= false (unbox_bool (_@ f23 h133)))
(push)
(assert (not (= false (unbox_bool (_@ f23 h133)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem h133 (filter f23 l_249)))
(assert (= false (mem h133 (filter f23 l_249))))
(check-sat)
; Query: (= false (mem h133 (filter f23 l_249)))
(push)
(assert (not (= false (mem h133 (filter f23 l_249)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h133 (filter f23 l_249)) (filter f23 l_249))
(assert (= (remove h133 (filter f23 l_249)) (filter f23 l_249)))
(check-sat)
; Query: (= true (msubset (filter f23 l_149) (filter f23 l_249)))
(push)
(assert (not (= true (msubset (filter f23 l_149) (filter f23 l_249)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_150 () Inductive)
(declare-fun l_250 () Inductive)
(declare-fun currentThread155 () Int)
(push)
(push)
; Assume: (= true (subset0 l_150 l_250))
(assert (= true (subset0 l_150 l_250)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_150))
(assert (= true (distinct0 l_150)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_150 nil)
(assert (= l_150 nil))
(check-sat)
; Query: (= true (msubset l_150 l_250))
(push)
(assert (not (= true (msubset l_150 l_250))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h134 () Inductive)
(declare-fun t134 () Inductive)
(push)
(push)
; Assume: (= l_150 (cons h134 t134))
(assert (= l_150 (cons h134 t134)))
(check-sat)
; Query: (= true (subset0 t134 l_250))
(push)
(assert (not (= true (subset0 t134 l_250))))
(check-sat)
(pop 1)
; Query: (= false (mem h134 t134))
(push)
(assert (not (= false (mem h134 t134))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t134 (remove h134 l_250)))
(assert (= true (subset0 t134 (remove h134 l_250))))
(check-sat)
; Query: (= true (subset0 t134 (remove h134 l_250)))
(push)
(assert (not (= true (subset0 t134 (remove h134 l_250)))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 t134))
(push)
(assert (not (= true (distinct0 t134))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t134 (remove h134 l_250)))
(assert (= true (msubset t134 (remove h134 l_250))))
(check-sat)
; Query: (= true (msubset l_150 l_250))
(push)
(assert (not (= true (msubset l_150 l_250))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_151 () Inductive)
(declare-fun l_251 () Inductive)
(declare-fun currentThread156 () Int)
(push)
(push)
; Assume: (= true (msubset l_151 l_251))
(assert (= true (msubset l_151 l_251)))
(check-sat)
(push)
; Assume: (= (length l_151) (length l_251))
(assert (= (length l_151) (length l_251)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_151 nil)
(assert (= l_151 nil))
(check-sat)
; Query: (= (length l_251) 0)
(push)
(assert (not (= (length l_251) 0)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= l_251 nil)
(assert (= l_251 nil))
(check-sat)
; Query: (= true (msubset l_251 l_151))
(push)
(assert (not (= true (msubset l_251 l_151))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h135 () Inductive)
(declare-fun t135 () Inductive)
(push)
(push)
; Assume: (= l_151 (cons h135 t135))
(assert (= l_151 (cons h135 t135)))
(check-sat)
; Query: (= true (msubset t135 (remove h135 l_251)))
(push)
(assert (not (= true (msubset t135 (remove h135 l_251)))))
(check-sat)
(pop 1)
; Query: (= (length t135) (length (remove h135 l_251)))
(push)
(assert (not (= (length t135) (length (remove h135 l_251)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove h135 l_251) t135))
(assert (= true (msubset (remove h135 l_251) t135)))
(check-sat)
; Query: (= true (mem h135 l_151))
(push)
(assert (not (= true (mem h135 l_151))))
(check-sat)
(pop 1)
; Query: (= true (msubset (remove h135 l_251) (remove h135 l_151)))
(push)
(assert (not (= true (msubset (remove h135 l_251) (remove h135 l_151)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_251 l_151))
(assert (= true (msubset l_251 l_151)))
(check-sat)
; Query: (= true (msubset l_251 l_151))
(push)
(assert (not (= true (msubset l_251 l_151))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(declare-fun multiset_eq (Inductive Inductive) Bool)
(declare-fun _@multiset_eq () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (unbox_bool (_@ (_@ _@multiset_eq var) var0))
            (multiset_eq var var0))
         :pattern ((_@ (_@ _@multiset_eq var) var0)))))
(declare-fun multiset_eq_unremove () Int)
(declare-fun multiset_eq_comm () Int)
(declare-fun multiset_eq_msubset_rec () Int)
(declare-fun multiset_eq_msubset () Int)
(declare-fun msubset_multiset_eq () Int)
(declare-fun multiset_eq_subset () Int)
(declare-fun multiset_eq_set_eq () Int)
(declare-fun distinct_set_eq_multiset_eq () Int)
(declare-fun multiset_eq_refl () Int)
(declare-fun cons_in_the_middle_multiset_eq () Int)
(declare-fun multiset_eq_same_len () Int)
(declare-fun multiset_eq_append_both () Int)
(declare-fun multiset_eq_lift_element () Int)
(declare-fun multiset_eq_mem () Int)
(declare-fun multiset_eq_remove () Int)
(declare-fun multiset_eq_trans () Int)
(declare-fun multiset_eq_map_remove_swap () Int)
(declare-fun multiset_eq_map () Int)
(declare-fun multiset_eq_distinct () Int)
(declare-fun multiset_eq_forall () Int)
(declare-fun multiset_eq_append_assoc () Int)
(declare-fun multiset_eq_append () Int)
(declare-fun multiset_eq_append_comm () Int)
(declare-fun multiset_eq_map_cons_remove () Int)
(declare-fun map_remove_swap () Int)
(declare-fun multiset_eq_lift_element_append () Int)
(declare-fun multiset_remove_append_swap () Int)
(declare-fun multiset_eq_cons_both () Int)
; set_fpclauses
; function multiset_eq
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (multiset_eq (cons var var0) var1)
            (and (= true (mem var var1))
               (multiset_eq var0 (remove var var1))))
         :pattern ((multiset_eq (cons var var0) var1)))))
; constructor nil
(assert
   (forall ((var Inductive))
      (! (= (multiset_eq nil var) (= var nil))
         :pattern ((multiset_eq nil var)))))
; Assert: (= (func_rank multiset_eq_unremove) 373)
(assert (= (func_rank multiset_eq_unremove) 373))
; Assert: (= (func_rank multiset_eq_comm) 374)
(assert (= (func_rank multiset_eq_comm) 374))
; Assert: (= (func_rank multiset_eq_msubset_rec) 375)
(assert (= (func_rank multiset_eq_msubset_rec) 375))
; Assert: (= (func_rank multiset_eq_msubset) 376)
(assert (= (func_rank multiset_eq_msubset) 376))
; Assert: (= (func_rank msubset_multiset_eq) 377)
(assert (= (func_rank msubset_multiset_eq) 377))
; Assert: (= (func_rank multiset_eq_subset) 378)
(assert (= (func_rank multiset_eq_subset) 378))
; Assert: (= (func_rank multiset_eq_set_eq) 379)
(assert (= (func_rank multiset_eq_set_eq) 379))
; Assert: (= (func_rank distinct_set_eq_multiset_eq) 380)
(assert (= (func_rank distinct_set_eq_multiset_eq) 380))
; Assert: (= (func_rank multiset_eq_refl) 381)
(assert (= (func_rank multiset_eq_refl) 381))
; Assert: (= (func_rank cons_in_the_middle_multiset_eq) 382)
(assert (= (func_rank cons_in_the_middle_multiset_eq) 382))
; Assert: (= (func_rank multiset_eq_same_len) 383)
(assert (= (func_rank multiset_eq_same_len) 383))
; Assert: (= (func_rank multiset_eq_append_both) 384)
(assert (= (func_rank multiset_eq_append_both) 384))
; Assert: (= (func_rank multiset_eq_lift_element) 385)
(assert (= (func_rank multiset_eq_lift_element) 385))
; Assert: (= (func_rank multiset_eq_mem) 386)
(assert (= (func_rank multiset_eq_mem) 386))
; Assert: (= (func_rank multiset_eq_remove) 387)
(assert (= (func_rank multiset_eq_remove) 387))
; Assert: (= (func_rank multiset_eq_trans) 388)
(assert (= (func_rank multiset_eq_trans) 388))
; Assert: (= (func_rank multiset_eq_map_remove_swap) 389)
(assert (= (func_rank multiset_eq_map_remove_swap) 389))
; Assert: (= (func_rank multiset_eq_map) 390)
(assert (= (func_rank multiset_eq_map) 390))
; Assert: (= (func_rank multiset_eq_distinct) 391)
(assert (= (func_rank multiset_eq_distinct) 391))
; Assert: (= (func_rank multiset_eq_forall) 392)
(assert (= (func_rank multiset_eq_forall) 392))
; Assert: (= (func_rank multiset_eq_append_assoc) 393)
(assert (= (func_rank multiset_eq_append_assoc) 393))
; Assert: (= (func_rank multiset_eq_append) 394)
(assert (= (func_rank multiset_eq_append) 394))
; Assert: (= (func_rank multiset_eq_append_comm) 395)
(assert (= (func_rank multiset_eq_append_comm) 395))
; Assert: (= (func_rank multiset_eq_map_cons_remove) 396)
(assert (= (func_rank multiset_eq_map_cons_remove) 396))
; Assert: (= (func_rank map_remove_swap) 397)
(assert (= (func_rank map_remove_swap) 397))
; Assert: (= (func_rank multiset_eq_lift_element_append) 398)
(assert (= (func_rank multiset_eq_lift_element_append) 398))
; Assert: (= (func_rank multiset_remove_append_swap) 399)
(assert (= (func_rank multiset_remove_append_swap) 399))
; Assert: (= (func_rank multiset_eq_cons_both) 400)
(assert (= (func_rank multiset_eq_cons_both) 400))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(push)
(declare-fun l_152 () Inductive)
(declare-fun l_252 () Inductive)
(declare-fun x22 () Inductive)
(declare-fun currentThread157 () Int)
(push)
(push)
; Assume: (= true (mem x22 l_152))
(assert (= true (mem x22 l_152)))
(check-sat)
(push)
; Assume: (= true (multiset_eq (remove x22 l_152) l_252))
(assert (= true (multiset_eq (remove x22 l_152) l_252)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_152 nil)
(assert (= l_152 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h136 () Inductive)
(declare-fun t136 () Inductive)
(push)
(push)
; Assume: (= l_152 (cons h136 t136))
(assert (= l_152 (cons h136 t136)))
(check-sat)
(push)
(push)
; Assume: (not (= x22 h136))
(assert (not (= x22 h136)))
(check-sat)
(push)
; Query: (= true (mem x22 t136))
(push)
(assert (not (= true (mem x22 t136))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (remove x22 t136) (remove h136 l_252)))
(push)
(assert (not (= true (multiset_eq (remove x22 t136) (remove h136 l_252)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq t136 (cons x22 (remove h136 l_252))))
(assert (= true (multiset_eq t136 (cons x22 (remove h136 l_252)))))
(check-sat)
; Query: (= true (multiset_eq l_152 (cons x22 l_252)))
(push)
(assert (not (= true (multiset_eq l_152 (cons x22 l_252)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= x22 h136)))
(assert (not (not (= x22 h136))))
(check-sat)
(push)
; Query: (= true (multiset_eq l_152 (cons x22 l_252)))
(push)
(assert (not (= true (multiset_eq l_152 (cons x22 l_252)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_153 () Inductive)
(declare-fun l_253 () Inductive)
(declare-fun currentThread158 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_153 l_253))
(assert (= true (multiset_eq l_153 l_253)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_153 nil)
(assert (= l_153 nil))
(check-sat)
; Query: (= true (multiset_eq l_253 l_153))
(push)
(assert (not (= true (multiset_eq l_253 l_153))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h137 () Inductive)
(declare-fun t137 () Inductive)
(push)
(push)
; Assume: (= l_153 (cons h137 t137))
(assert (= l_153 (cons h137 t137)))
(check-sat)
; Query: (= true (multiset_eq t137 (remove h137 l_253)))
(push)
(assert (not (= true (multiset_eq t137 (remove h137 l_253)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (remove h137 l_253) t137))
(assert (= true (multiset_eq (remove h137 l_253) t137)))
(check-sat)
; Query: (= true (multiset_eq (remove h137 l_253) t137))
(push)
(assert (not (= true (multiset_eq (remove h137 l_253) t137))))
(check-sat)
(pop 1)
; Query: (= true (mem h137 l_253))
(push)
(assert (not (= true (mem h137 l_253))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (remove h137 l_253) t137))
(push)
(assert (not (= true (multiset_eq (remove h137 l_253) t137))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq l_253 (cons h137 t137)))
(assert (= true (multiset_eq l_253 (cons h137 t137))))
(check-sat)
; Query: (= true (multiset_eq l_253 l_153))
(push)
(assert (not (= true (multiset_eq l_253 l_153))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq l_253 l_153))
(push)
(assert (not (= true (multiset_eq l_253 l_153))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_154 () Inductive)
(declare-fun l_254 () Inductive)
(declare-fun currentThread159 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_154 l_254))
(assert (= true (multiset_eq l_154 l_254)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_154 nil)
(assert (= l_154 nil))
(check-sat)
; Query: (= true (msubset l_154 l_254))
(push)
(assert (not (= true (msubset l_154 l_254))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h138 () Inductive)
(declare-fun t138 () Inductive)
(push)
(push)
; Assume: (= l_154 (cons h138 t138))
(assert (= l_154 (cons h138 t138)))
(check-sat)
; Query: (= true (multiset_eq t138 (remove h138 l_254)))
(push)
(assert (not (= true (multiset_eq t138 (remove h138 l_254)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset t138 (remove h138 l_254)))
(assert (= true (msubset t138 (remove h138 l_254))))
(check-sat)
; Query: (= true (msubset l_154 l_254))
(push)
(assert (not (= true (msubset l_154 l_254))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_155 () Inductive)
(declare-fun l_255 () Inductive)
(declare-fun currentThread160 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_155 l_255))
(assert (= true (multiset_eq l_155 l_255)))
(check-sat)
(push)
(push)
; Query: (= true (multiset_eq l_155 l_255))
(push)
(assert (not (= true (multiset_eq l_155 l_255))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_155 l_255))
(assert (= true (msubset l_155 l_255)))
(check-sat)
; Query: (= true (multiset_eq l_155 l_255))
(push)
(assert (not (= true (multiset_eq l_155 l_255))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq l_255 l_155))
(assert (= true (multiset_eq l_255 l_155)))
(check-sat)
; Query: (= true (multiset_eq l_255 l_155))
(push)
(assert (not (= true (multiset_eq l_255 l_155))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_255 l_155))
(assert (= true (msubset l_255 l_155)))
(check-sat)
; Query: (= true (msubset l_155 l_255))
(push)
(assert (not (= true (msubset l_155 l_255))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_255 l_155))
(push)
(assert (not (= true (msubset l_255 l_155))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_156 () Inductive)
(declare-fun l_256 () Inductive)
(declare-fun currentThread161 () Int)
(push)
(push)
; Assume: (= true (msubset l_156 l_256))
(assert (= true (msubset l_156 l_256)))
(check-sat)
(push)
; Assume: (= true (msubset l_256 l_156))
(assert (= true (msubset l_256 l_156)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_156 nil)
(assert (= l_156 nil))
(check-sat)
; Query: (= true (msubset l_256 nil))
(push)
(assert (not (= true (msubset l_256 nil))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= l_256 nil)
(assert (= l_256 nil))
(check-sat)
; Query: (= true (multiset_eq l_156 l_256))
(push)
(assert (not (= true (multiset_eq l_156 l_256))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h139 () Inductive)
(declare-fun t139 () Inductive)
(push)
(push)
; Assume: (= l_156 (cons h139 t139))
(assert (= l_156 (cons h139 t139)))
(check-sat)
; Query: (= true (msubset l_256 l_156))
(push)
(assert (not (= true (msubset l_256 l_156))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (remove h139 l_256) (remove h139 l_156)))
(assert (= true (msubset (remove h139 l_256) (remove h139 l_156))))
(check-sat)
; Query: (= true (msubset t139 (remove h139 l_256)))
(push)
(assert (not (= true (msubset t139 (remove h139 l_256)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (remove h139 l_256) t139))
(push)
(assert (not (= true (msubset (remove h139 l_256) t139))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq t139 (remove h139 l_256)))
(assert (= true (multiset_eq t139 (remove h139 l_256))))
(check-sat)
; Query: (= true (multiset_eq l_156 l_256))
(push)
(assert (not (= true (multiset_eq l_156 l_256))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_157 () Inductive)
(declare-fun l_257 () Inductive)
(declare-fun currentThread162 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_157 l_257))
(assert (= true (multiset_eq l_157 l_257)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_157 nil)
(assert (= l_157 nil))
(check-sat)
; Query: (= true (subset0 l_157 l_257))
(push)
(assert (not (= true (subset0 l_157 l_257))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h140 () Inductive)
(declare-fun t140 () Inductive)
(push)
(push)
; Assume: (= l_157 (cons h140 t140))
(assert (= l_157 (cons h140 t140)))
(check-sat)
; Query: (= true (multiset_eq t140 (remove h140 l_257)))
(push)
(assert (not (= true (multiset_eq t140 (remove h140 l_257)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t140 (remove h140 l_257)))
(assert (= true (subset0 t140 (remove h140 l_257))))
(check-sat)
; Query: (= true (subset0 t140 (remove h140 l_257)))
(push)
(assert (not (= true (subset0 t140 (remove h140 l_257)))))
(check-sat)
(pop 1)
; Query: (= true (subset0 t140 (remove h140 l_257)))
(push)
(assert (not (= true (subset0 t140 (remove h140 l_257)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 t140 l_257))
(assert (= true (subset0 t140 l_257)))
(check-sat)
; Query: (= true (subset0 l_157 l_257))
(push)
(assert (not (= true (subset0 l_157 l_257))))
(check-sat)
(pop 1)
; Query: (= true (subset0 l_157 l_257))
(push)
(assert (not (= true (subset0 l_157 l_257))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_158 () Inductive)
(declare-fun l_258 () Inductive)
(declare-fun currentThread163 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_158 l_258))
(assert (= true (multiset_eq l_158 l_258)))
(check-sat)
(push)
(push)
; Query: (= true (multiset_eq l_158 l_258))
(push)
(assert (not (= true (multiset_eq l_158 l_258))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 l_158 l_258))
(assert (= true (subset0 l_158 l_258)))
(check-sat)
; Query: (= true (multiset_eq l_158 l_258))
(push)
(assert (not (= true (multiset_eq l_158 l_258))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq l_258 l_158))
(assert (= true (multiset_eq l_258 l_158)))
(check-sat)
; Query: (= true (multiset_eq l_258 l_158))
(push)
(assert (not (= true (multiset_eq l_258 l_158))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 l_258 l_158))
(assert (= true (subset0 l_258 l_158)))
(check-sat)
; Query: (= true (set_eq l_158 l_258))
(push)
(assert (not (= true (set_eq l_158 l_258))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (=> (= true (multiset_eq var var0)) (= true (set_eq var var0)))))
(push)
(declare-fun l_159 () Inductive)
(declare-fun l_259 () Inductive)
(declare-fun currentThread164 () Int)
(push)
(push)
; Assume: (= true (set_eq l_159 l_259))
(assert (= true (set_eq l_159 l_259)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_159))
(assert (= true (distinct0 l_159)))
(check-sat)
(push)
; Assume: (= true (distinct0 l_259))
(assert (= true (distinct0 l_259)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_159 nil)
(assert (= l_159 nil))
(check-sat)
; Query: (= true (subset0 l_259 nil))
(push)
(assert (not (= true (subset0 l_259 nil))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= l_259 nil)
(assert (= l_259 nil))
(check-sat)
; Query: (= true (multiset_eq l_159 l_259))
(push)
(assert (not (= true (multiset_eq l_159 l_259))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h141 () Inductive)
(declare-fun t141 () Inductive)
(push)
(push)
; Assume: (= l_159 (cons h141 t141))
(assert (= l_159 (cons h141 t141)))
(check-sat)
; Query: (= true (distinct0 l_259))
(push)
(assert (not (= true (distinct0 l_259))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 (remove h141 l_259)))
(assert (= true (distinct0 (remove h141 l_259))))
(check-sat)
; Query: (= true (set_eq l_159 l_259))
(push)
(assert (not (= true (set_eq l_159 l_259))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_159))
(push)
(assert (not (= true (distinct0 l_159))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_259))
(push)
(assert (not (= true (distinct0 l_259))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (set_eq (remove h141 l_159) (remove h141 l_259)))
(assert (= true (set_eq (remove h141 l_159) (remove h141 l_259))))
(check-sat)
; Query: (= true (set_eq t141 (remove h141 l_259)))
(push)
(assert (not (= true (set_eq t141 (remove h141 l_259)))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 t141))
(push)
(assert (not (= true (distinct0 t141))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 (remove h141 l_259)))
(push)
(assert (not (= true (distinct0 (remove h141 l_259)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq t141 (remove h141 l_259)))
(assert (= true (multiset_eq t141 (remove h141 l_259))))
(check-sat)
; Query: (= true (mem h141 l_259))
(push)
(assert (not (= true (mem h141 l_259))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq l_159 l_259))
(push)
(assert (not (= true (multiset_eq l_159 l_259))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l39 () Inductive)
(declare-fun currentThread165 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l39 nil)
(assert (= l39 nil))
(check-sat)
; Query: (= true (multiset_eq l39 l39))
(push)
(assert (not (= true (multiset_eq l39 l39))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h142 () Inductive)
(declare-fun t142 () Inductive)
(push)
(push)
; Assume: (= l39 (cons h142 t142))
(assert (= l39 (cons h142 t142)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq t142 t142))
(assert (= true (multiset_eq t142 t142)))
(check-sat)
; Query: (= true (multiset_eq l39 l39))
(push)
(assert (not (= true (multiset_eq l39 l39))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_160 () Inductive)
(declare-fun l_260 () Inductive)
(declare-fun x23 () Inductive)
(declare-fun currentThread166 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_160 nil)
(assert (= l_160 nil))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (cons x23 l_260) (cons x23 l_260)))
(assert (= true (multiset_eq (cons x23 l_260) (cons x23 l_260))))
(check-sat)
; Query: (= true (multiset_eq (append l_160 (cons x23 l_260)) (cons x23 (append l_160 l_260))))
(push)
(assert
   (not
      (= true
         (multiset_eq (append l_160 (cons x23 l_260))
            (cons x23 (append l_160 l_260))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h143 () Inductive)
(declare-fun t143 () Inductive)
(push)
(push)
; Assume: (= l_160 (cons h143 t143))
(assert (= l_160 (cons h143 t143)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append t143 (cons x23 l_260)) (cons x23 (append t143 l_260))))
(assert
   (= true
      (multiset_eq (append t143 (cons x23 l_260))
         (cons x23 (append t143 l_260)))))
(check-sat)
; Query: (= true (multiset_eq (append l_160 (cons x23 l_260)) (cons x23 (append l_160 l_260))))
(push)
(assert
   (not
      (= true
         (multiset_eq (append l_160 (cons x23 l_260))
            (cons x23 (append l_160 l_260))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_161 () Inductive)
(declare-fun l_261 () Inductive)
(declare-fun currentThread167 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_161 l_261))
(assert (= true (multiset_eq l_161 l_261)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_161 nil)
(assert (= l_161 nil))
(check-sat)
; Query: (= (length l_161) (length l_261))
(push)
(assert (not (= (length l_161) (length l_261))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h144 () Inductive)
(declare-fun t144 () Inductive)
(push)
(push)
; Assume: (= l_161 (cons h144 t144))
(assert (= l_161 (cons h144 t144)))
(check-sat)
; Assert: (< (func_rank length_remove) 0)
(assert (< (func_rank length_remove) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (length (remove h144 l_261)) (ite (mem h144 l_261) (- (length l_261) 1) (length l_261)))
(assert
   (= (length (remove h144 l_261))
      (ite (mem h144 l_261) (- (length l_261) 1) (length l_261))))
(check-sat)
; Query: (= true (multiset_eq t144 (remove h144 l_261)))
(push)
(assert (not (= true (multiset_eq t144 (remove h144 l_261)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (length t144) (length (remove h144 l_261)))
(assert (= (length t144) (length (remove h144 l_261))))
(check-sat)
; Query: (= (length l_161) (length l_261))
(push)
(assert (not (= (length l_161) (length l_261))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_162 () Inductive)
(declare-fun l_262 () Inductive)
(declare-fun l_39 () Inductive)
(declare-fun currentThread168 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_162 l_262))
(assert (= true (multiset_eq l_162 l_262)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_162 nil)
(assert (= l_162 nil))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq l_39 l_39))
(assert (= true (multiset_eq l_39 l_39)))
(check-sat)
; Query: (= true (multiset_eq (append l_162 l_39) (append l_262 l_39)))
(push)
(assert (not (= true (multiset_eq (append l_162 l_39) (append l_262 l_39)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h145 () Inductive)
(declare-fun t145 () Inductive)
(push)
(push)
; Assume: (= l_162 (cons h145 t145))
(assert (= l_162 (cons h145 t145)))
(check-sat)
; Query: (= true (multiset_eq t145 (remove h145 l_262)))
(push)
(assert (not (= true (multiset_eq t145 (remove h145 l_262)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append t145 l_39) (append (remove h145 l_262) l_39)))
(assert
   (= true
      (multiset_eq (append t145 l_39) (append (remove h145 l_262) l_39))))
(check-sat)
; Query: (= true (mem h145 (append l_262 l_39)))
(push)
(assert (not (= true (mem h145 (append l_262 l_39)))))
(check-sat)
(pop 1)
; Query: (= true (mem h145 l_262))
(push)
(assert (not (= true (mem h145 l_262))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove h145 (append l_262 l_39)) (append (remove h145 l_262) l_39))
(assert
   (= (remove h145 (append l_262 l_39)) (append (remove h145 l_262) l_39)))
(check-sat)
; Query: (= (remove h145 (append l_262 l_39)) (append (remove h145 l_262) l_39))
(push)
(assert
   (not
      (= (remove h145 (append l_262 l_39)) (append (remove h145 l_262) l_39))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (append l_162 l_39) (append l_262 l_39)))
(push)
(assert (not (= true (multiset_eq (append l_162 l_39) (append l_262 l_39)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el35 () Inductive)
(declare-fun l40 () Inductive)
(declare-fun currentThread169 () Int)
(push)
(push)
; Assume: (= true (mem el35 l40))
(assert (= true (mem el35 l40)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l40 nil)
(assert (= l40 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h146 () Inductive)
(declare-fun t146 () Inductive)
(push)
(push)
; Assume: (= l40 (cons h146 t146))
(assert (= l40 (cons h146 t146)))
(check-sat)
(push)
(push)
; Assume: (= el35 h146)
(assert (= el35 h146))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq l40 l40))
(assert (= true (multiset_eq l40 l40)))
(check-sat)
; Query: (= true (multiset_eq (cons el35 (remove el35 l40)) l40))
(push)
(assert (not (= true (multiset_eq (cons el35 (remove el35 l40)) l40))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= el35 h146))
(assert (not (= el35 h146)))
(check-sat)
(push)
(push)
; Query: (= true (mem el35 t146))
(push)
(assert (not (= true (mem el35 t146))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (cons el35 (remove el35 t146)) t146))
(assert (= true (multiset_eq (cons el35 (remove el35 t146)) t146)))
(check-sat)
; Query: (= true (multiset_eq (cons el35 (remove el35 l40)) l40))
(push)
(assert (not (= true (multiset_eq (cons el35 (remove el35 l40)) l40))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x24 () Inductive)
(declare-fun l_163 () Inductive)
(declare-fun l_263 () Inductive)
(declare-fun currentThread170 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_163 l_263))
(assert (= true (multiset_eq l_163 l_263)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_163 nil)
(assert (= l_163 nil))
(check-sat)
; Query: (= (mem x24 l_163) (mem x24 l_263))
(push)
(assert (not (= (mem x24 l_163) (mem x24 l_263))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h147 () Inductive)
(declare-fun t147 () Inductive)
(push)
(push)
; Assume: (= l_163 (cons h147 t147))
(assert (= l_163 (cons h147 t147)))
(check-sat)
(push)
(push)
; Assume: (not (= h147 x24))
(assert (not (= h147 x24)))
(check-sat)
(push)
(push)
; Query: (= true (multiset_eq t147 (remove h147 l_263)))
(push)
(assert (not (= true (multiset_eq t147 (remove h147 l_263)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem x24 t147) (mem x24 (remove h147 l_263)))
(assert (= (mem x24 t147) (mem x24 (remove h147 l_263))))
(check-sat)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= x24 h147))
(push)
(assert (not (not (= x24 h147))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem x24 (remove h147 l_263)) (mem x24 l_263))
(assert (= (mem x24 (remove h147 l_263)) (mem x24 l_263)))
(check-sat)
; Query: (= (mem x24 l_163) (mem x24 l_263))
(push)
(assert (not (= (mem x24 l_163) (mem x24 l_263))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h147 x24)))
(assert (not (not (= h147 x24))))
(check-sat)
(push)
; Query: (= (mem x24 l_163) (mem x24 l_263))
(push)
(assert (not (= (mem x24 l_163) (mem x24 l_263))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_164 () Inductive)
(declare-fun l_264 () Inductive)
(declare-fun el36 () Inductive)
(declare-fun currentThread171 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_164 l_264))
(assert (= true (multiset_eq l_164 l_264)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_164 nil)
(assert (= l_164 nil))
(check-sat)
; Query: (= true (multiset_eq (remove el36 l_164) (remove el36 l_264)))
(push)
(assert (not (= true (multiset_eq (remove el36 l_164) (remove el36 l_264)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h148 () Inductive)
(declare-fun t148 () Inductive)
(push)
(push)
; Assume: (= l_164 (cons h148 t148))
(assert (= l_164 (cons h148 t148)))
(check-sat)
(push)
(push)
; Assume: (not (= h148 el36))
(assert (not (= h148 el36)))
(check-sat)
(push)
(push)
; Query: (= true (multiset_eq t148 (remove h148 l_264)))
(push)
(assert (not (= true (multiset_eq t148 (remove h148 l_264)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (remove el36 t148) (remove el36 (remove h148 l_264))))
(assert
   (= true
      (multiset_eq (remove el36 t148) (remove el36 (remove h148 l_264)))))
(check-sat)
; Assert: (< (func_rank remove_commutes) 0)
(assert (< (func_rank remove_commutes) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (remove el36 (remove h148 l_264)) (remove h148 (remove el36 l_264)))
(assert
   (= (remove el36 (remove h148 l_264)) (remove h148 (remove el36 l_264))))
(check-sat)
; Assert: (< (func_rank neq_mem_remove) 0)
(assert (< (func_rank neq_mem_remove) 0))
; Query: (not (= h148 el36))
(push)
(assert (not (not (= h148 el36))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h148 (remove el36 l_264)) (mem h148 l_264))
(assert (= (mem h148 (remove el36 l_264)) (mem h148 l_264)))
(check-sat)
; Query: (= true (multiset_eq (remove el36 l_164) (remove el36 l_264)))
(push)
(assert (not (= true (multiset_eq (remove el36 l_164) (remove el36 l_264)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= h148 el36)))
(assert (not (not (= h148 el36))))
(check-sat)
(push)
; Query: (= true (multiset_eq (remove el36 l_164) (remove el36 l_264)))
(push)
(assert (not (= true (multiset_eq (remove el36 l_164) (remove el36 l_264)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_165 () Inductive)
(declare-fun l_265 () Inductive)
(declare-fun l_310 () Inductive)
(declare-fun currentThread172 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_165 l_265))
(assert (= true (multiset_eq l_165 l_265)))
(check-sat)
(push)
; Assume: (= true (multiset_eq l_265 l_310))
(assert (= true (multiset_eq l_265 l_310)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_165 nil)
(assert (= l_165 nil))
(check-sat)
; Query: (= true (multiset_eq l_165 l_310))
(push)
(assert (not (= true (multiset_eq l_165 l_310))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h149 () Inductive)
(declare-fun t149 () Inductive)
(push)
(push)
; Assume: (= l_165 (cons h149 t149))
(assert (= l_165 (cons h149 t149)))
(check-sat)
; Query: (= true (multiset_eq l_265 l_310))
(push)
(assert (not (= true (multiset_eq l_265 l_310))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem h149 l_265) (mem h149 l_310))
(assert (= (mem h149 l_265) (mem h149 l_310)))
(check-sat)
; Query: (= true (multiset_eq t149 (remove h149 l_265)))
(push)
(assert (not (= true (multiset_eq t149 (remove h149 l_265)))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq l_265 l_310))
(push)
(assert (not (= true (multiset_eq l_265 l_310))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (remove h149 l_265) (remove h149 l_310)))
(assert (= true (multiset_eq (remove h149 l_265) (remove h149 l_310))))
(check-sat)
; Query: (= true (multiset_eq t149 (remove h149 l_265)))
(push)
(assert (not (= true (multiset_eq t149 (remove h149 l_265)))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (remove h149 l_265) (remove h149 l_310)))
(push)
(assert (not (= true (multiset_eq (remove h149 l_265) (remove h149 l_310)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq t149 (remove h149 l_310)))
(assert (= true (multiset_eq t149 (remove h149 l_310))))
(check-sat)
; Query: (= true (multiset_eq l_165 l_310))
(push)
(assert (not (= true (multiset_eq l_165 l_310))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f24 () Inductive)
(declare-fun el37 () Inductive)
(declare-fun l41 () Inductive)
(declare-fun currentThread173 () Int)
(push)
(push)
; Assume: (= true (mem el37 l41))
(assert (= true (mem el37 l41)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l41 nil)
(assert (= l41 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h150 () Inductive)
(declare-fun t150 () Inductive)
(push)
(push)
; Assume: (= l41 (cons h150 t150))
(assert (= l41 (cons h150 t150)))
(check-sat)
(push)
(push)
; Assume: (= h150 el37)
(assert (= h150 el37))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f24 t150) (map0 f24 t150)))
(assert (= true (multiset_eq (map0 f24 t150) (map0 f24 t150))))
(check-sat)
; Query: (= true (multiset_eq (map0 f24 (remove el37 l41)) (remove (_@ f24 el37) (map0 f24 l41))))
(push)
(assert
   (not
      (= true
         (multiset_eq (map0 f24 (remove el37 l41))
            (remove (_@ f24 el37) (map0 f24 l41))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h150 el37))
(assert (not (= h150 el37)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= (_@ f24 h150) (_@ f24 el37))
(assert (= (_@ f24 h150) (_@ f24 el37)))
(check-sat)
(push)
(push)
; Query: (= true (mem el37 t150))
(push)
(assert (not (= true (mem el37 t150))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f24 (remove el37 t150)) (remove (_@ f24 el37) (map0 f24 t150))))
(assert
   (= true
      (multiset_eq (map0 f24 (remove el37 t150))
         (remove (_@ f24 el37) (map0 f24 t150)))))
(check-sat)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem el37 t150) true)
(push)
(assert (not (= (mem el37 t150) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f24 el37) (map0 f24 t150)) true)
(assert (= (mem (_@ f24 el37) (map0 f24 t150)) true))
(check-sat)
; Query: (= true (mem (_@ f24 el37) (map0 f24 t150)))
(push)
(assert (not (= true (mem (_@ f24 el37) (map0 f24 t150)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (cons (_@ f24 el37) (remove (_@ f24 el37) (map0 f24 t150))) (map0 f24 t150)))
(assert
   (= true
      (multiset_eq
         (cons (_@ f24 el37) (remove (_@ f24 el37) (map0 f24 t150)))
         (map0 f24 t150))))
(check-sat)
; Query: (= true (multiset_eq (cons (_@ f24 el37) (remove (_@ f24 el37) (map0 f24 t150))) (map0 f24 t150)))
(push)
(assert
   (not
      (= true
         (multiset_eq
            (cons (_@ f24 el37) (remove (_@ f24 el37) (map0 f24 t150)))
            (map0 f24 t150)))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (map0 f24 (remove el37 l41)) (cons (_@ f24 el37) (remove (_@ f24 el37) (map0 f24 t150)))))
(push)
(assert
   (not
      (= true
         (multiset_eq (map0 f24 (remove el37 l41))
            (cons (_@ f24 el37) (remove (_@ f24 el37) (map0 f24 t150)))))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (cons (_@ f24 el37) (remove (_@ f24 el37) (map0 f24 t150))) (map0 f24 t150)))
(push)
(assert
   (not
      (= true
         (multiset_eq
            (cons (_@ f24 el37) (remove (_@ f24 el37) (map0 f24 t150)))
            (map0 f24 t150)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f24 (remove el37 l41)) (map0 f24 t150)))
(assert (= true (multiset_eq (map0 f24 (remove el37 l41)) (map0 f24 t150))))
(check-sat)
; Query: (= true (multiset_eq (map0 f24 (remove el37 l41)) (remove (_@ f24 el37) (map0 f24 l41))))
(push)
(assert
   (not
      (= true
         (multiset_eq (map0 f24 (remove el37 l41))
            (remove (_@ f24 el37) (map0 f24 l41))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (_@ f24 h150) (_@ f24 el37)))
(assert (not (= (_@ f24 h150) (_@ f24 el37))))
(check-sat)
(push)
(push)
; Query: (= true (mem el37 t150))
(push)
(assert (not (= true (mem el37 t150))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f24 (remove el37 t150)) (remove (_@ f24 el37) (map0 f24 t150))))
(assert
   (= true
      (multiset_eq (map0 f24 (remove el37 t150))
         (remove (_@ f24 el37) (map0 f24 t150)))))
(check-sat)
; Query: (= true (multiset_eq (map0 f24 (remove el37 l41)) (remove (_@ f24 el37) (map0 f24 l41))))
(push)
(assert
   (not
      (= true
         (multiset_eq (map0 f24 (remove el37 l41))
            (remove (_@ f24 el37) (map0 f24 l41))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f25 () Inductive)
(declare-fun l_166 () Inductive)
(declare-fun l_266 () Inductive)
(declare-fun currentThread174 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_166 l_266))
(assert (= true (multiset_eq l_166 l_266)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_166 nil)
(assert (= l_166 nil))
(check-sat)
; Query: (= true (multiset_eq (map0 f25 l_166) (map0 f25 l_266)))
(push)
(assert (not (= true (multiset_eq (map0 f25 l_166) (map0 f25 l_266)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h151 () Inductive)
(declare-fun t151 () Inductive)
(push)
(push)
; Assume: (= l_166 (cons h151 t151))
(assert (= l_166 (cons h151 t151)))
(check-sat)
; Assert: (< (func_rank mem_map) 0)
(assert (< (func_rank mem_map) 0))
; Query: (= (mem h151 l_266) true)
(push)
(assert (not (= (mem h151 l_266) true)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (mem (_@ f25 h151) (map0 f25 l_266)) true)
(assert (= (mem (_@ f25 h151) (map0 f25 l_266)) true))
(check-sat)
; Query: (= true (multiset_eq t151 (remove h151 l_266)))
(push)
(assert (not (= true (multiset_eq t151 (remove h151 l_266)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f25 t151) (map0 f25 (remove h151 l_266))))
(assert
   (= true (multiset_eq (map0 f25 t151) (map0 f25 (remove h151 l_266)))))
(check-sat)
; Query: (= true (mem h151 l_266))
(push)
(assert (not (= true (mem h151 l_266))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f25 (remove h151 l_266)) (remove (_@ f25 h151) (map0 f25 l_266))))
(assert
   (= true
      (multiset_eq (map0 f25 (remove h151 l_266))
         (remove (_@ f25 h151) (map0 f25 l_266)))))
(check-sat)
; Query: (= true (multiset_eq (map0 f25 t151) (map0 f25 (remove h151 l_266))))
(push)
(assert
   (not
      (= true (multiset_eq (map0 f25 t151) (map0 f25 (remove h151 l_266))))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (map0 f25 (remove h151 l_266)) (remove (_@ f25 h151) (map0 f25 l_266))))
(push)
(assert
   (not
      (= true
         (multiset_eq (map0 f25 (remove h151 l_266))
            (remove (_@ f25 h151) (map0 f25 l_266))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f25 t151) (remove (_@ f25 h151) (map0 f25 l_266))))
(assert
   (= true
      (multiset_eq (map0 f25 t151) (remove (_@ f25 h151) (map0 f25 l_266)))))
(check-sat)
; Query: (= true (multiset_eq (map0 f25 l_166) (map0 f25 l_266)))
(push)
(assert (not (= true (multiset_eq (map0 f25 l_166) (map0 f25 l_266)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_167 () Inductive)
(declare-fun l_267 () Inductive)
(declare-fun currentThread175 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_167 l_267))
(assert (= true (multiset_eq l_167 l_267)))
(check-sat)
(push)
(push)
; Query: (= true (multiset_eq l_167 l_267))
(push)
(assert (not (= true (multiset_eq l_167 l_267))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_167 l_267))
(assert (= true (msubset l_167 l_267)))
(check-sat)
(push)
; Assume: (= true (msubset l_267 l_167))
(assert (= true (msubset l_267 l_167)))
(check-sat)
(push)
(push)
; Assume: (distinct0 l_167)
(assert (distinct0 l_167))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_267 l_167))
(push)
(assert (not (= true (msubset l_267 l_167))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_167))
(push)
(assert (not (= true (distinct0 l_167))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 l_267))
(assert (= true (distinct0 l_267)))
(check-sat)
(push)
(push)
; Assume: (distinct0 l_267)
(assert (distinct0 l_267))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_167 l_267))
(push)
(assert (not (= true (msubset l_167 l_267))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_267))
(push)
(assert (not (= true (distinct0 l_267))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 l_167))
(assert (= true (distinct0 l_167)))
(check-sat)
; Query: (= (distinct0 l_167) (distinct0 l_267))
(push)
(assert (not (= (distinct0 l_167) (distinct0 l_267))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (distinct0 l_267))
(assert (not (distinct0 l_267)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (distinct0 l_167))
(assert (not (distinct0 l_167)))
(check-sat)
(push)
(push)
(push)
; Assume: (distinct0 l_267)
(assert (distinct0 l_267))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_167 l_267))
(push)
(assert (not (= true (msubset l_167 l_267))))
(check-sat)
(pop 1)
; Query: (= true (distinct0 l_267))
(push)
(assert (not (= true (distinct0 l_267))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (distinct0 l_167))
(assert (= true (distinct0 l_167)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (distinct0 l_267))
(assert (not (distinct0 l_267)))
(check-sat)
(push)
; Query: (= (distinct0 l_167) (distinct0 l_267))
(push)
(assert (not (= (distinct0 l_167) (distinct0 l_267))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_168 () Inductive)
(declare-fun l_268 () Inductive)
(declare-fun f26 () Inductive)
(declare-fun currentThread176 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_168 l_268))
(assert (= true (multiset_eq l_168 l_268)))
(check-sat)
(push)
(push)
; Query: (= true (multiset_eq l_168 l_268))
(push)
(assert (not (= true (multiset_eq l_168 l_268))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_168 l_268))
(assert (= true (msubset l_168 l_268)))
(check-sat)
(push)
; Assume: (= true (msubset l_268 l_168))
(assert (= true (msubset l_268 l_168)))
(check-sat)
(push)
(push)
; Assume: (forall0 l_168 f26)
(assert (forall0 l_168 f26))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_268 l_168))
(push)
(assert (not (= true (msubset l_268 l_168))))
(check-sat)
(pop 1)
; Query: (= true (forall0 l_168 f26))
(push)
(assert (not (= true (forall0 l_168 f26))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 l_268 f26))
(assert (= true (forall0 l_268 f26)))
(check-sat)
(push)
(push)
; Assume: (forall0 l_268 f26)
(assert (forall0 l_268 f26))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_168 l_268))
(push)
(assert (not (= true (msubset l_168 l_268))))
(check-sat)
(pop 1)
; Query: (= true (forall0 l_268 f26))
(push)
(assert (not (= true (forall0 l_268 f26))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 l_168 f26))
(assert (= true (forall0 l_168 f26)))
(check-sat)
; Query: (= (forall0 l_168 f26) (forall0 l_268 f26))
(push)
(assert (not (= (forall0 l_168 f26) (forall0 l_268 f26))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (forall0 l_268 f26))
(assert (not (forall0 l_268 f26)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (forall0 l_168 f26))
(assert (not (forall0 l_168 f26)))
(check-sat)
(push)
(push)
(push)
; Assume: (forall0 l_268 f26)
(assert (forall0 l_268 f26))
(check-sat)
(push)
(push)
; Query: (= true (msubset l_168 l_268))
(push)
(assert (not (= true (msubset l_168 l_268))))
(check-sat)
(pop 1)
; Query: (= true (forall0 l_268 f26))
(push)
(assert (not (= true (forall0 l_268 f26))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 l_168 f26))
(assert (= true (forall0 l_168 f26)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (forall0 l_268 f26))
(assert (not (forall0 l_268 f26)))
(check-sat)
(push)
; Query: (= (forall0 l_168 f26) (forall0 l_268 f26))
(push)
(assert (not (= (forall0 l_168 f26) (forall0 l_268 f26))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_169 () Inductive)
(declare-fun l_269 () Inductive)
(declare-fun l_311 () Inductive)
(declare-fun currentThread177 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_169 nil)
(assert (= l_169 nil))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append l_269 l_311) (append l_269 l_311)))
(assert (= true (multiset_eq (append l_269 l_311) (append l_269 l_311))))
(check-sat)
; Query: (= true (multiset_eq (append (append l_169 l_269) l_311) (append l_169 (append l_269 l_311))))
(push)
(assert
   (not
      (= true
         (multiset_eq (append (append l_169 l_269) l_311)
            (append l_169 (append l_269 l_311))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h152 () Inductive)
(declare-fun t152 () Inductive)
(push)
(push)
; Assume: (= l_169 (cons h152 t152))
(assert (= l_169 (cons h152 t152)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append (append t152 l_269) l_311) (append t152 (append l_269 l_311))))
(assert
   (= true
      (multiset_eq (append (append t152 l_269) l_311)
         (append t152 (append l_269 l_311)))))
(check-sat)
; Query: (= true (multiset_eq (append (append l_169 l_269) l_311) (append l_169 (append l_269 l_311))))
(push)
(assert
   (not
      (= true
         (multiset_eq (append (append l_169 l_269) l_311)
            (append l_169 (append l_269 l_311))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_170 () Inductive)
(declare-fun l_270 () Inductive)
(declare-fun l_312 () Inductive)
(declare-fun l_42 () Inductive)
(declare-fun currentThread178 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_170 l_270))
(assert (= true (multiset_eq l_170 l_270)))
(check-sat)
(push)
; Assume: (= true (multiset_eq l_312 l_42))
(assert (= true (multiset_eq l_312 l_42)))
(check-sat)
(push)
(push)
; Query: (= true (multiset_eq l_170 l_270))
(push)
(assert (not (= true (multiset_eq l_170 l_270))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_170 l_270))
(assert (= true (msubset l_170 l_270)))
(check-sat)
(push)
; Assume: (= true (msubset l_270 l_170))
(assert (= true (msubset l_270 l_170)))
(check-sat)
; Query: (= true (multiset_eq l_312 l_42))
(push)
(assert (not (= true (multiset_eq l_312 l_42))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_312 l_42))
(assert (= true (msubset l_312 l_42)))
(check-sat)
(push)
; Assume: (= true (msubset l_42 l_312))
(assert (= true (msubset l_42 l_312)))
(check-sat)
; Query: (= true (msubset l_170 l_270))
(push)
(assert (not (= true (msubset l_170 l_270))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_312 l_42))
(push)
(assert (not (= true (msubset l_312 l_42))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append l_170 l_312) (append l_270 l_42)))
(assert (= true (msubset (append l_170 l_312) (append l_270 l_42))))
(check-sat)
; Query: (= true (msubset l_270 l_170))
(push)
(assert (not (= true (msubset l_270 l_170))))
(check-sat)
(pop 1)
; Query: (= true (msubset l_42 l_312))
(push)
(assert (not (= true (msubset l_42 l_312))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append l_270 l_42) (append l_170 l_312)))
(assert (= true (msubset (append l_270 l_42) (append l_170 l_312))))
(check-sat)
; Query: (= true (msubset (append l_170 l_312) (append l_270 l_42)))
(push)
(assert (not (= true (msubset (append l_170 l_312) (append l_270 l_42)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (append l_270 l_42) (append l_170 l_312)))
(push)
(assert (not (= true (msubset (append l_270 l_42) (append l_170 l_312)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append l_170 l_312) (append l_270 l_42)))
(assert (= true (multiset_eq (append l_170 l_312) (append l_270 l_42))))
(check-sat)
; Query: (= true (multiset_eq (append l_170 l_312) (append l_270 l_42)))
(push)
(assert
   (not (= true (multiset_eq (append l_170 l_312) (append l_270 l_42)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_171 () Inductive)
(declare-fun l_271 () Inductive)
(declare-fun currentThread179 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append l_171 l_271) (append l_271 l_171)))
(assert (= true (msubset (append l_171 l_271) (append l_271 l_171))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset (append l_271 l_171) (append l_171 l_271)))
(assert (= true (msubset (append l_271 l_171) (append l_171 l_271))))
(check-sat)
; Query: (= true (msubset (append l_171 l_271) (append l_271 l_171)))
(push)
(assert (not (= true (msubset (append l_171 l_271) (append l_271 l_171)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (append l_271 l_171) (append l_171 l_271)))
(push)
(assert (not (= true (msubset (append l_271 l_171) (append l_171 l_271)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append l_171 l_271) (append l_271 l_171)))
(assert (= true (multiset_eq (append l_171 l_271) (append l_271 l_171))))
(check-sat)
; Query: (= true (multiset_eq (append l_171 l_271) (append l_271 l_171)))
(push)
(assert
   (not (= true (multiset_eq (append l_171 l_271) (append l_271 l_171)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f27 () Inductive)
(declare-fun l42 () Inductive)
(declare-fun x25 () Inductive)
(declare-fun y1 () Inductive)
(declare-fun currentThread180 () Int)
(push)
(push)
; Assume: (= true (mem x25 l42))
(assert (= true (mem x25 l42)))
(check-sat)
(push)
; Assume: (= (_@ f27 x25) (_@ f27 y1))
(assert (= (_@ f27 x25) (_@ f27 y1)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l42 nil)
(assert (= l42 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h153 () Inductive)
(declare-fun t153 () Inductive)
(push)
(push)
; Assume: (= l42 (cons h153 t153))
(assert (= l42 (cons h153 t153)))
(check-sat)
(push)
(push)
; Assume: (= h153 x25)
(assert (= h153 x25))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f27 l42) (map0 f27 l42)))
(assert (= true (multiset_eq (map0 f27 l42) (map0 f27 l42))))
(check-sat)
; Query: (= true (multiset_eq (map0 f27 l42) (map0 f27 (cons y1 (remove x25 l42)))))
(push)
(assert
   (not
      (= true
         (multiset_eq (map0 f27 l42) (map0 f27 (cons y1 (remove x25 l42)))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h153 x25))
(assert (not (= h153 x25)))
(check-sat)
(push)
(push)
; Query: (= true (mem x25 t153))
(push)
(assert (not (= true (mem x25 t153))))
(check-sat)
(pop 1)
; Query: (= (_@ f27 x25) (_@ f27 y1))
(push)
(assert (not (= (_@ f27 x25) (_@ f27 y1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f27 t153) (map0 f27 (cons y1 (remove x25 t153)))))
(assert
   (= true
      (multiset_eq (map0 f27 t153) (map0 f27 (cons y1 (remove x25 t153))))))
(check-sat)
; Query: (= true (multiset_eq (map0 f27 l42) (map0 f27 (cons y1 (remove x25 l42)))))
(push)
(assert
   (not
      (= true
         (multiset_eq (map0 f27 l42) (map0 f27 (cons y1 (remove x25 l42)))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun f28 () Inductive)
(declare-fun x26 () Inductive)
(declare-fun l43 () Inductive)
(declare-fun currentThread181 () Int)
(push)
(push)
; Assume: (= true (mem x26 l43))
(assert (= true (mem x26 l43)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l43 nil)
(assert (= l43 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h154 () Inductive)
(declare-fun t154 () Inductive)
(push)
(push)
; Assume: (= l43 (cons h154 t154))
(assert (= l43 (cons h154 t154)))
(check-sat)
(push)
(push)
; Assume: (= h154 x26)
(assert (= h154 x26))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f28 (remove x26 l43)) (map0 f28 (remove x26 l43))))
(assert
   (= true
      (multiset_eq (map0 f28 (remove x26 l43)) (map0 f28 (remove x26 l43)))))
(check-sat)
; Query: (= true (multiset_eq (remove (_@ f28 x26) (map0 f28 l43)) (map0 f28 (remove x26 l43))))
(push)
(assert
   (not
      (= true
         (multiset_eq (remove (_@ f28 x26) (map0 f28 l43))
            (map0 f28 (remove x26 l43))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h154 x26))
(assert (not (= h154 x26)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= (_@ f28 h154) (_@ f28 x26))
(assert (= (_@ f28 h154) (_@ f28 x26)))
(check-sat)
(push)
(push)
; Query: (= true (mem x26 t154))
(push)
(assert (not (= true (mem x26 t154))))
(check-sat)
(pop 1)
; Query: (= (_@ f28 x26) (_@ f28 h154))
(push)
(assert (not (= (_@ f28 x26) (_@ f28 h154))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (map0 f28 t154) (map0 f28 (cons h154 (remove x26 t154)))))
(assert
   (= true
      (multiset_eq (map0 f28 t154) (map0 f28 (cons h154 (remove x26 t154))))))
(check-sat)
; Query: (= true (multiset_eq (remove (_@ f28 x26) (map0 f28 l43)) (map0 f28 (remove x26 l43))))
(push)
(assert
   (not
      (= true
         (multiset_eq (remove (_@ f28 x26) (map0 f28 l43))
            (map0 f28 (remove x26 l43))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= (_@ f28 h154) (_@ f28 x26)))
(assert (not (= (_@ f28 h154) (_@ f28 x26))))
(check-sat)
(push)
(push)
; Query: (= true (mem x26 t154))
(push)
(assert (not (= true (mem x26 t154))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (remove (_@ f28 x26) (map0 f28 t154)) (map0 f28 (remove x26 t154))))
(assert
   (= true
      (multiset_eq (remove (_@ f28 x26) (map0 f28 t154))
         (map0 f28 (remove x26 t154)))))
(check-sat)
; Query: (= true (multiset_eq (remove (_@ f28 x26) (map0 f28 l43)) (map0 f28 (remove x26 l43))))
(push)
(assert
   (not
      (= true
         (multiset_eq (remove (_@ f28 x26) (map0 f28 l43))
            (map0 f28 (remove x26 l43))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun el38 () Inductive)
(declare-fun l_172 () Inductive)
(declare-fun l_272 () Inductive)
(declare-fun currentThread182 () Int)
(push)
(push)
; Assume: (= true (mem el38 l_272))
(assert (= true (mem el38 l_272)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_172 nil)
(assert (= l_172 nil))
(check-sat)
; Query: (= true (mem el38 l_272))
(push)
(assert (not (= true (mem el38 l_272))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (cons el38 (remove el38 l_272)) l_272))
(assert (= true (multiset_eq (cons el38 (remove el38 l_272)) l_272)))
(check-sat)
; Query: (= true (multiset_eq (cons el38 (remove el38 l_272)) l_272))
(push)
(assert (not (= true (multiset_eq (cons el38 (remove el38 l_272)) l_272))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq l_272 (cons el38 (remove el38 l_272))))
(assert (= true (multiset_eq l_272 (cons el38 (remove el38 l_272)))))
(check-sat)
; Query: (= true (multiset_eq (append l_172 l_272) (append (cons el38 l_172) (remove el38 l_272))))
(push)
(assert
   (not
      (= true
         (multiset_eq (append l_172 l_272)
            (append (cons el38 l_172) (remove el38 l_272))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h155 () Inductive)
(declare-fun t155 () Inductive)
(push)
(push)
; Assume: (= l_172 (cons h155 t155))
(assert (= l_172 (cons h155 t155)))
(check-sat)
; Query: (= true (mem el38 l_272))
(push)
(assert (not (= true (mem el38 l_272))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append t155 l_272) (append (cons el38 t155) (remove el38 l_272))))
(assert
   (= true
      (multiset_eq (append t155 l_272)
         (append (cons el38 t155) (remove el38 l_272)))))
(check-sat)
; Query: (= true (multiset_eq (append l_172 l_272) (append (cons el38 l_172) (remove el38 l_272))))
(push)
(assert
   (not
      (= true
         (multiset_eq (append l_172 l_272)
            (append (cons el38 l_172) (remove el38 l_272))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x27 () Inductive)
(declare-fun l_173 () Inductive)
(declare-fun l_273 () Inductive)
(declare-fun currentThread183 () Int)
(push)
(push)
; Assume: (= true (mem x27 l_273))
(assert (= true (mem x27 l_273)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_173 nil)
(assert (= l_173 nil))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (remove x27 l_273) (remove x27 l_273)))
(assert (= true (multiset_eq (remove x27 l_273) (remove x27 l_273))))
(check-sat)
; Query: (= true (multiset_eq (remove x27 (append l_173 l_273)) (append l_173 (remove x27 l_273))))
(push)
(assert
   (not
      (= true
         (multiset_eq (remove x27 (append l_173 l_273))
            (append l_173 (remove x27 l_273))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h156 () Inductive)
(declare-fun t156 () Inductive)
(push)
(push)
; Assume: (= l_173 (cons h156 t156))
(assert (= l_173 (cons h156 t156)))
(check-sat)
(push)
(push)
; Assume: (= x27 h156)
(assert (= x27 h156))
(check-sat)
(push)
(push)
; Query: (= true (mem x27 l_273))
(push)
(assert (not (= true (mem x27 l_273))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append t156 l_273) (append (cons x27 t156) (remove x27 l_273))))
(assert
   (= true
      (multiset_eq (append t156 l_273)
         (append (cons x27 t156) (remove x27 l_273)))))
(check-sat)
; Query: (= true (multiset_eq (append t156 l_273) (append (cons x27 t156) (remove x27 l_273))))
(push)
(assert
   (not
      (= true
         (multiset_eq (append t156 l_273)
            (append (cons x27 t156) (remove x27 l_273))))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (remove x27 (append l_173 l_273)) (append l_173 (remove x27 l_273))))
(push)
(assert
   (not
      (= true
         (multiset_eq (remove x27 (append l_173 l_273))
            (append l_173 (remove x27 l_273))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= x27 h156))
(assert (not (= x27 h156)))
(check-sat)
(push)
(push)
; Query: (= true (mem x27 l_273))
(push)
(assert (not (= true (mem x27 l_273))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (remove x27 (append t156 l_273)) (append t156 (remove x27 l_273))))
(assert
   (= true
      (multiset_eq (remove x27 (append t156 l_273))
         (append t156 (remove x27 l_273)))))
(check-sat)
; Query: (= true (multiset_eq (remove x27 (append t156 l_273)) (append t156 (remove x27 l_273))))
(push)
(assert
   (not
      (= true
         (multiset_eq (remove x27 (append t156 l_273))
            (append t156 (remove x27 l_273))))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (remove x27 (append l_173 l_273)) (append l_173 (remove x27 l_273))))
(push)
(assert
   (not
      (= true
         (multiset_eq (remove x27 (append l_173 l_273))
            (append l_173 (remove x27 l_273))))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (remove x27 (append l_173 l_273)) (append l_173 (remove x27 l_273))))
(push)
(assert
   (not
      (= true
         (multiset_eq (remove x27 (append l_173 l_273))
            (append l_173 (remove x27 l_273))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_174 () Inductive)
(declare-fun l_274 () Inductive)
(declare-fun x28 () Inductive)
(declare-fun currentThread184 () Int)
(push)
(push)
; Assume: (= true (multiset_eq l_174 l_274))
(assert (= true (multiset_eq l_174 l_274)))
(check-sat)
(push)
(push)
; Query: (= true (multiset_eq l_174 l_274))
(push)
(assert (not (= true (multiset_eq l_174 l_274))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq l_274 l_174))
(assert (= true (multiset_eq l_274 l_174)))
(check-sat)
; Query: (= true (multiset_eq l_174 l_274))
(push)
(assert (not (= true (multiset_eq l_174 l_274))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_174 l_274))
(assert (= true (msubset l_174 l_274)))
(check-sat)
(push)
; Assume: (= true (msubset l_274 l_174))
(assert (= true (msubset l_274 l_174)))
(check-sat)
; Query: (= true (multiset_eq l_274 l_174))
(push)
(assert (not (= true (multiset_eq l_274 l_174))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_274 l_174))
(assert (= true (msubset l_274 l_174)))
(check-sat)
(push)
; Assume: (= true (msubset l_174 l_274))
(assert (= true (msubset l_174 l_274)))
(check-sat)
; Query: (= true (msubset l_174 l_274))
(push)
(assert (not (= true (msubset l_174 l_274))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_174 (cons x28 l_274)))
(assert (= true (msubset l_174 (cons x28 l_274))))
(check-sat)
; Query: (= true (msubset l_274 l_174))
(push)
(assert (not (= true (msubset l_274 l_174))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (msubset l_274 (cons x28 l_174)))
(assert (= true (msubset l_274 (cons x28 l_174))))
(check-sat)
; Query: (= true (msubset (cons x28 l_174) (cons x28 l_274)))
(push)
(assert (not (= true (msubset (cons x28 l_174) (cons x28 l_274)))))
(check-sat)
(pop 1)
; Query: (= true (msubset (cons x28 l_274) (cons x28 l_174)))
(push)
(assert (not (= true (msubset (cons x28 l_274) (cons x28 l_174)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (cons x28 l_174) (cons x28 l_274)))
(assert (= true (multiset_eq (cons x28 l_174) (cons x28 l_274))))
(check-sat)
; Query: (= true (multiset_eq (cons x28 l_174) (cons x28 l_274)))
(push)
(assert (not (= true (multiset_eq (cons x28 l_174) (cons x28 l_274)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(declare-fun get_some (Inductive) Inductive)
(declare-fun _@get_some () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@get_some var) (get_some var))
         :pattern ((_@ _@get_some var)))))
(declare-fun forall_2 (Inductive Inductive Inductive) Bool)
(declare-fun _@forall_2 () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (!
         (= (unbox_bool (_@ (_@ (_@ _@forall_2 var) var0) var1))
            (forall_2 var var0 var1))
         :pattern ((_@ (_@ (_@ _@forall_2 var) var0) var1)))))
(declare-fun forall_idx (Inductive Int Inductive) Bool)
(declare-fun _@forall_idx () Inductive)
(assert
   (forall ((var Inductive) (var0 Int) (var1 Inductive))
      (!
         (= (unbox_bool (_@ (_@ (_@ _@forall_idx var) (box_int var0)) var1))
            (forall_idx var var0 var1))
         :pattern ((_@ (_@ (_@ _@forall_idx var) (box_int var0)) var1)))))
(declare-fun no_dups (Inductive) Bool)
(declare-fun _@no_dups () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_bool (_@ _@no_dups var)) (no_dups var))
         :pattern ((_@ _@no_dups var)))))
(declare-fun gt (Int Int) Bool)
(declare-fun _@gt () Inductive)
(assert
   (forall ((var Int) (var0 Int))
      (!
         (= (unbox_bool (_@ (_@ _@gt (box_int var)) (box_int var0)))
            (gt var var0))
         :pattern ((_@ (_@ _@gt (box_int var)) (box_int var0))))))
(declare-fun ge (Int Int) Bool)
(declare-fun _@ge () Inductive)
(assert
   (forall ((var Int) (var0 Int))
      (!
         (= (unbox_bool (_@ (_@ _@ge (box_int var)) (box_int var0)))
            (ge var var0))
         :pattern ((_@ (_@ _@ge (box_int var)) (box_int var0))))))
(declare-fun lt (Int Int) Bool)
(declare-fun _@lt () Inductive)
(assert
   (forall ((var Int) (var0 Int))
      (!
         (= (unbox_bool (_@ (_@ _@lt (box_int var)) (box_int var0)))
            (lt var var0))
         :pattern ((_@ (_@ _@lt (box_int var)) (box_int var0))))))
(declare-fun le (Int Int) Bool)
(declare-fun _@le () Inductive)
(assert
   (forall ((var Int) (var0 Int))
      (!
         (= (unbox_bool (_@ (_@ _@le (box_int var)) (box_int var0)))
            (le var var0))
         :pattern ((_@ (_@ _@le (box_int var)) (box_int var0))))))
(declare-fun eq (Inductive Inductive) Bool)
(declare-fun _@eq () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@eq var) var0)) (eq var var0))
         :pattern ((_@ (_@ _@eq var) var0)))))
(declare-fun length_eq (Int Inductive) Bool)
(declare-fun _@length_eq () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (unbox_bool (_@ (_@ _@length_eq (box_int var)) var0))
            (length_eq var var0))
         :pattern ((_@ (_@ _@length_eq (box_int var)) var0)))))
(declare-fun opt_no_dups (Inductive) Bool)
(declare-fun _@opt_no_dups () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_bool (_@ _@opt_no_dups var)) (opt_no_dups var))
         :pattern ((_@ _@opt_no_dups var)))))
(declare-fun neq (Inductive Inductive) Bool)
(declare-fun _@neq () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (unbox_bool (_@ (_@ _@neq var) var0)) (neq var var0))
         :pattern ((_@ (_@ _@neq var) var0)))))
(declare-fun nat_ge (Int Inductive) Bool)
(declare-fun _@nat_ge () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (unbox_bool (_@ (_@ _@nat_ge (box_int var)) var0))
            (nat_ge var var0))
         :pattern ((_@ (_@ _@nat_ge (box_int var)) var0)))))
(declare-fun nat_lt (Int Inductive) Bool)
(declare-fun _@nat_lt () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (unbox_bool (_@ (_@ _@nat_lt (box_int var)) var0))
            (nat_lt var var0))
         :pattern ((_@ (_@ _@nat_lt (box_int var)) var0)))))
(declare-fun sup (Inductive Inductive Inductive) Inductive)
(declare-fun _@sup () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (! (= (_@ (_@ (_@ _@sup var) var0) var1) (sup var var0 var1))
         :pattern ((_@ (_@ (_@ _@sup var) var0) var1)))))
(declare-fun repeat_n (Inductive Inductive) Inductive)
(declare-fun _@repeat_n () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@repeat_n var) var0) (repeat_n var var0))
         :pattern ((_@ (_@ _@repeat_n var) var0)))))
(declare-fun forall_2_nth () Int)
(declare-fun forall_2_update () Int)
(declare-fun forall_idx_nth () Int)
(declare-fun forall_idx_update () Int)
(declare-fun forall_idx_tail () Int)
(declare-fun extract_prop_by_idx () Int)
(declare-fun some_get_some () Int)
(declare-fun forall_ge_lower () Int)
(declare-fun distinct_ge () Int)
(declare-fun ge_le_ge () Int)
(declare-fun lt_le_lt () Int)
(declare-fun rem_preserves_opt_no_dups () Int)
(declare-fun no_dups_same () Int)
(declare-fun less_and_not_eq_lesser () Int)
(declare-fun forall_sup_map () Int)
(declare-fun two_inequalities_give_eq () Int)
(declare-fun repeat_n_length () Int)
(declare-fun lower_limit_ge_than () Int)
(declare-fun upper_limit_nat_lt () Int)
(declare-fun nat_lt_and_ge_disjoint () Int)
(declare-fun lower_and_upper_limit_complement () Int)
(declare-fun separated_by_bnd_disjoint () Int)
(declare-fun lt_and_ge_false () Int)
(declare-fun note () Int)
(declare-fun nth_map () Int)
; set_fpclauses
; function get_some
; switching on argument number 0
; constructor some
(assert
   (forall ((var Inductive))
      (! (= (get_some (some var)) var) :pattern ((get_some (some var))))))
; constructor none
(assert (= (get_some none) default_value))
(declare-fun switch_expression_1_3
   (Inductive Inductive Inductive Inductive Inductive Inductive) Bool)
; set_fpclauses
; function switch_expression_1_3
; switching on argument number 0
; constructor nil
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Inductive))
      (! (= (switch_expression_1_3 nil var var0 var1 var2 var3) true)
         :pattern ((switch_expression_1_3 nil var var0 var1 var2 var3)))))
; constructor cons
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Inductive) (var4 Inductive) (var5 Inductive))
      (!
         (= (switch_expression_1_3 (cons var var0) var1 var2 var3 var4 var5)
            (and (unbox_bool (_@ (_@ var1 var5) var))
               (forall_2 var4 var0 var1)))
         :pattern
         ((switch_expression_1_3 (cons var var0) var1 var2 var3 var4 var5)))))
; set_fpclauses
; function forall_2
; switching on argument number 0
; constructor cons
(declare-fun switch_expression_1_4
   (Inductive Inductive Inductive Inductive Inductive Inductive) Bool)
; set_fpclauses
; function switch_expression_1_4
; switching on argument number 0
; constructor nil
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Inductive))
      (! (= (switch_expression_1_4 nil var var0 var1 var2 var3) true)
         :pattern ((switch_expression_1_4 nil var var0 var1 var2 var3)))))
; constructor cons
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Inductive) (var4 Inductive) (var5 Inductive))
      (!
         (= (switch_expression_1_4 (cons var var0) var1 var2 var3 var4 var5)
            (and (unbox_bool (_@ (_@ var1 var5) var))
               (forall_2 var4 var0 var1)))
         :pattern
         ((switch_expression_1_4 (cons var var0) var1 var2 var3 var4 var5)))))
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (forall_2 (cons var var0) var1 var2)
            (switch_expression_1_4 var1 var2 var1 (cons var var0) var0 var))
         :pattern ((forall_2 (cons var var0) var1 var2)))))
; constructor nil
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (forall_2 nil var var0) true) :pattern ((forall_2 nil var var0)))))
; set_fpclauses
; function forall_idx
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int) (var2 Inductive))
      (!
         (= (forall_idx (cons var var0) var1 var2)
            (and (unbox_bool (_@ (_@ var2 (box_int var1)) var))
               (forall_idx var0 (+ var1 1) var2)))
         :pattern ((forall_idx (cons var var0) var1 var2)))))
; constructor nil
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (forall_idx nil var var0) true)
         :pattern ((forall_idx nil var var0)))))
; set_fpclauses
; function no_dups
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (no_dups (cons var var0))
            (and (not (mem var var0)) (no_dups var0)))
         :pattern ((no_dups (cons var var0))))))
; constructor nil
(assert (= (no_dups nil) true))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (gt var var0) (< var var0)) :pattern ((gt var var0)))))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (ge var var0) (<= var var0)) :pattern ((ge var var0)))))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (lt var var0) (< var0 var)) :pattern ((lt var var0)))))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (le var var0) (<= var0 var)) :pattern ((le var var0)))))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (eq var var0) (= var var0)) :pattern ((eq var var0)))))
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (length_eq var var0) (= var (length var0)))
         :pattern ((length_eq var var0)))))
; set_fpclauses
; function opt_no_dups
; switching on argument number 0
; constructor cons
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (opt_no_dups (cons var var0))
            (and (opt_no_dups var0) (or (= var none) (not (mem var var0)))))
         :pattern ((opt_no_dups (cons var var0))))))
; constructor nil
(assert (= (opt_no_dups nil) true))
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (neq var var0) (not (= var var0))) :pattern ((neq var var0)))))
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (nat_ge var var0) (<= var (int_of_nat var0)))
         :pattern ((nat_ge var var0)))))
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (nat_lt var var0) (< (int_of_nat var0) var))
         :pattern ((nat_lt var var0)))))
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive))
      (! (= (sup var var0 var1) (_@ var (_@ var0 var1)))
         :pattern ((sup var var0 var1)))))
; set_fpclauses
; function repeat_n
; switching on argument number 0
; constructor succ
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (repeat_n (succ var) var0) (cons var0 (repeat_n var var0)))
         :pattern ((repeat_n (succ var) var0)))))
; constructor zero
(assert
   (forall ((var Inductive))
      (! (= (repeat_n zero var) nil) :pattern ((repeat_n zero var)))))
; Assert: (= (func_rank forall_2_nth) 401)
(assert (= (func_rank forall_2_nth) 401))
; Assert: (= (func_rank forall_2_update) 402)
(assert (= (func_rank forall_2_update) 402))
; Assert: (= (func_rank forall_idx_nth) 403)
(assert (= (func_rank forall_idx_nth) 403))
; Assert: (= (func_rank forall_idx_update) 404)
(assert (= (func_rank forall_idx_update) 404))
; Assert: (= (func_rank forall_idx_tail) 405)
(assert (= (func_rank forall_idx_tail) 405))
; Assert: (= (func_rank extract_prop_by_idx) 406)
(assert (= (func_rank extract_prop_by_idx) 406))
; Assert: (= (func_rank some_get_some) 407)
(assert (= (func_rank some_get_some) 407))
; Assert: (= (func_rank forall_ge_lower) 408)
(assert (= (func_rank forall_ge_lower) 408))
; Assert: (= (func_rank distinct_ge) 409)
(assert (= (func_rank distinct_ge) 409))
; Assert: (= (func_rank ge_le_ge) 410)
(assert (= (func_rank ge_le_ge) 410))
; Assert: (= (func_rank lt_le_lt) 411)
(assert (= (func_rank lt_le_lt) 411))
; Assert: (= (func_rank rem_preserves_opt_no_dups) 412)
(assert (= (func_rank rem_preserves_opt_no_dups) 412))
; Assert: (= (func_rank no_dups_same) 413)
(assert (= (func_rank no_dups_same) 413))
; Assert: (= (func_rank less_and_not_eq_lesser) 414)
(assert (= (func_rank less_and_not_eq_lesser) 414))
; Assert: (= (func_rank forall_sup_map) 415)
(assert (= (func_rank forall_sup_map) 415))
; Assert: (= (func_rank two_inequalities_give_eq) 416)
(assert (= (func_rank two_inequalities_give_eq) 416))
; Assert: (= (func_rank repeat_n_length) 417)
(assert (= (func_rank repeat_n_length) 417))
; Assert: (= (func_rank lower_limit_ge_than) 418)
(assert (= (func_rank lower_limit_ge_than) 418))
; Assert: (= (func_rank upper_limit_nat_lt) 419)
(assert (= (func_rank upper_limit_nat_lt) 419))
; Assert: (= (func_rank nat_lt_and_ge_disjoint) 420)
(assert (= (func_rank nat_lt_and_ge_disjoint) 420))
; Assert: (= (func_rank lower_and_upper_limit_complement) 421)
(assert (= (func_rank lower_and_upper_limit_complement) 421))
; Assert: (= (func_rank separated_by_bnd_disjoint) 422)
(assert (= (func_rank separated_by_bnd_disjoint) 422))
; Assert: (= (func_rank lt_and_ge_false) 423)
(assert (= (func_rank lt_and_ge_false) 423))
; Assert: (= (func_rank note) 424)
(assert (= (func_rank note) 424))
; Assert: (= (func_rank nth_map) 425)
(assert (= (func_rank nth_map) 425))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(push)
(declare-fun l_175 () Inductive)
(declare-fun l_275 () Inductive)
(declare-fun f29 () Inductive)
(declare-fun index3 () Int)
(declare-fun currentThread185 () Int)
(push)
(push)
; Assume: (<= 0 index3)
(assert (<= 0 index3))
(check-sat)
(push)
; Assume: (< index3 (length l_175))
(assert (< index3 (length l_175)))
(check-sat)
(push)
; Assume: (< index3 (length l_275))
(assert (< index3 (length l_275)))
(check-sat)
(push)
; Assume: (= true (forall_2 l_175 l_275 f29))
(assert (= true (forall_2 l_175 l_275 f29)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_175 nil)
(assert (= l_175 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h_1 () Inductive)
(declare-fun t_1 () Inductive)
(push)
(push)
; Assume: (= l_175 (cons h_1 t_1))
(assert (= l_175 (cons h_1 t_1)))
(check-sat)
(push)
(push)
; Assume: (= l_275 nil)
(assert (= l_275 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h_2 () Inductive)
(declare-fun t_2 () Inductive)
(push)
(push)
; Assume: (= l_275 (cons h_2 t_2))
(assert (= l_275 (cons h_2 t_2)))
(check-sat)
(push)
(push)
; Assume: (= index3 0)
(assert (= index3 0))
(check-sat)
(push)
; Query: (= true (unbox_bool (_@ (_@ f29 (nth index3 l_175)) (nth index3 l_275))))
(push)
(assert
   (not
      (= true
         (unbox_bool (_@ (_@ f29 (nth index3 l_175)) (nth index3 l_275))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= index3 0))
(assert (not (= index3 0)))
(check-sat)
(push)
; Query: (<= 0 (- index3 1))
(push)
(assert (not (<= 0 (- index3 1))))
(check-sat)
(pop 1)
; Query: (< (- index3 1) (length t_1))
(push)
(assert (not (< (- index3 1) (length t_1))))
(check-sat)
(pop 1)
; Query: (< (- index3 1) (length t_2))
(push)
(assert (not (< (- index3 1) (length t_2))))
(check-sat)
(pop 1)
; Query: (= true (forall_2 t_1 t_2 f29))
(push)
(assert (not (= true (forall_2 t_1 t_2 f29))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (unbox_bool (_@ (_@ f29 (nth (- index3 1) t_1)) (nth (- index3 1) t_2))))
(assert
   (= true
      (unbox_bool
         (_@ (_@ f29 (nth (- index3 1) t_1)) (nth (- index3 1) t_2)))))
(check-sat)
; Query: (= true (unbox_bool (_@ (_@ f29 (nth index3 l_175)) (nth index3 l_275))))
(push)
(assert
   (not
      (= true
         (unbox_bool (_@ (_@ f29 (nth index3 l_175)) (nth index3 l_275))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_176 () Inductive)
(declare-fun l_276 () Inductive)
(declare-fun f30 () Inductive)
(declare-fun i11 () Int)
(declare-fun v_1 () Inductive)
(declare-fun v_2 () Inductive)
(declare-fun currentThread186 () Int)
(push)
(push)
; Assume: (= true (forall_2 l_176 l_276 f30))
(assert (= true (forall_2 l_176 l_276 f30)))
(check-sat)
(push)
; Assume: (= true (unbox_bool (_@ (_@ f30 v_1) v_2)))
(assert (= true (unbox_bool (_@ (_@ f30 v_1) v_2))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_176 nil)
(assert (= l_176 nil))
(check-sat)
; Query: (= true (forall_2 (update i11 v_1 l_176) (update i11 v_2 l_276) f30))
(push)
(assert
   (not
      (= true (forall_2 (update i11 v_1 l_176) (update i11 v_2 l_276) f30))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h_10 () Inductive)
(declare-fun t_10 () Inductive)
(push)
(push)
; Assume: (= l_176 (cons h_10 t_10))
(assert (= l_176 (cons h_10 t_10)))
(check-sat)
(push)
(push)
; Assume: (= l_276 nil)
(assert (= l_276 nil))
(check-sat)
; Query: (= true (forall_2 (update i11 v_1 l_176) (update i11 v_2 l_276) f30))
(push)
(assert
   (not
      (= true (forall_2 (update i11 v_1 l_176) (update i11 v_2 l_276) f30))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h_20 () Inductive)
(declare-fun t_20 () Inductive)
(push)
(push)
; Assume: (= l_276 (cons h_20 t_20))
(assert (= l_276 (cons h_20 t_20)))
(check-sat)
(push)
(push)
; Assume: (not (= i11 0))
(assert (not (= i11 0)))
(check-sat)
(push)
; Query: (= true (forall_2 t_10 t_20 f30))
(push)
(assert (not (= true (forall_2 t_10 t_20 f30))))
(check-sat)
(pop 1)
; Query: (= true (unbox_bool (_@ (_@ f30 v_1) v_2)))
(push)
(assert (not (= true (unbox_bool (_@ (_@ f30 v_1) v_2)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall_2 (update (- i11 1) v_1 t_10) (update (- i11 1) v_2 t_20) f30))
(assert
   (= true
      (forall_2 (update (- i11 1) v_1 t_10) (update (- i11 1) v_2 t_20) f30)))
(check-sat)
; Query: (= true (forall_2 (update i11 v_1 l_176) (update i11 v_2 l_276) f30))
(push)
(assert
   (not
      (= true (forall_2 (update i11 v_1 l_176) (update i11 v_2 l_276) f30))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= i11 0)))
(assert (not (not (= i11 0))))
(check-sat)
(push)
; Query: (= true (forall_2 (update i11 v_1 l_176) (update i11 v_2 l_276) f30))
(push)
(assert
   (not
      (= true (forall_2 (update i11 v_1 l_176) (update i11 v_2 l_276) f30))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun values () Inductive)
(declare-fun idx () Int)
(declare-fun prop2 () Inductive)
(declare-fun i12 () Int)
(declare-fun currentThread187 () Int)
(push)
(push)
; Assume: (<= 0 i12)
(assert (<= 0 i12))
(check-sat)
(push)
; Assume: (< i12 (length values))
(assert (< i12 (length values)))
(check-sat)
(push)
; Assume: (= true (forall_idx values idx prop2))
(assert (= true (forall_idx values idx prop2)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= values nil)
(assert (= values nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h157 () Inductive)
(declare-fun t157 () Inductive)
(push)
(push)
; Assume: (= values (cons h157 t157))
(assert (= values (cons h157 t157)))
(check-sat)
(push)
(push)
; Assume: (< 0 i12)
(assert (< 0 i12))
(check-sat)
(push)
; Query: (<= 0 (- i12 1))
(push)
(assert (not (<= 0 (- i12 1))))
(check-sat)
(pop 1)
; Query: (< (- i12 1) (length t157))
(push)
(assert (not (< (- i12 1) (length t157))))
(check-sat)
(pop 1)
; Query: (= true (forall_idx t157 (+ idx 1) prop2))
(push)
(assert (not (= true (forall_idx t157 (+ idx 1) prop2))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (unbox_bool (_@ (_@ prop2 (box_int (+ (+ idx 1) (- i12 1)))) (nth (- i12 1) t157))))
(assert
   (= true
      (unbox_bool
         (_@ (_@ prop2 (box_int (+ (+ idx 1) (- i12 1))))
            (nth (- i12 1) t157)))))
(check-sat)
; Query: (= true (unbox_bool (_@ (_@ prop2 (box_int (+ idx i12))) (nth i12 values))))
(push)
(assert
   (not
      (= true
         (unbox_bool (_@ (_@ prop2 (box_int (+ idx i12))) (nth i12 values))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (< 0 i12))
(assert (not (< 0 i12)))
(check-sat)
(push)
; Query: (= true (unbox_bool (_@ (_@ prop2 (box_int (+ idx i12))) (nth i12 values))))
(push)
(assert
   (not
      (= true
         (unbox_bool (_@ (_@ prop2 (box_int (+ idx i12))) (nth i12 values))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun values0 () Inductive)
(declare-fun idx0 () Int)
(declare-fun prop3 () Inductive)
(declare-fun i13 () Int)
(declare-fun v0 () Inductive)
(declare-fun currentThread188 () Int)
(push)
(push)
; Assume: (= true (forall_idx values0 idx0 prop3))
(assert (= true (forall_idx values0 idx0 prop3)))
(check-sat)
(push)
; Assume: (= true (unbox_bool (_@ (_@ prop3 (box_int (+ idx0 i13))) v0)))
(assert (= true (unbox_bool (_@ (_@ prop3 (box_int (+ idx0 i13))) v0))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= values0 nil)
(assert (= values0 nil))
(check-sat)
; Query: (= true (forall_idx (update i13 v0 values0) idx0 prop3))
(push)
(assert (not (= true (forall_idx (update i13 v0 values0) idx0 prop3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h158 () Inductive)
(declare-fun t158 () Inductive)
(push)
(push)
; Assume: (= values0 (cons h158 t158))
(assert (= values0 (cons h158 t158)))
(check-sat)
(push)
(push)
; Assume: (not (= i13 0))
(assert (not (= i13 0)))
(check-sat)
(push)
; Query: (= true (forall_idx t158 (+ idx0 1) prop3))
(push)
(assert (not (= true (forall_idx t158 (+ idx0 1) prop3))))
(check-sat)
(pop 1)
; Query: (= true (unbox_bool (_@ (_@ prop3 (box_int (+ (+ idx0 1) (- i13 1)))) v0)))
(push)
(assert
   (not
      (= true
         (unbox_bool (_@ (_@ prop3 (box_int (+ (+ idx0 1) (- i13 1)))) v0)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall_idx (update (- i13 1) v0 t158) (+ idx0 1) prop3))
(assert (= true (forall_idx (update (- i13 1) v0 t158) (+ idx0 1) prop3)))
(check-sat)
; Query: (= true (forall_idx (update i13 v0 values0) idx0 prop3))
(push)
(assert (not (= true (forall_idx (update i13 v0 values0) idx0 prop3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (not (= i13 0)))
(assert (not (not (= i13 0))))
(check-sat)
(push)
; Query: (= true (forall_idx (update i13 v0 values0) idx0 prop3))
(push)
(assert (not (= true (forall_idx (update i13 v0 values0) idx0 prop3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun values1 () Inductive)
(declare-fun idx1 () Int)
(declare-fun prop4 () Inductive)
(declare-fun currentThread189 () Int)
(push)
(push)
; Assume: (= true (forall_idx values1 idx1 prop4))
(assert (= true (forall_idx values1 idx1 prop4)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= values1 nil)
(assert (= values1 nil))
(check-sat)
; Query: (= true (forall_idx (tail values1) (+ idx1 1) prop4))
(push)
(assert (not (= true (forall_idx (tail values1) (+ idx1 1) prop4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h159 () Inductive)
(declare-fun t159 () Inductive)
(push)
(push)
; Assume: (= values1 (cons h159 t159))
(assert (= values1 (cons h159 t159)))
(check-sat)
; Query: (= true (forall_idx (tail values1) (+ idx1 1) prop4))
(push)
(assert (not (= true (forall_idx (tail values1) (+ idx1 1) prop4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun v1 () Inductive)
(declare-fun prop5 () Inductive)
(declare-fun start_index () Int)
(declare-fun index4 () Int)
(declare-fun currentThread190 () Int)
(push)
(push)
; Assume: (= true (forall_idx v1 start_index prop5))
(assert (= true (forall_idx v1 start_index prop5)))
(check-sat)
(push)
; Assume: (<= 0 (- index4 start_index))
(assert (<= 0 (- index4 start_index)))
(check-sat)
(push)
; Assume: (< (- index4 start_index) (length v1))
(assert (< (- index4 start_index) (length v1)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= v1 nil)
(assert (= v1 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h160 () Inductive)
(declare-fun t160 () Inductive)
(push)
(push)
; Assume: (= v1 (cons h160 t160))
(assert (= v1 (cons h160 t160)))
(check-sat)
(push)
(push)
; Assume: (= start_index index4)
(assert (= start_index index4))
(check-sat)
(push)
(push)
; Query: (= true (unbox_bool (_@ (_@ prop5 (box_int index4)) (nth (- index4 start_index) v1))))
(push)
(assert
   (not
      (= true
         (unbox_bool
            (_@ (_@ prop5 (box_int index4)) (nth (- index4 start_index) v1))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= start_index index4))
(assert (not (= start_index index4)))
(check-sat)
(push)
(push)
; Query: (= true (forall_idx t160 (+ start_index 1) prop5))
(push)
(assert (not (= true (forall_idx t160 (+ start_index 1) prop5))))
(check-sat)
(pop 1)
; Query: (<= 0 (- index4 (+ start_index 1)))
(push)
(assert (not (<= 0 (- index4 (+ start_index 1)))))
(check-sat)
(pop 1)
; Query: (< (- index4 (+ start_index 1)) (length t160))
(push)
(assert (not (< (- index4 (+ start_index 1)) (length t160))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (unbox_bool (_@ (_@ prop5 (box_int index4)) (nth (- index4 (+ start_index 1)) t160))))
(assert
   (= true
      (unbox_bool
         (_@ (_@ prop5 (box_int index4))
            (nth (- index4 (+ start_index 1)) t160)))))
(check-sat)
; Query: (= true (unbox_bool (_@ (_@ prop5 (box_int index4)) (nth (- index4 start_index) v1))))
(push)
(assert
   (not
      (= true
         (unbox_bool
            (_@ (_@ prop5 (box_int index4)) (nth (- index4 start_index) v1))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x29 () Inductive)
(declare-fun currentThread191 () Int)
(push)
(push)
; Assume: (not (= x29 none))
(assert (not (= x29 none)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= x29 none)
(assert (= x29 none))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun v2 () Inductive)
(push)
(push)
; Assume: (= x29 (some v2))
(assert (= x29 (some v2)))
(check-sat)
; Query: (= (some (get_some x29)) x29)
(push)
(assert (not (= (some (get_some x29)) x29)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs27 () Inductive)
(declare-fun low_bound () Int)
(declare-fun x30 () Int)
(declare-fun currentThread192 () Int)
(push)
(push)
; Assume: (= true (forall0 xs27 (_@ _@ge (box_int low_bound))))
(assert (= true (forall0 xs27 (_@ _@ge (box_int low_bound)))))
(check-sat)
(push)
; Assume: (< x30 low_bound)
(assert (< x30 low_bound))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs27 nil)
(assert (= xs27 nil))
(check-sat)
; Query: (not (mem (box_int x30) xs27))
(push)
(assert (not (not (mem (box_int x30) xs27))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x_0 () Int)
(declare-fun xs_0 () Inductive)
(push)
(push)
; Assume: (= xs27 (cons (box_int x_0) xs_0))
(assert (= xs27 (cons (box_int x_0) xs_0)))
(check-sat)
; Query: (= true (forall0 xs_0 (_@ _@ge (box_int low_bound))))
(push)
(assert (not (= true (forall0 xs_0 (_@ _@ge (box_int low_bound))))))
(check-sat)
(pop 1)
; Query: (< x30 low_bound)
(push)
(assert (not (< x30 low_bound)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (not (mem (box_int x30) xs_0))
(assert (not (mem (box_int x30) xs_0)))
(check-sat)
; Query: (not (mem (box_int x30) xs27))
(push)
(assert (not (not (mem (box_int x30) xs27))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs28 () Inductive)
(declare-fun low_bound0 () Int)
(declare-fun x31 () Int)
(declare-fun currentThread193 () Int)
(push)
(push)
; Assume: (= true (distinct0 xs28))
(assert (= true (distinct0 xs28)))
(check-sat)
(push)
; Assume: (= true (forall0 xs28 (_@ _@ge (box_int low_bound0))))
(assert (= true (forall0 xs28 (_@ _@ge (box_int low_bound0)))))
(check-sat)
(push)
; Assume: (< x31 low_bound0)
(assert (< x31 low_bound0))
(check-sat)
(push)
(push)
; Query: (= true (forall0 xs28 (_@ _@ge (box_int low_bound0))))
(push)
(assert (not (= true (forall0 xs28 (_@ _@ge (box_int low_bound0))))))
(check-sat)
(pop 1)
; Query: (< x31 low_bound0)
(push)
(assert (not (< x31 low_bound0)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (not (mem (box_int x31) xs28))
(assert (not (mem (box_int x31) xs28)))
(check-sat)
; Query: (= true (distinct0 (cons (box_int x31) xs28)))
(push)
(assert (not (= true (distinct0 (cons (box_int x31) xs28)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l44 () Inductive)
(declare-fun i14 () Int)
(declare-fun x32 () Int)
(declare-fun currentThread194 () Int)
(push)
(push)
; Assume: (<= x32 i14)
(assert (<= x32 i14))
(check-sat)
(push)
; Assume: (= true (forall0 l44 (_@ _@ge (box_int i14))))
(assert (= true (forall0 l44 (_@ _@ge (box_int i14)))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l44 nil)
(assert (= l44 nil))
(check-sat)
; Query: (= true (forall0 l44 (_@ _@ge (box_int x32))))
(push)
(assert (not (= true (forall0 l44 (_@ _@ge (box_int x32))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h161 () Int)
(declare-fun t161 () Inductive)
(push)
(push)
; Assume: (= l44 (cons (box_int h161) t161))
(assert (= l44 (cons (box_int h161) t161)))
(check-sat)
; Query: (<= x32 i14)
(push)
(assert (not (<= x32 i14)))
(check-sat)
(pop 1)
; Query: (= true (forall0 t161 (_@ _@ge (box_int i14))))
(push)
(assert (not (= true (forall0 t161 (_@ _@ge (box_int i14))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 t161 (_@ _@ge (box_int x32))))
(assert (= true (forall0 t161 (_@ _@ge (box_int x32)))))
(check-sat)
; Query: (= true (forall0 l44 (_@ _@ge (box_int x32))))
(push)
(assert (not (= true (forall0 l44 (_@ _@ge (box_int x32))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xs29 () Inductive)
(declare-fun bound () Int)
(declare-fun up_bound () Int)
(declare-fun currentThread195 () Int)
(push)
(push)
; Assume: (<= bound up_bound)
(assert (<= bound up_bound))
(check-sat)
(push)
; Assume: (= true (forall0 xs29 (_@ _@lt (box_int bound))))
(assert (= true (forall0 xs29 (_@ _@lt (box_int bound)))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= xs29 nil)
(assert (= xs29 nil))
(check-sat)
; Query: (= true (forall0 xs29 (_@ _@lt (box_int up_bound))))
(push)
(assert (not (= true (forall0 xs29 (_@ _@lt (box_int up_bound))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x_00 () Int)
(declare-fun xs_00 () Inductive)
(push)
(push)
; Assume: (= xs29 (cons (box_int x_00) xs_00))
(assert (= xs29 (cons (box_int x_00) xs_00)))
(check-sat)
; Query: (<= bound up_bound)
(push)
(assert (not (<= bound up_bound)))
(check-sat)
(pop 1)
; Query: (= true (forall0 xs_00 (_@ _@lt (box_int bound))))
(push)
(assert (not (= true (forall0 xs_00 (_@ _@lt (box_int bound))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 xs_00 (_@ _@lt (box_int up_bound))))
(assert (= true (forall0 xs_00 (_@ _@lt (box_int up_bound)))))
(check-sat)
; Query: (= true (forall0 xs29 (_@ _@lt (box_int up_bound))))
(push)
(assert (not (= true (forall0 xs29 (_@ _@lt (box_int up_bound))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun ks0 () Inductive)
(declare-fun i15 () Int)
(declare-fun currentThread196 () Int)
(push)
(push)
; Assume: (= true (opt_no_dups ks0))
(assert (= true (opt_no_dups ks0)))
(check-sat)
(push)
; Assume: (<= 0 i15)
(assert (<= 0 i15))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= ks0 nil)
(assert (= ks0 nil))
(check-sat)
; Query: (= true (opt_no_dups (update i15 none ks0)))
(push)
(assert (not (= true (opt_no_dups (update i15 none ks0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h162 () Inductive)
(declare-fun t162 () Inductive)
(push)
(push)
; Assume: (= ks0 (cons h162 t162))
(assert (= ks0 (cons h162 t162)))
(check-sat)
(push)
(push)
; Assume: (= i15 0)
(assert (= i15 0))
(check-sat)
(push)
(push)
; Query: (= true (opt_no_dups (update i15 none ks0)))
(push)
(assert (not (= true (opt_no_dups (update i15 none ks0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= i15 0))
(assert (not (= i15 0)))
(check-sat)
(push)
(push)
; Query: (= true (opt_no_dups t162))
(push)
(assert (not (= true (opt_no_dups t162))))
(check-sat)
(pop 1)
; Query: (<= 0 (- i15 1))
(push)
(assert (not (<= 0 (- i15 1))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (opt_no_dups (update (- i15 1) none t162)))
(assert (= true (opt_no_dups (update (- i15 1) none t162))))
(check-sat)
(push)
(push)
; Assume: (= h162 none)
(assert (= h162 none))
(check-sat)
(push)
(push)
; Query: (= true (opt_no_dups (update i15 none ks0)))
(push)
(assert (not (= true (opt_no_dups (update i15 none ks0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= h162 none))
(assert (not (= h162 none)))
(check-sat)
(push)
(push)
; Query: (= false (mem h162 t162))
(push)
(assert (not (= false (mem h162 t162))))
(check-sat)
(pop 1)
; Query: (not (= h162 none))
(push)
(assert (not (not (= h162 none))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (some (get_some h162)) h162)
(assert (= (some (get_some h162)) h162))
(check-sat)
; Query: (= false (mem (some (get_some h162)) t162))
(push)
(assert (not (= false (mem (some (get_some h162)) t162))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= false (mem (some (get_some h162)) (update (- i15 1) none t162)))
(assert (= false (mem (some (get_some h162)) (update (- i15 1) none t162))))
(check-sat)
; Query: (= true (opt_no_dups (update i15 none ks0)))
(push)
(assert (not (= true (opt_no_dups (update i15 none ks0)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun ks1 () Inductive)
(declare-fun k4 () Inductive)
(declare-fun n18 () Int)
(declare-fun m1 () Int)
(declare-fun currentThread197 () Int)
(push)
(push)
; Assume: (= true (opt_no_dups ks1))
(assert (= true (opt_no_dups ks1)))
(check-sat)
(push)
; Assume: (<= 0 n18)
(assert (<= 0 n18))
(check-sat)
(push)
; Assume: (< n18 (length ks1))
(assert (< n18 (length ks1)))
(check-sat)
(push)
; Assume: (<= 0 m1)
(assert (<= 0 m1))
(check-sat)
(push)
; Assume: (< m1 (length ks1))
(assert (< m1 (length ks1)))
(check-sat)
(push)
; Assume: (= (nth n18 ks1) (some k4))
(assert (= (nth n18 ks1) (some k4)))
(check-sat)
(push)
; Assume: (= (nth m1 ks1) (some k4))
(assert (= (nth m1 ks1) (some k4)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= ks1 nil)
(assert (= ks1 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h163 () Inductive)
(declare-fun t163 () Inductive)
(push)
(push)
; Assume: (= ks1 (cons h163 t163))
(assert (= ks1 (cons h163 t163)))
(check-sat)
(push)
(push)
; Assume: (= n18 0)
(assert (= n18 0))
(check-sat)
(push)
(push)
; Query: (= h163 (some k4))
(push)
(assert (not (= h163 (some k4))))
(check-sat)
(pop 1)
; Query: (not (mem h163 t163))
(push)
(assert (not (not (mem h163 t163))))
(check-sat)
(pop 1)
; Query: (= n18 m1)
(push)
(assert (not (= n18 m1)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= n18 0))
(assert (not (= n18 0)))
(check-sat)
(push)
(push)
(push)
; Assume: (= m1 0)
(assert (= m1 0))
(check-sat)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (= m1 0))
(assert (not (= m1 0)))
(check-sat)
(push)
(push)
; Query: (< 0 n18)
(push)
(assert (not (< 0 n18)))
(check-sat)
(pop 1)
; Query: (< 0 m1)
(push)
(assert (not (< 0 m1)))
(check-sat)
(pop 1)
; Query: (= true (opt_no_dups t163))
(push)
(assert (not (= true (opt_no_dups t163))))
(check-sat)
(pop 1)
; Query: (<= 0 (- n18 1))
(push)
(assert (not (<= 0 (- n18 1))))
(check-sat)
(pop 1)
; Query: (< (- n18 1) (length t163))
(push)
(assert (not (< (- n18 1) (length t163))))
(check-sat)
(pop 1)
; Query: (<= 0 (- m1 1))
(push)
(assert (not (<= 0 (- m1 1))))
(check-sat)
(pop 1)
; Query: (< (- m1 1) (length t163))
(push)
(assert (not (< (- m1 1) (length t163))))
(check-sat)
(pop 1)
; Query: (= (nth (- n18 1) t163) (some k4))
(push)
(assert (not (= (nth (- n18 1) t163) (some k4))))
(check-sat)
(pop 1)
; Query: (= (nth (- m1 1) t163) (some k4))
(push)
(assert (not (= (nth (- m1 1) t163) (some k4))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (- n18 1) (- m1 1))
(assert (= (- n18 1) (- m1 1)))
(check-sat)
; Query: (= n18 m1)
(push)
(assert (not (= n18 m1)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x33 () Inductive)
(declare-fun lim () Inductive)
(declare-fun currentThread198 () Int)
(push)
(push)
; Assume: (< (int_of_nat x33) (int_of_nat (succ lim)))
(assert (< (int_of_nat x33) (int_of_nat (succ lim))))
(check-sat)
(push)
; Assume: (not (= x33 lim))
(assert (not (= x33 lim)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= x33 zero)
(assert (= x33 zero))
(check-sat)
(push)
(push)
; Assume: (= lim zero)
(assert (= lim zero))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun ln () Inductive)
(push)
(push)
; Assume: (= lim (succ ln))
(assert (= lim (succ ln)))
(check-sat)
; Query: (< (int_of_nat x33) (int_of_nat lim))
(push)
(assert (not (< (int_of_nat x33) (int_of_nat lim))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun xn () Inductive)
(push)
(push)
; Assume: (= x33 (succ xn))
(assert (= x33 (succ xn)))
(check-sat)
(push)
(push)
; Assume: (= lim zero)
(assert (= lim zero))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun ln0 () Inductive)
(push)
(push)
; Assume: (= lim (succ ln0))
(assert (= lim (succ ln0)))
(check-sat)
; Query: (< (int_of_nat xn) (int_of_nat (succ ln0)))
(push)
(assert (not (< (int_of_nat xn) (int_of_nat (succ ln0)))))
(check-sat)
(pop 1)
; Query: (not (= xn ln0))
(push)
(assert (not (not (= xn ln0))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (< (int_of_nat xn) (int_of_nat ln0))
(assert (< (int_of_nat xn) (int_of_nat ln0)))
(check-sat)
; Query: (< (int_of_nat x33) (int_of_nat lim))
(push)
(assert (not (< (int_of_nat x33) (int_of_nat lim))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l45 () Inductive)
(declare-fun f_13 () Inductive)
(declare-fun f_23 () Inductive)
(declare-fun currentThread199 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l45 nil)
(assert (= l45 nil))
(check-sat)
; Query: (= (forall0 l45 (_@ (_@ _@sup f_13) f_23)) (forall0 (map0 f_23 l45) f_13))
(push)
(assert
   (not
      (= (forall0 l45 (_@ (_@ _@sup f_13) f_23))
         (forall0 (map0 f_23 l45) f_13))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h164 () Inductive)
(declare-fun t164 () Inductive)
(push)
(push)
; Assume: (= l45 (cons h164 t164))
(assert (= l45 (cons h164 t164)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (forall0 t164 (_@ (_@ _@sup f_13) f_23)) (forall0 (map0 f_23 t164) f_13))
(assert
   (= (forall0 t164 (_@ (_@ _@sup f_13) f_23))
      (forall0 (map0 f_23 t164) f_13)))
(check-sat)
; Query: (= (forall0 l45 (_@ (_@ _@sup f_13) f_23)) (forall0 (map0 f_23 l45) f_13))
(push)
(assert
   (not
      (= (forall0 l45 (_@ (_@ _@sup f_13) f_23))
         (forall0 (map0 f_23 l45) f_13))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun a0 () Int)
(declare-fun b0 () Int)
(declare-fun currentThread200 () Int)
(push)
(push)
; Assume: (<= a0 b0)
(assert (<= a0 b0))
(check-sat)
(push)
; Assume: (<= b0 a0)
(assert (<= b0 a0))
(check-sat)
(push)
(push)
; Query: (= a0 b0)
(push)
(assert (not (= a0 b0)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun len () Inductive)
(declare-fun x34 () Inductive)
(declare-fun currentThread201 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= len zero)
(assert (= len zero))
(check-sat)
; Query: (= (length (repeat_n len x34)) (int_of_nat len))
(push)
(assert (not (= (length (repeat_n len x34)) (int_of_nat len))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n19 () Inductive)
(push)
(push)
; Assume: (= len (succ n19))
(assert (= len (succ n19)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (length (repeat_n n19 x34)) (int_of_nat n19))
(assert (= (length (repeat_n n19 x34)) (int_of_nat n19)))
(check-sat)
; Query: (= (length (repeat_n len x34)) (int_of_nat len))
(push)
(assert (not (= (length (repeat_n len x34)) (int_of_nat len))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l46 () Inductive)
(declare-fun lim0 () Int)
(declare-fun currentThread202 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (= true (= l46 (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46))) (forall0 l46 (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd)))
(assert
   (=
      (= true
         (= l46
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46)))
      (forall0 l46 (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd))))
(check-sat)
(push)
; Assume: (= true (forall0 (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46) (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd)))
(assert
   (= true
      (forall0
         (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46)
         (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (forall0 (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46) (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd)) (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46)) (_@ _@nat_ge (box_int lim0))))
(assert
   (=
      (forall0
         (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46)
         (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd))
      (forall0
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46))
         (_@ _@nat_ge (box_int lim0)))))
(check-sat)
; Query: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd) l46)) (_@ _@nat_ge (box_int lim0))))
(push)
(assert
   (not
      (= true
         (forall0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim0))) _@snd)
                  l46))
            (_@ _@nat_ge (box_int lim0))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l47 () Inductive)
(declare-fun lim1 () Int)
(declare-fun currentThread203 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (= true (= l47 (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47))) (forall0 l47 (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd)))
(assert
   (=
      (= true
         (= l47
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47)))
      (forall0 l47 (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd))))
(check-sat)
(push)
; Assume: (= true (forall0 (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47) (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd)))
(assert
   (= true
      (forall0
         (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47)
         (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (forall0 (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47) (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd)) (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47)) (_@ _@nat_lt (box_int lim1))))
(assert
   (=
      (forall0
         (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47)
         (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd))
      (forall0
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47))
         (_@ _@nat_lt (box_int lim1)))))
(check-sat)
; Query: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd) l47)) (_@ _@nat_lt (box_int lim1))))
(push)
(assert
   (not
      (= true
         (forall0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim1))) _@snd)
                  l47))
            (_@ _@nat_lt (box_int lim1))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun lst24 () Inductive)
(declare-fun lim2 () Int)
(declare-fun currentThread204 () Int)
(push)
(push)
; Assume: (= true (forall0 lst24 (_@ _@nat_lt (box_int lim2))))
(assert (= true (forall0 lst24 (_@ _@nat_lt (box_int lim2)))))
(check-sat)
(push)
; Assume: (= true (forall0 lst24 (_@ _@nat_ge (box_int lim2))))
(assert (= true (forall0 lst24 (_@ _@nat_ge (box_int lim2)))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= lst24 nil)
(assert (= lst24 nil))
(check-sat)
; Query: (= lst24 nil)
(push)
(assert (not (= lst24 nil)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h165 () Inductive)
(declare-fun t165 () Inductive)
(push)
(push)
; Assume: (= lst24 (cons h165 t165))
(assert (= lst24 (cons h165 t165)))
(check-sat)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l48 () Inductive)
(declare-fun lim3 () Int)
(declare-fun currentThread205 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l48 nil)
(assert (= l48 nil))
(check-sat)
; Query: (= true (multiset_eq (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) l48))
(push)
(assert
   (not
      (= true
         (multiset_eq
            (append
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48)
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))
            l48))))
(check-sat)
(pop 1)
; Query: (= true (disjoint (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))))
(push)
(assert
   (not
      (= true
         (disjoint
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h166 () Inductive)
(declare-fun t166 () Inductive)
(push)
(push)
; Assume: (= l48 (cons h166 t166))
(assert (= l48 (cons h166 t166)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) t166)) t166))
(assert
   (= true
      (multiset_eq
         (append
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166)
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) t166))
         t166)))
(check-sat)
(push)
; Assume: (= true (disjoint (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) t166))))
(assert
   (= true
      (disjoint
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166))
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) t166)))))
(check-sat)
(declare-fun key () Inductive)
(declare-fun dist () Inductive)
(push)
(push)
; Assume: (= h166 (pair key dist))
(assert (= h166 (pair key dist)))
(check-sat)
(push)
(push)
; Assume: (unbox_bool (_@ (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) h166))
(assert
   (unbox_bool (_@ (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) h166)))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) (_@ _@nat_lt (box_int lim3))))
(assert
   (= true
      (forall0
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))
         (_@ _@nat_lt (box_int lim3)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (_@ _@nat_ge (box_int lim3))))
(assert
   (= true
      (forall0
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48))
         (_@ _@nat_ge (box_int lim3)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48))))
(assert
   (= true
      (subset0
         (intersection0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48)))
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)))))
(check-sat)
(push)
; Assume: (= true (subset0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))))
(assert
   (= true
      (subset0
         (intersection0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48)))
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)))))
(check-sat)
; Query: (= true (subset0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48))))
(push)
(assert
   (not
      (= true
         (subset0
            (intersection0
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     l48))
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     l48)))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (_@ _@nat_ge (box_int lim3))))
(push)
(assert
   (not
      (= true
         (forall0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (_@ _@nat_ge (box_int lim3))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (_@ _@nat_ge (box_int lim3))))
(assert
   (= true
      (forall0
         (intersection0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48)))
         (_@ _@nat_ge (box_int lim3)))))
(check-sat)
; Query: (= true (subset0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))))
(push)
(assert
   (not
      (= true
         (subset0
            (intersection0
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     l48))
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     l48)))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) (_@ _@nat_lt (box_int lim3))))
(push)
(assert
   (not
      (= true
         (forall0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))
            (_@ _@nat_lt (box_int lim3))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (_@ _@nat_lt (box_int lim3))))
(assert
   (= true
      (forall0
         (intersection0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48)))
         (_@ _@nat_lt (box_int lim3)))))
(check-sat)
; Query: (= true (forall0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (_@ _@nat_lt (box_int lim3))))
(push)
(assert
   (not
      (= true
         (forall0
            (intersection0
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     l48))
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     l48)))
            (_@ _@nat_lt (box_int lim3))))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (_@ _@nat_ge (box_int lim3))))
(push)
(assert
   (not
      (= true
         (forall0
            (intersection0
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     l48))
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     l48)))
            (_@ _@nat_ge (box_int lim3))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) nil)
(assert
   (=
      (intersection0
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48))
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)))
      nil))
(check-sat)
; Query: (= true (multiset_eq (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) l48))
(push)
(assert
   (not
      (= true
         (multiset_eq
            (append
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48)
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))
            l48))))
(check-sat)
(pop 1)
; Query: (= true (disjoint (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))))
(push)
(assert
   (not
      (= true
         (disjoint
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (unbox_bool (_@ (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) h166)))
(assert
   (not
      (unbox_bool
         (_@ (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) h166))))
(check-sat)
(push)
(push)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166) (cons h166 (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) t166))) (cons h166 (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) t166)))))
(assert
   (= true
      (multiset_eq
         (append
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166)
            (cons h166
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  t166)))
         (cons h166
            (append
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  t166)
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  t166))))))
(check-sat)
; Query: (= true (multiset_eq (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) (cons h166 (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) t166)))))
(push)
(assert
   (not
      (= true
         (multiset_eq
            (append
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48)
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))
            (cons h166
               (append
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     t166)
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     t166)))))))
(check-sat)
(pop 1)
; Query: (= true (multiset_eq (cons h166 (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) t166) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) t166))) l48))
(push)
(assert
   (not
      (= true
         (multiset_eq
            (cons h166
               (append
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     t166)
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     t166)))
            l48))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (multiset_eq (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) l48))
(assert
   (= true
      (multiset_eq
         (append
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))
         l48)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) (_@ _@nat_lt (box_int lim3))))
(assert
   (= true
      (forall0
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))
         (_@ _@nat_lt (box_int lim3)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (_@ _@nat_ge (box_int lim3))))
(assert
   (= true
      (forall0
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48))
         (_@ _@nat_ge (box_int lim3)))))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (subset0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48))))
(assert
   (= true
      (subset0
         (intersection0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48)))
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)))))
(check-sat)
(push)
; Assume: (= true (subset0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))))
(assert
   (= true
      (subset0
         (intersection0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48)))
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)))))
(check-sat)
; Query: (= true (subset0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48))))
(push)
(assert
   (not
      (= true
         (subset0
            (intersection0
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     l48))
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     l48)))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (_@ _@nat_ge (box_int lim3))))
(push)
(assert
   (not
      (= true
         (forall0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (_@ _@nat_ge (box_int lim3))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (_@ _@nat_ge (box_int lim3))))
(assert
   (= true
      (forall0
         (intersection0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48)))
         (_@ _@nat_ge (box_int lim3)))))
(check-sat)
; Query: (= true (subset0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))))
(push)
(assert
   (not
      (= true
         (subset0
            (intersection0
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     l48))
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     l48)))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) (_@ _@nat_lt (box_int lim3))))
(push)
(assert
   (not
      (= true
         (forall0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))
            (_@ _@nat_lt (box_int lim3))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (forall0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (_@ _@nat_lt (box_int lim3))))
(assert
   (= true
      (forall0
         (intersection0
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48)))
         (_@ _@nat_lt (box_int lim3)))))
(check-sat)
; Query: (= true (forall0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (_@ _@nat_lt (box_int lim3))))
(push)
(assert
   (not
      (= true
         (forall0
            (intersection0
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     l48))
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     l48)))
            (_@ _@nat_lt (box_int lim3))))))
(check-sat)
(pop 1)
; Query: (= true (forall0 (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) (_@ _@nat_ge (box_int lim3))))
(push)
(assert
   (not
      (= true
         (forall0
            (intersection0
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                     l48))
               (map0 _@snd
                  (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                     l48)))
            (_@ _@nat_ge (box_int lim3))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (intersection0 (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))) nil)
(assert
   (=
      (intersection0
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48))
         (map0 _@snd
            (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)))
      nil))
(check-sat)
; Query: (= true (multiset_eq (append (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48) (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48)) l48))
(push)
(assert
   (not
      (= true
         (multiset_eq
            (append
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48)
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))
            l48))))
(check-sat)
(pop 1)
; Query: (= true (disjoint (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd) l48)) (map0 _@snd (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd) l48))))
(push)
(assert
   (not
      (= true
         (disjoint
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_ge (box_int lim3))) _@snd)
                  l48))
            (map0 _@snd
               (filter (_@ (_@ _@sup (_@ _@nat_lt (box_int lim3))) _@snd)
                  l48))))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun l_177 () Inductive)
(declare-fun l_277 () Inductive)
(declare-fun bnd () Int)
(declare-fun currentThread206 () Int)
(push)
(push)
; Assume: (= true (forall0 l_177 (_@ _@nat_lt (box_int bnd))))
(assert (= true (forall0 l_177 (_@ _@nat_lt (box_int bnd)))))
(check-sat)
(push)
; Assume: (= true (forall0 l_277 (_@ _@nat_ge (box_int bnd))))
(assert (= true (forall0 l_277 (_@ _@nat_ge (box_int bnd)))))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l_277 nil)
(assert (= l_277 nil))
(check-sat)
; Query: (= true (disjoint l_177 l_277))
(push)
(assert (not (= true (disjoint l_177 l_277))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun h167 () Inductive)
(declare-fun t167 () Inductive)
(push)
(push)
; Assume: (= l_277 (cons h167 t167))
(assert (= l_277 (cons h167 t167)))
(check-sat)
(push)
(push)
; Assume: (mem h167 l_177)
(assert (mem h167 l_177))
(check-sat)
(push)
(push)
; Assert: (< (func_rank forall_mem) 0)
(assert (< (func_rank forall_mem) 0))
; Query: (and (= (forall0 l_177 (_@ _@nat_lt (box_int bnd))) true) (= (mem h167 l_177) true))
(push)
(assert
   (not
      (and (= (forall0 l_177 (_@ _@nat_lt (box_int bnd))) true)
         (= (mem h167 l_177) true))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (unbox_bool (_@ (_@ _@nat_lt (box_int bnd)) h167)) true)
(assert (= (unbox_bool (_@ (_@ _@nat_lt (box_int bnd)) h167)) true))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (mem h167 l_177))
(assert (not (mem h167 l_177)))
(check-sat)
(push)
; Query: (= true (forall0 l_177 (_@ _@nat_lt (box_int bnd))))
(push)
(assert (not (= true (forall0 l_177 (_@ _@nat_lt (box_int bnd))))))
(check-sat)
(pop 1)
; Query: (= true (forall0 t167 (_@ _@nat_ge (box_int bnd))))
(push)
(assert (not (= true (forall0 t167 (_@ _@nat_ge (box_int bnd))))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= true (disjoint l_177 t167))
(assert (= true (disjoint l_177 t167)))
(check-sat)
; Query: (= true (disjoint l_177 l_277))
(push)
(assert (not (= true (disjoint l_177 l_277))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun x35 () Int)
(declare-fun y2 () Int)
(declare-fun currentThread207 () Int)
(push)
(push)
; Assume: (< x35 y2)
(assert (< x35 y2))
(check-sat)
(push)
; Assume: (<= y2 x35)
(assert (<= y2 x35))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun b1 () Bool)
(declare-fun currentThread208 () Int)
(push)
(push)
; Assume: b1
(assert b1)
(check-sat)
(push)
(push)
; Query: b1
(push)
(assert (not b1))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun index5 () Int)
(declare-fun f31 () Inductive)
(declare-fun l49 () Inductive)
(declare-fun currentThread209 () Int)
(push)
(push)
; Assume: (<= 0 index5)
(assert (<= 0 index5))
(check-sat)
(push)
; Assume: (< index5 (length l49))
(assert (< index5 (length l49)))
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= l49 nil)
(assert (= l49 nil))
(check-sat)
(pop 1)
(pop 1)
(push)
(declare-fun h168 () Inductive)
(declare-fun t168 () Inductive)
(push)
(push)
; Assume: (= l49 (cons h168 t168))
(assert (= l49 (cons h168 t168)))
(check-sat)
(push)
(push)
; Assume: (< 0 index5)
(assert (< 0 index5))
(check-sat)
(push)
; Query: (<= 0 (- index5 1))
(push)
(assert (not (<= 0 (- index5 1))))
(check-sat)
(pop 1)
; Query: (< (- index5 1) (length t168))
(push)
(assert (not (< (- index5 1) (length t168))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (nth (- index5 1) (map0 f31 t168)) (_@ f31 (nth (- index5 1) t168)))
(assert
   (= (nth (- index5 1) (map0 f31 t168)) (_@ f31 (nth (- index5 1) t168))))
(check-sat)
; Query: (= (nth index5 (map0 f31 l49)) (_@ f31 (nth index5 l49)))
(push)
(assert (not (= (nth index5 (map0 f31 l49)) (_@ f31 (nth index5 l49)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(push)
; Assume: (not (< 0 index5))
(assert (not (< 0 index5)))
(check-sat)
(push)
; Query: (= (nth index5 (map0 f31 l49)) (_@ f31 (nth index5 l49)))
(push)
(assert (not (= (nth index5 (map0 f31 l49)) (_@ f31 (nth index5 l49)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(declare-fun rule (Inductive Int Int) Inductive)
; disjointness axiom
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (! (= (ctortag (rule var var0 var1)) 16)
         :pattern ((rule var var0 var1)))))
; injectiveness axioms
(declare-fun ctorinv14 (Inductive) Inductive)
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (! (= (ctorinv14 (rule var var0 var1)) var)
         :pattern ((rule var var0 var1)))))
(declare-fun ctorinv15 (Inductive) Int)
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (! (= (ctorinv15 (rule var var0 var1)) var0)
         :pattern ((rule var var0 var1)))))
(declare-fun ctorinv16 (Inductive) Int)
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (! (= (ctorinv16 (rule var var0 var1)) var1)
         :pattern ((rule var var0 var1)))))
(declare-fun _@rule () Inductive)
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (!
         (= (_@ (_@ (_@ _@rule var) (box_int var0)) (box_int var1))
            (rule var var0 var1))
         :pattern ((_@ (_@ (_@ _@rule var) (box_int var0)) (box_int var1))))))
(declare-fun tables (Inductive Inductive Int) Inductive)
; disjointness axiom
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (! (= (ctortag (tables var var0 var1)) 17)
         :pattern ((tables var var0 var1)))))
; injectiveness axioms
(declare-fun ctorinv17 (Inductive) Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (! (= (ctorinv17 (tables var var0 var1)) var)
         :pattern ((tables var var0 var1)))))
(declare-fun ctorinv18 (Inductive) Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (! (= (ctorinv18 (tables var var0 var1)) var0)
         :pattern ((tables var var0 var1)))))
(declare-fun ctorinv19 (Inductive) Int)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (! (= (ctorinv19 (tables var var0 var1)) var1)
         :pattern ((tables var var0 var1)))))
(declare-fun _@tables () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (!
         (= (_@ (_@ (_@ _@tables var) var0) (box_int var1))
            (tables var var0 var1))
         :pattern ((_@ (_@ (_@ _@tables var) var0) (box_int var1))))))
(declare-fun Z_of_int (Int Inductive) Inductive)
(declare-fun _@Z_of_int () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (_@ (_@ _@Z_of_int (box_int var)) var0) (Z_of_int var var0))
         :pattern ((_@ (_@ _@Z_of_int (box_int var)) var0)))))
(declare-fun init_rule (Int Int Int) Inductive)
(declare-fun _@init_rule () Inductive)
(assert
   (forall ((var Int) (var0 Int) (var1 Int))
      (!
         (=
            (_@ (_@ (_@ _@init_rule (box_int var)) (box_int var0))
               (box_int var1))
            (init_rule var var0 var1))
         :pattern
         ((_@ (_@ (_@ _@init_rule (box_int var)) (box_int var0))
             (box_int var1))))))
(declare-fun rule_ipv_4 (Inductive) Int)
(declare-fun _@rule_ipv_4 () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@rule_ipv_4 var)) (rule_ipv_4 var))
         :pattern ((_@ _@rule_ipv_4 var)))))
(declare-fun rule_prefixlen (Inductive) Int)
(declare-fun _@rule_prefixlen () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@rule_prefixlen var)) (rule_prefixlen var))
         :pattern ((_@ _@rule_prefixlen var)))))
(declare-fun rule_route (Inductive) Int)
(declare-fun _@rule_route () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@rule_route var)) (rule_route var))
         :pattern ((_@ _@rule_route var)))))
(declare-fun dir_lpm_2_4 (Inductive) Inductive)
(declare-fun _@dir_lpm_2_4 () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@dir_lpm_2_4 var) (dir_lpm_2_4 var))
         :pattern ((_@ _@dir_lpm_2_4 var)))))
(declare-fun dir_lpm_long (Inductive) Inductive)
(declare-fun _@dir_lpm_long () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@dir_lpm_long var) (dir_lpm_long var))
         :pattern ((_@ _@dir_lpm_long var)))))
(declare-fun dir_lpm_long_index (Inductive) Int)
(declare-fun _@dir_lpm_long_index () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_int (_@ _@dir_lpm_long_index var))
            (dir_lpm_long_index var))
         :pattern ((_@ _@dir_lpm_long_index var)))))
(declare-fun rule__2_4_get_value (Inductive) Int)
(declare-fun _@rule__2_4_get_value () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_int (_@ _@rule__2_4_get_value var))
            (rule__2_4_get_value var))
         :pattern ((_@ _@rule__2_4_get_value var)))))
(declare-fun index_2_4_from_ipv_4 (Inductive) Int)
(declare-fun _@index_2_4_from_ipv_4 () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_int (_@ _@index_2_4_from_ipv_4 var))
            (index_2_4_from_ipv_4 var))
         :pattern ((_@ _@index_2_4_from_ipv_4 var)))))
(declare-fun indexlong_from_ipv_4 (Inductive Int) Int)
(declare-fun _@indexlong_from_ipv_4 () Inductive)
(assert
   (forall ((var Inductive) (var0 Int))
      (!
         (= (unbox_int (_@ (_@ _@indexlong_from_ipv_4 var) (box_int var0)))
            (indexlong_from_ipv_4 var var0))
         :pattern ((_@ (_@ _@indexlong_from_ipv_4 var) (box_int var0))))))
(declare-fun compute_rule_size (Int) Int)
(declare-fun _@compute_rule_size () Inductive)
(assert
   (forall ((var Int))
      (!
         (= (unbox_int (_@ _@compute_rule_size (box_int var)))
            (compute_rule_size var))
         :pattern ((_@ _@compute_rule_size (box_int var))))))
(declare-fun mask_rec (Int Inductive) Inductive)
(declare-fun _@mask_rec () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (! (= (_@ (_@ _@mask_rec (box_int var)) var0) (mask_rec var var0))
         :pattern ((_@ (_@ _@mask_rec (box_int var)) var0)))))
(declare-fun mask_3_2_from_prefixlen (Int) Inductive)
(declare-fun _@mask_3_2_from_prefixlen () Inductive)
(assert
   (forall ((var Int))
      (!
         (= (_@ _@mask_3_2_from_prefixlen (box_int var))
            (mask_3_2_from_prefixlen var))
         :pattern ((_@ _@mask_3_2_from_prefixlen (box_int var))))))
(declare-fun compute_starting_index__2_4 (Inductive) Int)
(declare-fun _@compute_starting_index__2_4 () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_int (_@ _@compute_starting_index__2_4 var))
            (compute_starting_index__2_4 var))
         :pattern ((_@ _@compute_starting_index__2_4 var)))))
(declare-fun compute_starting_index_long (Inductive Int) Int)
(declare-fun _@compute_starting_index_long () Inductive)
(assert
   (forall ((var Inductive) (var0 Int))
      (!
         (=
            (unbox_int
               (_@ (_@ _@compute_starting_index_long var) (box_int var0)))
            (compute_starting_index_long var var0))
         :pattern
         ((_@ (_@ _@compute_starting_index_long var) (box_int var0))))))
(declare-fun is_new_index_needed (Inductive) Bool)
(declare-fun _@is_new_index_needed () Inductive)
(assert
   (forall ((var Inductive))
      (!
         (= (unbox_bool (_@ _@is_new_index_needed var))
            (is_new_index_needed var))
         :pattern ((_@ _@is_new_index_needed var)))))
(declare-fun extract_2_4_value (Inductive) Int)
(declare-fun _@extract_2_4_value () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (unbox_int (_@ _@extract_2_4_value var)) (extract_2_4_value var))
         :pattern ((_@ _@extract_2_4_value var)))))
(declare-fun extract_flag (Int) Bool)
(declare-fun _@extract_flag () Inductive)
(assert
   (forall ((var Int))
      (!
         (= (unbox_bool (_@ _@extract_flag (box_int var)))
            (extract_flag var))
         :pattern ((_@ _@extract_flag (box_int var))))))
(declare-fun set_flag (Int) Int)
(declare-fun _@set_flag () Inductive)
(assert
   (forall ((var Int))
      (! (= (unbox_int (_@ _@set_flag (box_int var))) (set_flag var))
         :pattern ((_@ _@set_flag (box_int var))))))
(declare-fun set_flag_entry (Inductive) Inductive)
(declare-fun _@set_flag_entry () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@set_flag_entry var) (set_flag_entry var))
         :pattern ((_@ _@set_flag_entry var)))))
(declare-fun extract_value (Int) Int)
(declare-fun _@extract_value () Inductive)
(assert
   (forall ((var Int))
      (!
         (= (unbox_int (_@ _@extract_value (box_int var)))
            (extract_value var))
         :pattern ((_@ _@extract_value (box_int var))))))
(declare-fun lookup_lpm__2_4 (Int Inductive) Inductive)
(declare-fun _@lookup_lpm__2_4 () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (_@ (_@ _@lookup_lpm__2_4 (box_int var)) var0)
            (lookup_lpm__2_4 var var0))
         :pattern ((_@ (_@ _@lookup_lpm__2_4 (box_int var)) var0)))))
(declare-fun lookup_lpm_long (Int Inductive) Inductive)
(declare-fun _@lookup_lpm_long () Inductive)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (_@ (_@ _@lookup_lpm_long (box_int var)) var0)
            (lookup_lpm_long var var0))
         :pattern ((_@ (_@ _@lookup_lpm_long (box_int var)) var0)))))
(declare-fun lpm_dir__2_4__8_lookup (Inductive Inductive) Int)
(declare-fun _@lpm_dir__2_4__8_lookup () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (unbox_int (_@ (_@ _@lpm_dir__2_4__8_lookup var) var0))
            (lpm_dir__2_4__8_lookup var var0))
         :pattern ((_@ (_@ _@lpm_dir__2_4__8_lookup var) var0)))))
(declare-fun update_n (Inductive Int Inductive Inductive) Inductive)
(declare-fun _@update_n () Inductive)
(assert
   (forall ((var Inductive) (var0 Int) (var1 Inductive) (var2 Inductive))
      (!
         (= (_@ (_@ (_@ (_@ _@update_n var) (box_int var0)) var1) var2)
            (update_n var var0 var1 var2))
         :pattern
         ((_@ (_@ (_@ (_@ _@update_n var) (box_int var0)) var1) var2)))))
(declare-fun insert_route__2_4 (Inductive Inductive) Inductive)
(declare-fun _@insert_route__2_4 () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (!
         (= (_@ (_@ _@insert_route__2_4 var) var0)
            (insert_route__2_4 var var0))
         :pattern ((_@ (_@ _@insert_route__2_4 var) var0)))))
(declare-fun insert_route_long (Inductive Inductive Int) Inductive)
(declare-fun _@insert_route_long () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (!
         (= (_@ (_@ (_@ _@insert_route_long var) var0) (box_int var1))
            (insert_route_long var var0 var1))
         :pattern
         ((_@ (_@ (_@ _@insert_route_long var) var0) (box_int var1))))))
(declare-fun insert_lpm__2_4 (Inductive Inductive) Inductive)
(declare-fun _@insert_lpm__2_4 () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@insert_lpm__2_4 var) var0) (insert_lpm__2_4 var var0))
         :pattern ((_@ (_@ _@insert_lpm__2_4 var) var0)))))
(declare-fun insert_lpm_long (Inductive Inductive) Inductive)
(declare-fun _@insert_lpm_long () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@insert_lpm_long var) var0) (insert_lpm_long var var0))
         :pattern ((_@ (_@ _@insert_lpm_long var) var0)))))
(declare-fun add_rule (Inductive Inductive) Inductive)
(declare-fun _@add_rule () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive))
      (! (= (_@ (_@ _@add_rule var) var0) (add_rule var var0))
         :pattern ((_@ (_@ _@add_rule var) var0)))))
(declare-fun entry__2_4_mapping (Int) Inductive)
(declare-fun _@entry__2_4_mapping () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@entry__2_4_mapping (box_int var)) (entry__2_4_mapping var))
         :pattern ((_@ _@entry__2_4_mapping (box_int var))))))
(declare-fun entry_long_mapping (Int) Inductive)
(declare-fun _@entry_long_mapping () Inductive)
(assert
   (forall ((var Int))
      (! (= (_@ _@entry_long_mapping (box_int var)) (entry_long_mapping var))
         :pattern ((_@ _@entry_long_mapping (box_int var))))))
(declare-fun build_tables (Inductive Inductive Int) Inductive)
(declare-fun _@build_tables () Inductive)
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (!
         (= (_@ (_@ (_@ _@build_tables var) var0) (box_int var1))
            (build_tables var var0 var1))
         :pattern ((_@ (_@ (_@ _@build_tables var) var0) (box_int var1))))))
(declare-fun dir_init () Inductive)
(declare-fun get_someOption_2_4 (Inductive) Inductive)
(declare-fun _@get_someOption_2_4 () Inductive)
(assert
   (forall ((var Inductive))
      (! (= (_@ _@get_someOption_2_4 var) (get_someOption_2_4 var))
         :pattern ((_@ _@get_someOption_2_4 var)))))
(declare-fun valid_entry_2_4 (Int) Bool)
(declare-fun _@valid_entry_2_4 () Inductive)
(assert
   (forall ((var Int))
      (!
         (= (unbox_bool (_@ _@valid_entry_2_4 (box_int var)))
            (valid_entry_2_4 var))
         :pattern ((_@ _@valid_entry_2_4 (box_int var))))))
(declare-fun valid_entry_long (Int) Bool)
(declare-fun _@valid_entry_long () Inductive)
(assert
   (forall ((var Int))
      (!
         (= (unbox_bool (_@ _@valid_entry_long (box_int var)))
            (valid_entry_long var))
         :pattern ((_@ _@valid_entry_long (box_int var))))))
(declare-fun update_n_length () Int)
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (Z_of_int var var0)
            (Z_of_bits (Zsign false) (snd (bits_of_int var var0))))
         :pattern ((Z_of_int var var0)))))
(assert
   (forall ((var Int) (var0 Int) (var1 Int))
      (! (= (init_rule var var0 var1) (rule (Z_of_int var N_3_2) var0 var1))
         :pattern ((init_rule var var0 var1)))))
; set_fpclauses
; function rule_ipv_4
; switching on argument number 0
; constructor rule
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (! (= (rule_ipv_4 (rule var var0 var1)) (int_of_Z var))
         :pattern ((rule_ipv_4 (rule var var0 var1))))))
; set_fpclauses
; function rule_prefixlen
; switching on argument number 0
; constructor rule
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (! (= (rule_prefixlen (rule var var0 var1)) var0)
         :pattern ((rule_prefixlen (rule var var0 var1))))))
; set_fpclauses
; function rule_route
; switching on argument number 0
; constructor rule
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (! (= (rule_route (rule var var0 var1)) var1)
         :pattern ((rule_route (rule var var0 var1))))))
; set_fpclauses
; function dir_lpm_2_4
; switching on argument number 0
; constructor tables
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (! (= (dir_lpm_2_4 (tables var var0 var1)) var)
         :pattern ((dir_lpm_2_4 (tables var var0 var1))))))
; set_fpclauses
; function dir_lpm_long
; switching on argument number 0
; constructor tables
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (! (= (dir_lpm_long (tables var var0 var1)) var0)
         :pattern ((dir_lpm_long (tables var var0 var1))))))
; set_fpclauses
; function dir_lpm_long_index
; switching on argument number 0
; constructor tables
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (! (= (dir_lpm_long_index (tables var var0 var1)) var1)
         :pattern ((dir_lpm_long_index (tables var var0 var1))))))
(assert
   (forall ((var Inductive))
      (!
         (= (rule__2_4_get_value var)
            (int_of_Z (Z_and var (Z_of_int 32767 N_1_6))))
         :pattern ((rule__2_4_get_value var)))))
(assert
   (forall ((var Inductive))
      (! (= (index_2_4_from_ipv_4 var) (int_of_Z (Z_shiftright var N_8)))
         :pattern ((index_2_4_from_ipv_4 var)))))
(assert
   (forall ((var Inductive) (var0 Int))
      (!
         (= (indexlong_from_ipv_4 var var0)
            (+ (* var0 256) (int_of_Z (Z_and var (Z_of_int 255 N_8)))))
         :pattern ((indexlong_from_ipv_4 var var0)))))
(assert
   (forall ((var Int))
      (!
         (= (compute_rule_size var)
            (ite (< var 24) (pow_nat 2 (nat_of_int (- 24 var)))
               (pow_nat 2 (nat_of_int (- 32 var)))))
         :pattern ((compute_rule_size var)))))
; set_fpclauses
; function mask_rec
; switching on argument number 1
; constructor succ
(assert
   (forall ((var Int) (var0 Inductive))
      (!
         (= (mask_rec var (succ var0))
            (ite (= (int_of_nat (succ var0)) var)
               (Zdigit (mask_rec (- var 1) var0) true)
               (Zdigit (mask_rec var var0) false)))
         :pattern ((mask_rec var (succ var0))))))
; constructor zero
(assert
   (forall ((var Int))
      (! (= (mask_rec var zero) (Zsign false))
         :pattern ((mask_rec var zero)))))
(assert
   (forall ((var Int))
      (! (= (mask_3_2_from_prefixlen var) (mask_rec var N_3_2))
         :pattern ((mask_3_2_from_prefixlen var)))))
; set_fpclauses
; function compute_starting_index__2_4
; switching on argument number 0
; constructor rule
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int))
      (!
         (= (compute_starting_index__2_4 (rule var var0 var1))
            (index_2_4_from_ipv_4 (Z_and var (mask_3_2_from_prefixlen var0))))
         :pattern ((compute_starting_index__2_4 (rule var var0 var1))))))
; set_fpclauses
; function compute_starting_index_long
; switching on argument number 0
; constructor rule
(assert
   (forall ((var Inductive) (var0 Int) (var1 Int) (var2 Int))
      (!
         (= (compute_starting_index_long (rule var var0 var1) var2)
            (+ (* var2 256)
               (int_of_Z
                  (Z_and (Z_and var (mask_3_2_from_prefixlen var0))
                     (Z_of_int 255 N_8)))))
         :pattern ((compute_starting_index_long (rule var var0 var1) var2)))))
(declare-fun switch_expression_1_5 (Inductive Inductive Inductive) Bool)
; set_fpclauses
; function switch_expression_1_5
; switching on argument number 0
; constructor pair
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (switch_expression_1_5 (pair var var0) var1 var2)
            (not (unbox_bool var)))
         :pattern ((switch_expression_1_5 (pair var var0) var1 var2)))))
; set_fpclauses
; function is_new_index_needed
; switching on argument number 0
; constructor some
(declare-fun switch_expression_1_6 (Inductive Inductive Inductive) Bool)
; set_fpclauses
; function switch_expression_1_6
; switching on argument number 0
; constructor pair
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (switch_expression_1_6 (pair var var0) var1 var2)
            (not (unbox_bool var)))
         :pattern ((switch_expression_1_6 (pair var var0) var1 var2)))))
(assert
   (forall ((var Inductive))
      (!
         (= (is_new_index_needed (some var))
            (switch_expression_1_6 var (some var) var))
         :pattern ((is_new_index_needed (some var))))))
; constructor none
(assert (= (is_new_index_needed none) true))
; set_fpclauses
; function extract_2_4_value
; switching on argument number 0
; constructor some
(assert
   (forall ((var Inductive))
      (! (= (extract_2_4_value (some var)) (int_of_Z (snd var)))
         :pattern ((extract_2_4_value (some var))))))
; constructor none
(assert (= (extract_2_4_value none) 65535))
(assert
   (forall ((var Int))
      (! (= (extract_flag var) (= (shiftright var 15) 1))
         :pattern ((extract_flag var)))))
(assert
   (forall ((var Int))
      (! (= (set_flag var) (bitor var 32768)) :pattern ((set_flag var)))))
(declare-fun switch_expression_1_7 (Inductive Inductive Inductive) Inductive)
; set_fpclauses
; function switch_expression_1_7
; switching on argument number 0
; constructor pair
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (switch_expression_1_7 (pair var var0) var1 var2)
            (some (pair (box_bool true) var0)))
         :pattern ((switch_expression_1_7 (pair var var0) var1 var2)))))
; set_fpclauses
; function set_flag_entry
; switching on argument number 0
; constructor some
(declare-fun switch_expression_1_8 (Inductive Inductive Inductive) Inductive)
; set_fpclauses
; function switch_expression_1_8
; switching on argument number 0
; constructor pair
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive))
      (!
         (= (switch_expression_1_8 (pair var var0) var1 var2)
            (some (pair (box_bool true) var0)))
         :pattern ((switch_expression_1_8 (pair var var0) var1 var2)))))
(assert
   (forall ((var Inductive))
      (!
         (= (set_flag_entry (some var))
            (switch_expression_1_8 var (some var) var))
         :pattern ((set_flag_entry (some var))))))
; constructor none
(assert (= (set_flag_entry none) none))
(assert
   (forall ((var Int))
      (! (= (extract_value var) (bitand var 32767))
         :pattern ((extract_value var)))))
; set_fpclauses
; function lookup_lpm__2_4
; switching on argument number 1
; constructor tables
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive) (var2 Int))
      (! (= (lookup_lpm__2_4 var (tables var0 var1 var2)) (nth var var0))
         :pattern ((lookup_lpm__2_4 var (tables var0 var1 var2))))))
; set_fpclauses
; function lookup_lpm_long
; switching on argument number 1
; constructor tables
(assert
   (forall ((var Int) (var0 Inductive) (var1 Inductive) (var2 Int))
      (! (= (lookup_lpm_long var (tables var0 var1 var2)) (nth var var1))
         :pattern ((lookup_lpm_long var (tables var0 var1 var2))))))
(declare-fun switch_expression_1_9
   (Inductive Inductive Inductive Int Inductive Inductive) Int)
(declare-fun switch_expression_2_0
   (Inductive Inductive Inductive Int Inductive Inductive Inductive) Int)
(declare-fun switch_expression_2_1
   (Inductive Inductive Inductive Inductive Int Inductive Inductive Inductive
      Bool)
   Int)
; set_fpclauses
; function switch_expression_2_1
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive) (var5 Inductive) (var6 Bool))
      (!
         (=
            (switch_expression_2_1 none var var0 var1 var2 var3 var4 var5
               var6)
            65535)
         :pattern
         ((switch_expression_2_1 none var var0 var1 var2 var3 var4 var5 var6)))))
; constructor some
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive)
       (var7 Bool))
      (!
         (=
            (switch_expression_2_1 (some var) var0 var1 var2 var3 var4 var5
               var6 var7)
            (int_of_Z var))
         :pattern
         ((switch_expression_2_1 (some var) var0 var1 var2 var3 var4 var5
             var6 var7)))))
; set_fpclauses
; function switch_expression_2_0
; switching on argument number 0
; constructor pair
(declare-fun switch_expression_2_2
   (Inductive Inductive Inductive Inductive Int Inductive Inductive Inductive
      Bool)
   Int)
; set_fpclauses
; function switch_expression_2_2
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive) (var5 Inductive) (var6 Bool))
      (!
         (=
            (switch_expression_2_2 none var var0 var1 var2 var3 var4 var5
               var6)
            65535)
         :pattern
         ((switch_expression_2_2 none var var0 var1 var2 var3 var4 var5 var6)))))
; constructor some
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive)
       (var7 Bool))
      (!
         (=
            (switch_expression_2_2 (some var) var0 var1 var2 var3 var4 var5
               var6 var7)
            (int_of_Z var))
         :pattern
         ((switch_expression_2_2 (some var) var0 var1 var2 var3 var4 var5
             var6 var7)))))
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive))
      (!
         (=
            (switch_expression_2_0 (pair var var0) var1 var2 var3 var4 var5
               var6)
            (ite (unbox_bool var)
               (switch_expression_2_2
                  (lookup_lpm_long
                     (indexlong_from_ipv_4 var4 (int_of_Z var0)) var5)
                  var6 var5 var4 var3 var2 var1 var0 (unbox_bool var))
               (int_of_Z var0)))
         :pattern
         ((switch_expression_2_0 (pair var var0) var1 var2 var3 var4 var5
             var6)))))
; set_fpclauses
; function switch_expression_1_9
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Int) (var2 Inductive)
       (var3 Inductive))
      (! (= (switch_expression_1_9 none var var0 var1 var2 var3) 65535)
         :pattern ((switch_expression_1_9 none var var0 var1 var2 var3)))))
; constructor some
(declare-fun switch_expression_2_3
   (Inductive Inductive Inductive Int Inductive Inductive Inductive) Int)
(declare-fun switch_expression_2_4
   (Inductive Inductive Inductive Inductive Int Inductive Inductive Inductive
      Bool)
   Int)
; set_fpclauses
; function switch_expression_2_4
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive) (var5 Inductive) (var6 Bool))
      (!
         (=
            (switch_expression_2_4 none var var0 var1 var2 var3 var4 var5
               var6)
            65535)
         :pattern
         ((switch_expression_2_4 none var var0 var1 var2 var3 var4 var5 var6)))))
; constructor some
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive)
       (var7 Bool))
      (!
         (=
            (switch_expression_2_4 (some var) var0 var1 var2 var3 var4 var5
               var6 var7)
            (int_of_Z var))
         :pattern
         ((switch_expression_2_4 (some var) var0 var1 var2 var3 var4 var5
             var6 var7)))))
; set_fpclauses
; function switch_expression_2_3
; switching on argument number 0
; constructor pair
(declare-fun switch_expression_2_5
   (Inductive Inductive Inductive Inductive Int Inductive Inductive Inductive
      Bool)
   Int)
; set_fpclauses
; function switch_expression_2_5
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive) (var5 Inductive) (var6 Bool))
      (!
         (=
            (switch_expression_2_5 none var var0 var1 var2 var3 var4 var5
               var6)
            65535)
         :pattern
         ((switch_expression_2_5 none var var0 var1 var2 var3 var4 var5 var6)))))
; constructor some
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive)
       (var7 Bool))
      (!
         (=
            (switch_expression_2_5 (some var) var0 var1 var2 var3 var4 var5
               var6 var7)
            (int_of_Z var))
         :pattern
         ((switch_expression_2_5 (some var) var0 var1 var2 var3 var4 var5
             var6 var7)))))
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive))
      (!
         (=
            (switch_expression_2_3 (pair var var0) var1 var2 var3 var4 var5
               var6)
            (ite (unbox_bool var)
               (switch_expression_2_5
                  (lookup_lpm_long
                     (indexlong_from_ipv_4 var4 (int_of_Z var0)) var5)
                  var6 var5 var4 var3 var2 var1 var0 (unbox_bool var))
               (int_of_Z var0)))
         :pattern
         ((switch_expression_2_3 (pair var var0) var1 var2 var3 var4 var5
             var6)))))
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive))
      (!
         (= (switch_expression_1_9 (some var) var0 var1 var2 var3 var4)
            (switch_expression_2_3 var var4 var3 var2 var1 var0 var))
         :pattern
         ((switch_expression_1_9 (some var) var0 var1 var2 var3 var4)))))
; set_fpclauses
; function lpm_dir__2_4__8_lookup
; switching on argument number 1
; constructor tables
(declare-fun switch_expression_2_6
   (Inductive Inductive Inductive Int Inductive Inductive) Int)
(declare-fun switch_expression_2_7
   (Inductive Inductive Inductive Int Inductive Inductive Inductive) Int)
(declare-fun switch_expression_2_8
   (Inductive Inductive Inductive Inductive Int Inductive Inductive Inductive
      Bool)
   Int)
; set_fpclauses
; function switch_expression_2_8
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive) (var5 Inductive) (var6 Bool))
      (!
         (=
            (switch_expression_2_8 none var var0 var1 var2 var3 var4 var5
               var6)
            65535)
         :pattern
         ((switch_expression_2_8 none var var0 var1 var2 var3 var4 var5 var6)))))
; constructor some
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive)
       (var7 Bool))
      (!
         (=
            (switch_expression_2_8 (some var) var0 var1 var2 var3 var4 var5
               var6 var7)
            (int_of_Z var))
         :pattern
         ((switch_expression_2_8 (some var) var0 var1 var2 var3 var4 var5
             var6 var7)))))
; set_fpclauses
; function switch_expression_2_7
; switching on argument number 0
; constructor pair
(declare-fun switch_expression_2_9
   (Inductive Inductive Inductive Inductive Int Inductive Inductive Inductive
      Bool)
   Int)
; set_fpclauses
; function switch_expression_2_9
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive) (var5 Inductive) (var6 Bool))
      (!
         (=
            (switch_expression_2_9 none var var0 var1 var2 var3 var4 var5
               var6)
            65535)
         :pattern
         ((switch_expression_2_9 none var var0 var1 var2 var3 var4 var5 var6)))))
; constructor some
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive)
       (var7 Bool))
      (!
         (=
            (switch_expression_2_9 (some var) var0 var1 var2 var3 var4 var5
               var6 var7)
            (int_of_Z var))
         :pattern
         ((switch_expression_2_9 (some var) var0 var1 var2 var3 var4 var5
             var6 var7)))))
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive))
      (!
         (=
            (switch_expression_2_7 (pair var var0) var1 var2 var3 var4 var5
               var6)
            (ite (unbox_bool var)
               (switch_expression_2_9
                  (lookup_lpm_long
                     (indexlong_from_ipv_4 var4 (int_of_Z var0)) var5)
                  var6 var5 var4 var3 var2 var1 var0 (unbox_bool var))
               (int_of_Z var0)))
         :pattern
         ((switch_expression_2_7 (pair var var0) var1 var2 var3 var4 var5
             var6)))))
; set_fpclauses
; function switch_expression_2_6
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Int) (var2 Inductive)
       (var3 Inductive))
      (! (= (switch_expression_2_6 none var var0 var1 var2 var3) 65535)
         :pattern ((switch_expression_2_6 none var var0 var1 var2 var3)))))
; constructor some
(declare-fun switch_expression_3_0
   (Inductive Inductive Inductive Int Inductive Inductive Inductive) Int)
(declare-fun switch_expression_3_1
   (Inductive Inductive Inductive Inductive Int Inductive Inductive Inductive
      Bool)
   Int)
; set_fpclauses
; function switch_expression_3_1
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive) (var5 Inductive) (var6 Bool))
      (!
         (=
            (switch_expression_3_1 none var var0 var1 var2 var3 var4 var5
               var6)
            65535)
         :pattern
         ((switch_expression_3_1 none var var0 var1 var2 var3 var4 var5 var6)))))
; constructor some
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive)
       (var7 Bool))
      (!
         (=
            (switch_expression_3_1 (some var) var0 var1 var2 var3 var4 var5
               var6 var7)
            (int_of_Z var))
         :pattern
         ((switch_expression_3_1 (some var) var0 var1 var2 var3 var4 var5
             var6 var7)))))
; set_fpclauses
; function switch_expression_3_0
; switching on argument number 0
; constructor pair
(declare-fun switch_expression_3_2
   (Inductive Inductive Inductive Inductive Int Inductive Inductive Inductive
      Bool)
   Int)
; set_fpclauses
; function switch_expression_3_2
; switching on argument number 0
; constructor none
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive) (var5 Inductive) (var6 Bool))
      (!
         (=
            (switch_expression_3_2 none var var0 var1 var2 var3 var4 var5
               var6)
            65535)
         :pattern
         ((switch_expression_3_2 none var var0 var1 var2 var3 var4 var5 var6)))))
; constructor some
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive)
       (var7 Bool))
      (!
         (=
            (switch_expression_3_2 (some var) var0 var1 var2 var3 var4 var5
               var6 var7)
            (int_of_Z var))
         :pattern
         ((switch_expression_3_2 (some var) var0 var1 var2 var3 var4 var5
             var6 var7)))))
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Inductive)
       (var3 Int) (var4 Inductive) (var5 Inductive) (var6 Inductive))
      (!
         (=
            (switch_expression_3_0 (pair var var0) var1 var2 var3 var4 var5
               var6)
            (ite (unbox_bool var)
               (switch_expression_3_2
                  (lookup_lpm_long
                     (indexlong_from_ipv_4 var4 (int_of_Z var0)) var5)
                  var6 var5 var4 var3 var2 var1 var0 (unbox_bool var))
               (int_of_Z var0)))
         :pattern
         ((switch_expression_3_0 (pair var var0) var1 var2 var3 var4 var5
             var6)))))
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int)
       (var3 Inductive) (var4 Inductive))
      (!
         (= (switch_expression_2_6 (some var) var0 var1 var2 var3 var4)
            (switch_expression_3_0 var var4 var3 var2 var1 var0 var))
         :pattern
         ((switch_expression_2_6 (some var) var0 var1 var2 var3 var4)))))
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Inductive) (var2 Int))
      (!
         (= (lpm_dir__2_4__8_lookup var (tables var0 var1 var2))
            (switch_expression_2_6
               (lookup_lpm__2_4 (index_2_4_from_ipv_4 var)
                  (tables var0 var1 var2))
               (tables var0 var1 var2) var var2 var1 var0))
         :pattern ((lpm_dir__2_4__8_lookup var (tables var0 var1 var2))))))
; set_fpclauses
; function update_n
; switching on argument number 2
; constructor succ
(assert
   (forall ((var Inductive) (var0 Int) (var1 Inductive) (var2 Inductive))
      (!
         (= (update_n var var0 (succ var1) var2)
            (update_n (update var0 var2 var) (+ var0 1) var1 var2))
         :pattern ((update_n var var0 (succ var1) var2)))))
; constructor zero
(assert
   (forall ((var Inductive) (var0 Int) (var1 Inductive))
      (! (= (update_n var var0 zero var1) var)
         :pattern ((update_n var var0 zero var1)))))
; set_fpclauses
; function insert_route__2_4
; switching on argument number 1
; constructor rule
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int) (var2 Int))
      (!
         (= (insert_route__2_4 var (rule var0 var1 var2))
            (update_n var (compute_starting_index__2_4 (rule var0 var1 var2))
               (nat_of_int (compute_rule_size var1))
               (some (pair (box_bool false) (Z_of_int var2 N_1_6)))))
         :pattern ((insert_route__2_4 var (rule var0 var1 var2))))))
; set_fpclauses
; function insert_route_long
; switching on argument number 1
; constructor rule
(assert
   (forall
    ((var Inductive) (var0 Inductive) (var1 Int) (var2 Int) (var3 Int))
      (!
         (= (insert_route_long var (rule var0 var1 var2) var3)
            (update_n var
               (compute_starting_index_long (rule var0 var1 var2) var3)
               (nat_of_int (compute_rule_size var1))
               (some (Z_of_int var2 N_1_6))))
         :pattern ((insert_route_long var (rule var0 var1 var2) var3)))))
; set_fpclauses
; function insert_lpm__2_4
; switching on argument number 0
; constructor tables
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int) (var2 Inductive))
      (!
         (= (insert_lpm__2_4 (tables var var0 var1) var2)
            (tables (insert_route__2_4 var var2) var0 var1))
         :pattern ((insert_lpm__2_4 (tables var var0 var1) var2)))))
(declare-fun switch_expression_3_3
   (Inductive Inductive Inductive Int Inductive Inductive) Inductive)
; set_fpclauses
; function switch_expression_3_3
; switching on argument number 0
; constructor rule
(assert
   (forall
    ((var Inductive) (var0 Int) (var1 Int) (var2 Inductive) (var3 Inductive)
       (var4 Int) (var5 Inductive) (var6 Inductive))
      (!
         (=
            (switch_expression_3_3 (rule var var0 var1) var2 var3 var4 var5
               var6)
            (ite
               (is_new_index_needed
                  (lookup_lpm__2_4 (index_2_4_from_ipv_4 var) var3))
               (ite (= var4 256) (tables var6 var5 var4)
                  (tables
                     (update_n var6 (compute_starting_index__2_4 var2) N_1
                        (some (pair (box_bool true) (Z_of_int var4 N_1_6))))
                     (insert_route_long var5 var2 var4) (+ var4 1)))
               (tables var6
                  (insert_route_long var5 var2
                     (extract_2_4_value
                        (lookup_lpm__2_4 (index_2_4_from_ipv_4 var) var3)))
                  var4)))
         :pattern
         ((switch_expression_3_3 (rule var var0 var1) var2 var3 var4 var5
             var6)))))
; set_fpclauses
; function insert_lpm_long
; switching on argument number 0
; constructor tables
(declare-fun switch_expression_3_4
   (Inductive Inductive Inductive Int Inductive Inductive) Inductive)
; set_fpclauses
; function switch_expression_3_4
; switching on argument number 0
; constructor rule
(assert
   (forall
    ((var Inductive) (var0 Int) (var1 Int) (var2 Inductive) (var3 Inductive)
       (var4 Int) (var5 Inductive) (var6 Inductive))
      (!
         (=
            (switch_expression_3_4 (rule var var0 var1) var2 var3 var4 var5
               var6)
            (ite
               (is_new_index_needed
                  (lookup_lpm__2_4 (index_2_4_from_ipv_4 var) var3))
               (ite (= var4 256) (tables var6 var5 var4)
                  (tables
                     (update_n var6 (compute_starting_index__2_4 var2) N_1
                        (some (pair (box_bool true) (Z_of_int var4 N_1_6))))
                     (insert_route_long var5 var2 var4) (+ var4 1)))
               (tables var6
                  (insert_route_long var5 var2
                     (extract_2_4_value
                        (lookup_lpm__2_4 (index_2_4_from_ipv_4 var) var3)))
                  var4)))
         :pattern
         ((switch_expression_3_4 (rule var var0 var1) var2 var3 var4 var5
             var6)))))
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int) (var2 Inductive))
      (!
         (= (insert_lpm_long (tables var var0 var1) var2)
            (switch_expression_3_4 var2 var2 (tables var var0 var1) var1 var0
               var))
         :pattern ((insert_lpm_long (tables var var0 var1) var2)))))
; set_fpclauses
; function add_rule
; switching on argument number 1
; constructor rule
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int) (var2 Int))
      (!
         (= (add_rule var (rule var0 var1 var2))
            (ite (< var1 24) (insert_lpm__2_4 var (rule var0 var1 var2))
               (insert_lpm_long var (rule var0 var1 var2))))
         :pattern ((add_rule var (rule var0 var1 var2))))))
(assert
   (forall ((var Int))
      (!
         (= (entry__2_4_mapping var)
            (ite (= var 65535) none
               (some
                  (pair (box_bool (extract_flag var))
                     (Z_of_int (extract_value var) N_1_6)))))
         :pattern ((entry__2_4_mapping var)))))
(assert
   (forall ((var Int))
      (!
         (= (entry_long_mapping var)
            (ite (= var 65535) none (some (Z_of_int var N_1_6))))
         :pattern ((entry_long_mapping var)))))
(assert
   (forall ((var Inductive) (var0 Inductive) (var1 Int))
      (!
         (= (build_tables var var0 var1)
            (tables (map0 _@entry__2_4_mapping var)
               (map0 _@entry_long_mapping var0) var1))
         :pattern ((build_tables var var0 var1)))))
(assert
   (= dir_init
      (tables (repeat_n (nat_of_int 16777216) none)
         (repeat_n (nat_of_int 65536) none) 0)))
; set_fpclauses
; function get_someOption_2_4
; switching on argument number 0
; constructor some
(assert
   (forall ((var Inductive))
      (! (= (get_someOption_2_4 (some var)) var)
         :pattern ((get_someOption_2_4 (some var))))))
; constructor none
(assert (= (get_someOption_2_4 none) (pair (box_bool false) (Zsign false))))
(assert
   (forall ((var Int))
      (!
         (= (valid_entry_2_4 var)
            (ite (= var 65535) true
               (ite (extract_flag var)
                  (and (and (<= 32768 var) (<= var 33023))
                     (and (<= 0 (extract_value var))
                        (<= (extract_value var) 255)))
                  (and (<= 0 var) (<= var 32767)))))
         :pattern ((valid_entry_2_4 var)))))
(assert
   (forall ((var Int))
      (!
         (= (valid_entry_long var)
            (ite (= var 65535) true (and (<= 0 var) (<= var 32767))))
         :pattern ((valid_entry_long var)))))
; Assert: (= (func_rank update_n_length) 426)
(assert (= (func_rank update_n_length) 426))
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(push)
(declare-fun lst25 () Inductive)
(declare-fun start () Int)
(declare-fun count_0 () Inductive)
(declare-fun x36 () Inductive)
(declare-fun currentThread210 () Int)
(push)
(push)
; Assume: true
(assert true)
(check-sat)
(push)
(push)
(push)
(push)
; Assume: (= count_0 zero)
(assert (= count_0 zero))
(check-sat)
; Query: (= (length lst25) (length (update_n lst25 start count_0 x36)))
(push)
(assert (not (= (length lst25) (length (update_n lst25 start count_0 x36)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(push)
(declare-fun n20 () Inductive)
(push)
(push)
; Assume: (= count_0 (succ n20))
(assert (= count_0 (succ n20)))
(check-sat)
; Assert: (< (func_rank length_update) 0)
(assert (< (func_rank length_update) 0))
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (length (update start x36 lst25)) (length lst25))
(assert (= (length (update start x36 lst25)) (length lst25)))
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (length (update start x36 lst25)) (length (update_n (update start x36 lst25) (+ start 1) n20 x36)))
(assert
   (= (length (update start x36 lst25))
      (length (update_n (update start x36 lst25) (+ start 1) n20 x36))))
(check-sat)
; Query: (= (length lst25) (length (update_n lst25 start count_0 x36)))
(push)
(assert (not (= (length lst25) (length (update_n lst25 start count_0 x36)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(push)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(assert
   (forall ((var Inductive) (var0 Int) (var1 Inductive) (var2 Inductive))
      (! (=> true (= (length var) (length (update_n var var0 var1 var2))))
         :pattern ((length (update_n var var0 var1 var2))))))
(declare-fun equal_int_equal_Z () Int)
(declare-fun flag_mask_MSB_one () Int)
(declare-fun flag_mask_or_x_begins_with_one () Int)
(declare-fun flag_mask_or_x_not_affect__1_5LSB () Int)
(declare-fun extract_value_is_value () Int)
(declare-fun valid_next_hop_2_4 () Int)
(declare-fun valid_next_bucket_long () Int)
(declare-fun valid_next_hop_long () Int)
(declare-fun long_index_extraction_equivalence () Int)
(declare-fun long_index_computing_equivalence_on_prefixlen_3_2 () Int)
(declare-fun value_2_4_extraction_equivalence () Int)
(declare-fun first_index_depends_on_prefixlen () Int)
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(declare-fun equal_int_equal_Z_0 () Int)
(declare-fun flag_mask_MSB_one_0 () Int)
(declare-fun flag_mask_or_x_begins_with_one_0 () Int)
(declare-fun flag_mask_or_x_not_affect__1_5LSB_0 () Int)
(declare-fun extract_value_is_value_0 () Int)
(declare-fun valid_next_hop_2_4_0 () Int)
(declare-fun valid_next_bucket_long_0 () Int)
(declare-fun valid_next_hop_long_0 () Int)
(declare-fun long_index_extraction_equivalence_0 () Int)
(declare-fun long_index_computing_equivalence_on_prefixlen_3_2_0 () Int)
(declare-fun value_2_4_extraction_equivalence_0 () Int)
(declare-fun first_index_depends_on_prefixlen_0 () Int)
; Assert: (= (func_rank equal_int_equal_Z_0) 439)
(assert (= (func_rank equal_int_equal_Z_0) 439))
(push)
(declare-fun x37 () Int)
(declare-fun yZ () Inductive)
(declare-fun n21 () Inductive)
(declare-fun currentThread211 () Int)
(push)
; Assume: (= x37 (int_of_Z yZ))
(assert (= x37 (int_of_Z yZ)))
(check-sat)
(push)
; Assume: (<= 0 x37)
(assert (<= 0 x37))
(check-sat)
(push)
; Assume: (< x37 (pow_nat 2 n21))
(assert (< x37 (pow_nat 2 n21)))
(check-sat)
; Query: (= x37 (int_of_Z yZ))
(push)
(assert (not (= x37 (int_of_Z yZ))))
(check-sat)
(pop 1)
; Query: (<= 0 x37)
(push)
(assert (not (<= 0 x37)))
(check-sat)
(pop 1)
; Query: (< x37 (pow_nat 2 n21))
(push)
(assert (not (< x37 (pow_nat 2 n21))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (Z_of_int x37 n21) yZ)
(assert (= (Z_of_int x37 n21) yZ))
(check-sat)
; Query: (= (Z_of_int x37 n21) yZ)
(push)
(assert (not (= (Z_of_int x37 n21) yZ)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank flag_mask_MSB_one_0) 440)
(assert (= (func_rank flag_mask_MSB_one_0) 440))
(push)
(declare-fun currentThread212 () Int)
(push)
; Assume: true
(assert true)
(check-sat)
; Query: true
(push)
(assert (not true))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (extract_flag 32768) true)
(assert (= (extract_flag 32768) true))
(check-sat)
; Query: (= (extract_flag 32768) true)
(push)
(assert (not (= (extract_flag 32768) true)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank flag_mask_or_x_begins_with_one_0) 441)
(assert (= (func_rank flag_mask_or_x_begins_with_one_0) 441))
(push)
(declare-fun x38 () Int)
(declare-fun currentThread213 () Int)
(push)
; Assume: (<= 0 x38)
(assert (<= 0 x38))
(check-sat)
(push)
; Assume: (<= x38 65535)
(assert (<= x38 65535))
(check-sat)
; Query: (<= 0 x38)
(push)
(assert (not (<= 0 x38)))
(check-sat)
(pop 1)
; Query: (<= x38 65535)
(push)
(assert (not (<= x38 65535)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (extract_flag (bitor x38 32768)) true)
(assert (= (extract_flag (bitor x38 32768)) true))
(check-sat)
; Query: (= (extract_flag (bitor x38 32768)) true)
(push)
(assert (not (= (extract_flag (bitor x38 32768)) true)))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank flag_mask_or_x_not_affect__1_5LSB_0) 442)
(assert (= (func_rank flag_mask_or_x_not_affect__1_5LSB_0) 442))
(push)
(declare-fun x39 () Int)
(declare-fun currentThread214 () Int)
(push)
; Assume: (<= 0 x39)
(assert (<= 0 x39))
(check-sat)
(push)
; Assume: (<= x39 32767)
(assert (<= x39 32767))
(check-sat)
; Query: (<= 0 x39)
(push)
(assert (not (<= 0 x39)))
(check-sat)
(pop 1)
; Query: (<= x39 32767)
(push)
(assert (not (<= x39 32767)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= x39 (bitand (bitor x39 32768) 32767))
(assert (= x39 (bitand (bitor x39 32768) 32767)))
(check-sat)
; Query: (= x39 (bitand (bitor x39 32768) 32767))
(push)
(assert (not (= x39 (bitand (bitor x39 32768) 32767))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank extract_value_is_value_0) 443)
(assert (= (func_rank extract_value_is_value_0) 443))
(push)
(declare-fun entry () Int)
(declare-fun currentThread215 () Int)
(push)
; Assume: (<= 0 entry)
(assert (<= 0 entry))
(check-sat)
(push)
; Assume: (<= entry 32767)
(assert (<= entry 32767))
(check-sat)
; Query: (<= 0 entry)
(push)
(assert (not (<= 0 entry)))
(check-sat)
(pop 1)
; Query: (<= entry 32767)
(push)
(assert (not (<= entry 32767)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= entry (extract_value entry))
(assert (= entry (extract_value entry)))
(check-sat)
; Query: (= entry (extract_value entry))
(push)
(assert (not (= entry (extract_value entry))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank valid_next_hop_2_4_0) 444)
(assert (= (func_rank valid_next_hop_2_4_0) 444))
(push)
(declare-fun entry0 () Int)
(declare-fun mapped () Inductive)
(declare-fun currentThread216 () Int)
(push)
; Assume: (not (= entry0 65535))
(assert (not (= entry0 65535)))
(check-sat)
(push)
; Assume: (<= 0 entry0)
(assert (<= 0 entry0))
(check-sat)
(push)
; Assume: (<= entry0 32767)
(assert (<= entry0 32767))
(check-sat)
(push)
; Assume: (= false (extract_flag entry0))
(assert (= false (extract_flag entry0)))
(check-sat)
(push)
; Assume: (= (entry__2_4_mapping entry0) mapped)
(assert (= (entry__2_4_mapping entry0) mapped))
(check-sat)
(declare-fun p1 () Inductive)
(push)
; Assume: (= mapped (some p1))
(assert (= mapped (some p1)))
(check-sat)
(declare-fun b2 () Inductive)
(declare-fun v3 () Inductive)
(push)
; Assume: (= p1 (pair b2 v3))
(assert (= p1 (pair b2 v3)))
(check-sat)
; Query: (not (= entry0 65535))
(push)
(assert (not (not (= entry0 65535))))
(check-sat)
(pop 1)
; Query: (<= 0 entry0)
(push)
(assert (not (<= 0 entry0)))
(check-sat)
(pop 1)
; Query: (<= entry0 32767)
(push)
(assert (not (<= entry0 32767)))
(check-sat)
(pop 1)
; Query: (= false (extract_flag entry0))
(push)
(assert (not (= false (extract_flag entry0))))
(check-sat)
(pop 1)
; Query: (= (entry__2_4_mapping entry0) mapped)
(push)
(assert (not (= (entry__2_4_mapping entry0) mapped)))
(check-sat)
(pop 1)
(push)
; Assume: (= mapped none)
(assert (= mapped none))
(check-sat)
(pop 1)
(declare-fun value6 () Inductive)
(push)
; Assume: (= mapped (some value6))
(assert (= mapped (some value6)))
(check-sat)
(declare-fun value_03 () Bool)
(declare-fun value_15 () Inductive)
(push)
; Assume: (= value6 (pair (box_bool value_03) value_15))
(assert (= value6 (pair (box_bool value_03) value_15)))
(check-sat)
(push)
(push)
; Assume: (= value_03 false)
(assert (= value_03 false))
(check-sat)
(push)
; Assume: (= entry0 (int_of_Z value_15))
(assert (= entry0 (int_of_Z value_15)))
(check-sat)
; Query: (= (unbox_bool b2) false)
(push)
(assert (not (= (unbox_bool b2) false)))
(check-sat)
(pop 1)
; Query: (= entry0 (int_of_Z v3))
(push)
(assert (not (= entry0 (int_of_Z v3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank valid_next_bucket_long_0) 445)
(assert (= (func_rank valid_next_bucket_long_0) 445))
(push)
(declare-fun entry1 () Int)
(declare-fun mapped0 () Inductive)
(declare-fun currentThread217 () Int)
(push)
; Assume: (not (= entry1 65535))
(assert (not (= entry1 65535)))
(check-sat)
(push)
; Assume: (= true (extract_flag entry1))
(assert (= true (extract_flag entry1)))
(check-sat)
(push)
; Assume: (= true (valid_entry_2_4 entry1))
(assert (= true (valid_entry_2_4 entry1)))
(check-sat)
(push)
; Assume: (= (entry__2_4_mapping entry1) mapped0)
(assert (= (entry__2_4_mapping entry1) mapped0))
(check-sat)
(declare-fun p2 () Inductive)
(push)
; Assume: (= mapped0 (some p2))
(assert (= mapped0 (some p2)))
(check-sat)
(declare-fun b3 () Inductive)
(declare-fun v4 () Inductive)
(push)
; Assume: (= p2 (pair b3 v4))
(assert (= p2 (pair b3 v4)))
(check-sat)
; Query: (not (= entry1 65535))
(push)
(assert (not (not (= entry1 65535))))
(check-sat)
(pop 1)
; Query: (= true (extract_flag entry1))
(push)
(assert (not (= true (extract_flag entry1))))
(check-sat)
(pop 1)
; Query: (= true (valid_entry_2_4 entry1))
(push)
(assert (not (= true (valid_entry_2_4 entry1))))
(check-sat)
(pop 1)
; Query: (= (entry__2_4_mapping entry1) mapped0)
(push)
(assert (not (= (entry__2_4_mapping entry1) mapped0)))
(check-sat)
(pop 1)
(push)
; Assume: (= mapped0 none)
(assert (= mapped0 none))
(check-sat)
(pop 1)
(declare-fun value7 () Inductive)
(push)
; Assume: (= mapped0 (some value7))
(assert (= mapped0 (some value7)))
(check-sat)
(declare-fun value_04 () Bool)
(declare-fun value_16 () Inductive)
(push)
; Assume: (= value7 (pair (box_bool value_04) value_16))
(assert (= value7 (pair (box_bool value_04) value_16)))
(check-sat)
(push)
(push)
; Assume: (= value_04 true)
(assert (= value_04 true))
(check-sat)
(push)
; Assume: (= (extract_value entry1) (int_of_Z value_16))
(assert (= (extract_value entry1) (int_of_Z value_16)))
(check-sat)
; Query: (= (unbox_bool b3) true)
(push)
(assert (not (= (unbox_bool b3) true)))
(check-sat)
(pop 1)
; Query: (= (extract_value entry1) (int_of_Z v4))
(push)
(assert (not (= (extract_value entry1) (int_of_Z v4))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank valid_next_hop_long_0) 446)
(assert (= (func_rank valid_next_hop_long_0) 446))
(push)
(declare-fun entry2 () Int)
(declare-fun mapped1 () Inductive)
(declare-fun currentThread218 () Int)
(push)
; Assume: (not (= entry2 65535))
(assert (not (= entry2 65535)))
(check-sat)
(push)
; Assume: (<= 0 entry2)
(assert (<= 0 entry2))
(check-sat)
(push)
; Assume: (<= entry2 32767)
(assert (<= entry2 32767))
(check-sat)
(push)
; Assume: (= (entry_long_mapping entry2) mapped1)
(assert (= (entry_long_mapping entry2) mapped1))
(check-sat)
(declare-fun v5 () Inductive)
(push)
; Assume: (= mapped1 (some v5))
(assert (= mapped1 (some v5)))
(check-sat)
; Query: (not (= entry2 65535))
(push)
(assert (not (not (= entry2 65535))))
(check-sat)
(pop 1)
; Query: (<= 0 entry2)
(push)
(assert (not (<= 0 entry2)))
(check-sat)
(pop 1)
; Query: (<= entry2 32767)
(push)
(assert (not (<= entry2 32767)))
(check-sat)
(pop 1)
; Query: (= (entry_long_mapping entry2) mapped1)
(push)
(assert (not (= (entry_long_mapping entry2) mapped1)))
(check-sat)
(pop 1)
(push)
; Assume: (= mapped1 none)
(assert (= mapped1 none))
(check-sat)
(pop 1)
(declare-fun value8 () Inductive)
(push)
; Assume: (= mapped1 (some value8))
(assert (= mapped1 (some value8)))
(check-sat)
(push)
(push)
; Assume: (= entry2 (int_of_Z value8))
(assert (= entry2 (int_of_Z value8)))
(check-sat)
; Query: (= entry2 (int_of_Z v5))
(push)
(assert (not (= entry2 (int_of_Z v5))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank long_index_extraction_equivalence_0) 447)
(assert (= (func_rank long_index_extraction_equivalence_0) 447))
(push)
(declare-fun entry3 () Int)
(declare-fun mapped2 () Inductive)
(declare-fun currentThread219 () Int)
(push)
; Assume: (= (entry__2_4_mapping entry3) mapped2)
(assert (= (entry__2_4_mapping entry3) mapped2))
(check-sat)
(push)
; Assume: (not (= entry3 65535))
(assert (not (= entry3 65535)))
(check-sat)
(declare-fun p3 () Inductive)
(push)
; Assume: (= mapped2 (some p3))
(assert (= mapped2 (some p3)))
(check-sat)
(declare-fun z () Inductive)
(push)
; Assume: (= p3 (pair (box_bool true) z))
(assert (= p3 (pair (box_bool true) z)))
(check-sat)
(push)
; Assume: (= true (valid_entry_2_4 entry3))
(assert (= true (valid_entry_2_4 entry3)))
(check-sat)
(push)
; Assume: (= true (extract_flag entry3))
(assert (= true (extract_flag entry3)))
(check-sat)
; Query: (= (entry__2_4_mapping entry3) mapped2)
(push)
(assert (not (= (entry__2_4_mapping entry3) mapped2)))
(check-sat)
(pop 1)
; Query: (not (= entry3 65535))
(push)
(assert (not (not (= entry3 65535))))
(check-sat)
(pop 1)
(push)
; Assume: (= mapped2 none)
(assert (= mapped2 none))
(check-sat)
(pop 1)
(declare-fun value9 () Inductive)
(push)
; Assume: (= mapped2 (some value9))
(assert (= mapped2 (some value9)))
(check-sat)
(declare-fun value_05 () Bool)
(declare-fun value_17 () Inductive)
(push)
; Assume: (= value9 (pair (box_bool value_05) value_17))
(assert (= value9 (pair (box_bool value_05) value_17)))
(check-sat)
; Query: (= true value_05)
(push)
(assert (not (= true value_05)))
(check-sat)
(pop 1)
; Query: (= true (valid_entry_2_4 entry3))
(push)
(assert (not (= true (valid_entry_2_4 entry3))))
(check-sat)
(pop 1)
; Query: (= true (extract_flag entry3))
(push)
(assert (not (= true (extract_flag entry3))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (bitand entry3 255) (extract_2_4_value mapped2))
(assert (= (bitand entry3 255) (extract_2_4_value mapped2)))
(check-sat)
; Query: (= (bitand entry3 255) (extract_2_4_value mapped2))
(push)
(assert (not (= (bitand entry3 255) (extract_2_4_value mapped2))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank long_index_computing_equivalence_on_prefixlen_3_2_0) 448)
(assert
   (= (func_rank long_index_computing_equivalence_on_prefixlen_3_2_0) 448))
(push)
(declare-fun ipv_4 () Int)
(declare-fun base_index () Int)
(declare-fun currentThread220 () Int)
(push)
; Assume: (<= 0 ipv_4)
(assert (<= 0 ipv_4))
(check-sat)
(push)
; Assume: (<= ipv_4 4294967295)
(assert (<= ipv_4 4294967295))
(check-sat)
; Query: (<= 0 ipv_4)
(push)
(assert (not (<= 0 ipv_4)))
(check-sat)
(pop 1)
; Query: (<= ipv_4 4294967295)
(push)
(assert (not (<= ipv_4 4294967295)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (compute_starting_index_long (init_rule ipv_4 32 0) base_index) (indexlong_from_ipv_4 (Z_of_int ipv_4 N_3_2) base_index))
(assert
   (= (compute_starting_index_long (init_rule ipv_4 32 0) base_index)
      (indexlong_from_ipv_4 (Z_of_int ipv_4 N_3_2) base_index)))
(check-sat)
; Query: (= (compute_starting_index_long (init_rule ipv_4 32 0) base_index) (indexlong_from_ipv_4 (Z_of_int ipv_4 N_3_2) base_index))
(push)
(assert
   (not
      (= (compute_starting_index_long (init_rule ipv_4 32 0) base_index)
         (indexlong_from_ipv_4 (Z_of_int ipv_4 N_3_2) base_index))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank value_2_4_extraction_equivalence_0) 449)
(assert (= (func_rank value_2_4_extraction_equivalence_0) 449))
(push)
(declare-fun entry4 () Int)
(declare-fun mapped3 () Inductive)
(declare-fun currentThread221 () Int)
(push)
; Assume: (<= 0 (extract_value entry4))
(assert (<= 0 (extract_value entry4)))
(check-sat)
(push)
; Assume: (<= (extract_value entry4) 255)
(assert (<= (extract_value entry4) 255))
(check-sat)
(push)
; Assume: (= (extract_flag entry4) true)
(assert (= (extract_flag entry4) true))
(check-sat)
(push)
; Assume: (= (valid_entry_2_4 entry4) true)
(assert (= (valid_entry_2_4 entry4) true))
(check-sat)
(push)
; Assume: (= (entry__2_4_mapping entry4) mapped3)
(assert (= (entry__2_4_mapping entry4) mapped3))
(check-sat)
(declare-fun p4 () Inductive)
(push)
; Assume: (= mapped3 (some p4))
(assert (= mapped3 (some p4)))
(check-sat)
(push)
; Assume: (= p4 (pair (box_bool true) (Z_of_int (extract_value entry4) N_1_6)))
(assert
   (= p4 (pair (box_bool true) (Z_of_int (extract_value entry4) N_1_6))))
(check-sat)
; Query: (<= 0 (extract_value entry4))
(push)
(assert (not (<= 0 (extract_value entry4))))
(check-sat)
(pop 1)
; Query: (<= (extract_value entry4) 255)
(push)
(assert (not (<= (extract_value entry4) 255)))
(check-sat)
(pop 1)
; Query: (= (extract_flag entry4) true)
(push)
(assert (not (= (extract_flag entry4) true)))
(check-sat)
(pop 1)
; Query: (= (valid_entry_2_4 entry4) true)
(push)
(assert (not (= (valid_entry_2_4 entry4) true)))
(check-sat)
(pop 1)
; Query: (= (entry__2_4_mapping entry4) mapped3)
(push)
(assert (not (= (entry__2_4_mapping entry4) mapped3)))
(check-sat)
(pop 1)
(push)
; Assume: (= mapped3 none)
(assert (= mapped3 none))
(check-sat)
(pop 1)
(declare-fun value10 () Inductive)
(push)
; Assume: (= mapped3 (some value10))
(assert (= mapped3 (some value10)))
(check-sat)
; Query: (= value10 (pair (box_bool true) (Z_of_int (extract_value entry4) N_1_6)))
(push)
(assert
   (not
      (= value10
         (pair (box_bool true) (Z_of_int (extract_value entry4) N_1_6)))))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (= (extract_value entry4) (extract_2_4_value mapped3))
(assert (= (extract_value entry4) (extract_2_4_value mapped3)))
(check-sat)
; Query: (= (extract_value entry4) (extract_2_4_value mapped3))
(push)
(assert (not (= (extract_value entry4) (extract_2_4_value mapped3))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
; Assert: (= (func_rank first_index_depends_on_prefixlen_0) 450)
(assert (= (func_rank first_index_depends_on_prefixlen_0) 450))
(push)
(declare-fun new_rule () Inductive)
(declare-fun base_index0 () Int)
(declare-fun prefixlen () Int)
(declare-fun currentThread222 () Int)
(push)
; Assume: (<= 0 base_index0)
(assert (<= 0 base_index0))
(check-sat)
(push)
; Assume: (< base_index0 256)
(assert (< base_index0 256))
(check-sat)
(push)
; Assume: (<= 24 prefixlen)
(assert (<= 24 prefixlen))
(check-sat)
(push)
; Assume: (<= prefixlen 32)
(assert (<= prefixlen 32))
(check-sat)
(declare-fun ipv_40 () Inductive)
(declare-fun value11 () Int)
(push)
; Assume: (= new_rule (rule ipv_40 prefixlen value11))
(assert (= new_rule (rule ipv_40 prefixlen value11)))
(check-sat)
(push)
; Assume: (<= 0 (int_of_Z ipv_40))
(assert (<= 0 (int_of_Z ipv_40)))
(check-sat)
(push)
; Assume: (<= (int_of_Z ipv_40) 4294967295)
(assert (<= (int_of_Z ipv_40) 4294967295))
(check-sat)
; Query: (<= 0 base_index0)
(push)
(assert (not (<= 0 base_index0)))
(check-sat)
(pop 1)
; Query: (< base_index0 256)
(push)
(assert (not (< base_index0 256)))
(check-sat)
(pop 1)
; Query: (<= 24 prefixlen)
(push)
(assert (not (<= 24 prefixlen)))
(check-sat)
(pop 1)
; Query: (<= prefixlen 32)
(push)
(assert (not (<= prefixlen 32)))
(check-sat)
(pop 1)
(declare-fun value_06 () Inductive)
(declare-fun value_18 () Int)
(declare-fun value_22 () Int)
(push)
; Assume: (= new_rule (rule value_06 value_18 value_22))
(assert (= new_rule (rule value_06 value_18 value_22)))
(check-sat)
; Query: (= prefixlen value_18)
(push)
(assert (not (= prefixlen value_18)))
(check-sat)
(pop 1)
; Query: (<= 0 (int_of_Z value_06))
(push)
(assert (not (<= 0 (int_of_Z value_06))))
(check-sat)
(pop 1)
; Query: (<= (int_of_Z value_06) 4294967295)
(push)
(assert (not (<= (int_of_Z value_06) 4294967295)))
(check-sat)
(pop 1)
(push)
(push)
; Assume: (<= (compute_starting_index_long new_rule base_index0) (- 16777216 (compute_rule_size prefixlen)))
(assert
   (<= (compute_starting_index_long new_rule base_index0)
      (- 16777216 (compute_rule_size prefixlen))))
(check-sat)
; Query: (<= (compute_starting_index_long new_rule base_index0) (- 16777216 (compute_rule_size prefixlen)))
(push)
(assert
   (not
      (<= (compute_starting_index_long new_rule base_index0)
         (- 16777216 (compute_rule_size prefixlen)))))
(check-sat)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(pop 1)
(assert
   (forall ((var Int) (var0 Int))
      (! (= (func_lt var var0) (< (func_rank var) (func_rank var0)))
         :pattern ((func_lt var var0)))))
(push)
(declare-fun x40 () Int)
(declare-fun yZ0 () Inductive)
(declare-fun n22 () Inductive)
(declare-fun currentThread223 () Int)
(push)
(push)
; Assume: (= x40 (int_of_Z yZ0))
(assert (= x40 (int_of_Z yZ0)))
(check-sat)
(push)
; Assume: (<= 0 x40)
(assert (<= 0 x40))
(check-sat)
(push)
; Assume: (< x40 (pow_nat 2 n22))
(assert (< x40 (pow_nat 2 n22)))
(check-sat)
(push)
(push)
; Query: (= x40 (int_of_Z yZ0))
(push)
(assert (not (= x40 (int_of_Z yZ0))))
(check-sat)
(pop 1)
; Query: (<= 0 (int_of_Z yZ0))
(push)
(assert (not (<= 0 (int_of_Z yZ0))))
(check-sat)
(pop 1)
; Query: (< (int_of_Z yZ0) (pow_nat 2 n22))
(push)
(assert (not (< (int_of_Z yZ0) (pow_nat 2 n22))))
(check-sat)
(pop 1)
; Query: (<= 0 x40)
(push)
(assert (not (<= 0 x40)))
(check-sat)
(pop 1)
; Query: (< x40 (pow_nat 2 n22))
(push)
(assert (not (< x40 (pow_nat 2 n22))))
(check-sat)
(pop 1)
(declare-fun xZ () Inductive)
(push)
(push)
; Assume: (= xZ (Z_of_bits (Zsign false) (snd (bits_of_int x40 n22))))
(assert (= xZ (Z_of_bits (Zsign false) (snd (bits_of_int x40 n22)))))
(check-sat)
(push)
; Assume: (= x40 (int_of_Z xZ))
(assert (= x40 (int_of_Z xZ)))
(check-sat)
; Query: (<= 0 (int_of_Z yZ0))
(push)
(assert (not (<= 0 (int_of_Z yZ0))))
(check-sat)
(pop 1)
; Query: (< (int_of_Z yZ0) (pow_nat 2 n22))
(push)
(assert (not (< (int_of_Z yZ0) (pow_nat 2 n22))))
(check-sat)
(pop 1)
(declare-fun yZ_bis () Inductive)
(push)
(push)
; Assume: (= yZ_bis (Z_of_bits (Zsign false) (snd (bits_of_int (int_of_Z yZ0) n22))))
(assert
   (= yZ_bis
      (Z_of_bits (Zsign false) (snd (bits_of_int (int_of_Z yZ0) n22)))))
(check-sat)
(push)
; Assume: (= (int_of_Z yZ0) (int_of_Z yZ_bis))
(assert (= (int_of_Z yZ0) (int_of_Z yZ_bis)))
(check-sat)
; Query: (= xZ yZ_bis)
(push)
(assert (not (= xZ yZ_bis)))
(check-sat)
(pop 1)
; Query: (= yZ0 yZ_bis)
(push)
(assert (not (= yZ0 yZ_bis)))
(check-sat)
(pop 1)
