#ifndef _PRIME_GH_INCLUDED_
#define _PRIME_GH_INCLUDED_

#include <nat.gh>
#include "modulo.gh"

fixpoint int min(int x, int y) {
    return x < y ? x : y;
} 

fixpoint bool divide(int quotient, int divisor) {
    return (quotient/divisor)*divisor == quotient; 
}

fixpoint bool common_divide(int quotient1, int quotient2, int divisor) {
    return divide(quotient1, divisor) && divide(quotient2, divisor);
} 

fixpoint bool is_prime_div(int x, nat divisor) {
    switch(divisor) {
        case zero: return false;
        case succ(divisor_pred):
            return divisor_pred == zero 
                ? false
                : divisor_pred == succ(zero) 
                    ? !divide(x, int_of_nat(divisor))
                    : !divide(x, int_of_nat(divisor)) && is_prime_div(x, divisor_pred);
    }

}

fixpoint bool is_prime(int x) {
    return is_prime_div(x, nat_of_int(x));
}

fixpoint bool are_coprime_div(int x, int y, nat divisor) {
    switch(divisor) {
        case zero: return false;
        case succ(divisor_pred):
            return divisor_pred == zero
                ? false
                : divisor_pred == succ(zero)
                    ? !common_divide(x, y, int_of_nat(divisor))
                    : !common_divide(x, y, int_of_nat(divisor)) && are_coprime_div(x, y, divisor_pred);
    }

}

fixpoint bool are_coprime(int x, int y) {
    return are_coprime_div(x, y, nat_of_int(min(x,y)));
}

// Assumption !
lemma void prime_is_coprime_with_anything(int prime, int n)
    requires    true == is_prime(prime) &*& 0 < n;
    ensures     true == are_coprime(prime, n);
{
    assume (true == are_coprime(prime, n));
}

lemma void modulo_less_than(int k, int m)
    requires 0 <= k &*& k < m &*& 0 < m;
    ensures k % m == k;
{
    division_round_to_zero(k, m);
    div_rem_nonneg(k, m);
}

// Assumption !
lemma void modulo_add_constant(int a, int b, int offset, int mod)
    requires 0 <= a &*& 0 <= b &*& 0 <= offset &*& 0 <= mod &*&
             a % mod != b % mod;
    ensures  (a + offset) % mod != (b + offset) % mod;
{
    assume ((a + offset) % mod != (b + offset) % mod);
}

// Assumption !
lemma void modulo_mul_coprime(int k, int s, int m)
    requires
        0 < k &*& k < m &*&
        0 < s &*& s < m &*&
        0 < m &*& 
        (k % m != 0) &*& true == are_coprime(s, m);
    ensures
        (k * s) % m != 0;
{
    assume ((k * s) % m != 0);
}

// Assumption !
lemma void modulo_mul_split(int a, int b, int m)
    requires
        0 <= a &*& 0 <= b &*& 
        0 < m &*& 
        (b - a) % m != 0;
    ensures
        b % m != a % m;
{
    assume (b % m != a % m);
}

lemma void modulo_permutation(int a, int b, int s, int m) 
    requires 
        0 <= a &*& a < m &*&
        0 <= b &*& b < m &*&
        0 < s &*& s < m &*&
        0 < m &*& 
        b > a &*& true == are_coprime(s, m);
    ensures
        (s * a) % m != (s * b) % m;
{
    modulo_less_than(b - a, m);
    modulo_mul_coprime(b - a, s, m);
    assert ((s * (b - a)) % m != 0 );
    assert ((s * b - s * a) % m != 0 );
    mul_nonnegative(s, a);
    mul_nonnegative(s, b);
    modulo_mul_split(s * a, s * b, m);
    assert ( (s * b) % m != (s * a) % m );
} 

#endif //_PRIME_GH_INCLUDED_
