#ifndef _PERMUTLIST_GH_INCLUDED_
#define _PERMUTLIST_GH_INCLUDED_

#include <nat.gh>
#include "stdex.gh"

fixpoint bool is_sub_permutation(list<int> xs, int max_val) {
    return forall(xs, (lt)(max_val)) && true == forall(xs, (ge)(0)) && no_dups(xs);
}

fixpoint bool is_permutation(list<int> xs) {
    return forall(xs, (lt)(length(xs))) && true == forall(xs, (ge)(0)) && no_dups(xs);
}

fixpoint bool permutation_contains_all(list<int> xs, nat x) {
    switch(x) {
        case zero: return mem(int_of_nat(zero), xs);
        case succ(x_pred): return mem(int_of_nat(x), xs) && permutation_contains_all(xs, x_pred);
    }
}

lemma void permutation_def_to_contains_all(list<int> xs)
    requires    true == is_permutation(xs);
    ensures     true == permutation_contains_all(xs, nat_of_int(length(xs)));
{
    assume (true == permutation_contains_all(xs, nat_of_int(length(xs))));
}

lemma void permutation_contains_all_to_some(list<int> xs, int check_for)
    requires
        true == permutation_contains_all(xs, nat_of_int(length(xs))) &*&
        0 <= check_for &*& check_for < length(xs);
    ensures
        true == mem(check_for, xs);
{
    assume (true == mem(check_for, xs));
}

fixpoint list<t> list_append<t>(list<t> xs, t x_tail) {
    switch(xs) {
        case nil: return cons(x_tail, nil);
        case cons(x0, xs0): return cons(x0, list_append(xs0, x_tail));
    }
}

fixpoint list<t> chunk<t>(list<t> xs, int begin, int end) {
    return take(end - begin, drop(begin, xs));
}

fixpoint list< list<t> > list_split_every_n<t>(list<t> xs, nat nb_split, int n) {
    switch(nb_split) {
        case zero: return nil;
        case succ(nb_split_pred): 
            return cons(take(n, xs), list_split_every_n(drop(n, xs), nb_split_pred, n));
    }
}

lemma void split_to_source<t>(list<t> xs, nat nb_split, int n, int i, int j)
    requires    length(xs) == int_of_nat(nb_split) * n &*&
                0 <= i &*& i < n &*&
                0 <= j &*& j < int_of_nat(nb_split);
    ensures     nth(i, nth(j, list_split_every_n(xs, nb_split, n))) == nth(j * n + i, xs);
{
    assume (nth(i, nth(j, list_split_every_n(xs, nb_split, n))) == nth(j * n + i, xs));
}

lemma_auto(length(list_split_every_n(xs, nb_split, n))) void length_split<t>(list<t> xs, nat nb_split, int n)
    requires    length(xs) == int_of_nat(nb_split) * n;
    ensures     length(list_split_every_n(xs, nb_split, n)) == int_of_nat(nb_split);
{
    assume (length(list_split_every_n(xs, nb_split, n)) == int_of_nat(nb_split));
}

lemma void length_split_forall<t>(list<t> xs, nat nb_split, int n, int i)
    requires    length(xs) == int_of_nat(nb_split) * n &*& 0 <= i &*& i < length(xs);
    ensures     length(nth(i, list_split_every_n(xs, nb_split, n))) == n;
{
    assume (length(nth(i, list_split_every_n(xs, nb_split, n))) == n);
}

fixpoint list< pair<int, t> > zip_with_index_recursive<t>(list<t> xs, int index) {
    switch(xs) {
        case nil: return nil;
        case cons(x0, xs0): return cons( pair(index, x0), zip_with_index_recursive(xs0, index + 1) );
    }
}

fixpoint list< pair<int, t> > zip_with_index<t>(list<t> xs) {
    return zip_with_index_recursive(xs, 0);
}

fixpoint list< pair<t1, t2> > zip<t1, t2>(list<t1> xs, list<t2> ys) {
    switch(xs) {
        case nil: return nil;
        case cons(x0, xs0): return cons( pair(x0, head(ys)) , zip(xs0, tail(ys)) );
    }
}

fixpoint list<int> first_n_integers_recursive(nat max, int index) {
    switch(max) {
        case zero: return nil;
        case succ(max_pred): return cons(index, first_n_integers_recursive(max_pred, index + 1));
    }
}

fixpoint list<int> first_n_integers(int n) {
    return first_n_integers_recursive(nat_of_int(n), 0);
}

fixpoint bool eq<t>(pair<t,t> p) { return fst(p) == snd(p); }

fixpoint bool l_contains<t>(list<t> xs, t x) {
    switch(xs) {
        case nil: return false;
        case cons(x0, xs0) : return x0 == x || l_contains(xs0, x); 
    }
}

lemma void take_full<t>(list<t> xs)
    requires    true;
    ensures     take(length(xs), xs) == xs;
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): take_full(xs0);
    }
}

lemma void ints_to_nth(list<int> xs, list<int> xs_orig, int i, int val)
    requires    xs == update(i, val, xs_orig);
    ensures     nth(i, xs) == val;
{
    assume (nth(i, xs) == val);
    // TODO
}

lemma void append_take<t>(list<t> xs, int i, fixpoint (t,bool) f)
    requires 
        0 <= i &*& i < length(xs) &*&
        true == forall(take(i, xs), f) &*& true == f(nth(i, xs));
    ensures 
        true == forall(take(i + 1, xs), f);
{
    assume (true == forall(take(i + 1, xs), f));
    // TODO
}

lemma void permutation_contains(list<int> xs)
    requires    true == is_permutation(xs);
    ensures     true == forall(xs, (l_contains)(xs));
{
    assume (true == forall(xs, (l_contains)(xs)));
    // TODO
} 

lemma void unzip<t>(list<t> xs)
    requires    true;
    ensures     xs == map(snd, zip_with_index(xs));
{
    assume (xs == map(snd, zip_with_index(xs)));
    // TODO
}

lemma void isolate_chunk_length<t>(list<t> xs, int begin, int end)
    requires    0 <= begin &*& begin <= end &*& end <= length(xs);
    ensures     length(chunk(xs, begin, end)) == end - begin;
{
    length_take(begin, xs);
    length_drop(end - begin, drop(begin, xs));
}

lemma void append_length<t>(list<t> xs, t x)
    requires    true;
    ensures     length(list_append(xs, x)) == length(xs) + 1;
{
    switch(xs) {
        case nil: 
        case cons(x0, xs0): append_length(xs0, x);
    }
}

lemma void append_preserves_fixpoint<t>(list<t> xs, t x, fixpoint (t,bool) f)
    requires 
        true == forall(xs, (f)) &*&
        true == f(x);
    ensures
        true == forall(list_append(xs, x), (f));
{
    switch(xs) {
        case nil:
            assert (list_append(xs, x) == cons(x, nil));
            assert (true == f(x));
        case cons(x0, xs0):
            append_preserves_fixpoint(xs0, x, f);
    }
}

lemma void append_preserves_bounds(list<int> xs, int x, int low_bound, int up_bound)
    requires
        true == forall(xs, (lt)(up_bound)) &*&
        true == forall(xs, (ge)(low_bound)) &*&
        low_bound <= x &*& x < up_bound;
    ensures
        true == forall(list_append(xs, x), (lt)(up_bound)) &*&
        true == forall(list_append(xs, x), (ge)(low_bound));
{
    switch(xs) {
        case nil:
            assert (list_append(xs, x) == cons(x, nil));
            assert (low_bound <= x && x < up_bound);
        case cons(x0, xs0):
            assert (low_bound <= x0 && x0 < up_bound);
            append_preserves_bounds(xs0, x, low_bound, up_bound);
    }
}

lemma void append_to_zip<t>(list<t> xs, t x) 
    requires true;
    ensures list_append(zip_with_index(xs), pair(length(xs),x)) == zip_with_index(list_append(xs, x));
{
    switch(xs) {
        case nil:
            assert (list_append(xs, x) == cons(x, nil));
            list<t> l = list_append(xs, x);
            assert (zip_with_index(l) == cons(pair(0, x), nil) );
            
            list< pair<int, t> > z = zip_with_index(xs);
            assert (list_append(z, pair(0, x)) == cons( pair(0, x), nil));

        case cons(x0, xs0):
            assume (list_append(zip_with_index(xs), pair(length(xs),x)) == zip_with_index(list_append(xs, x)));
            //TODO
    }
} 

lemma void zip_with_index_bounds<t>(list<t> xs) 
    requires true;
    ensures 
        true == forall( map(fst, zip_with_index(xs)), (lt)(length(xs)) ) &*&
        true == forall( map(fst, zip_with_index(xs)), (ge)(0) );
{
    assume ( true == forall( map(fst, zip_with_index(xs)), (lt)(length(xs)) ));
    assume ( true == forall( map(fst, zip_with_index(xs)), (ge)(0) ));
    //TODO
}

lemma void zip_no_dups_helper<t>(list<t> xs, int index)
    requires true;
    ensures xs == nil ? true : fst(head(zip_with_index_recursive(xs, index))) == index;
{
    switch(xs) {
        case nil: true;
        case cons(x0, xs0): assert(fst(head(zip_with_index_recursive(xs, index))) == index);
    }
}

lemma void zip_no_dups_rec<t>(list< pair<int, t> > xs_ziped, list<t> xs, int index)
    requires xs_ziped == zip_with_index_recursive(xs, index);
    ensures true == no_dups(map(fst, xs_ziped));
{
    assume (true == no_dups(map(fst, xs_ziped))); //TODO
}

lemma void zip_no_dups<t>(list<t> xs)
    requires true;
    ensures true == no_dups(map(fst, zip_with_index(xs)));
{
    list< pair<int, t> > xs_ziped = zip_with_index_recursive(xs, 0);
    zip_no_dups_rec(xs_ziped, xs, 0);
}

lemma void chunk_zerosize<t>(list<t> xs, int n)
    requires true;
    ensures chunk(xs, n, n) == nil;
{
    list<t> drop_xs = drop(n, xs);
    take_0(drop_xs);
}

#endif //_PERMUTLIST_GH_INCLUDED_
