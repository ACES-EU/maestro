#ifndef _MOD_POW2_INCLUDED_
#define _MOD_POW2_INCLUDED_

#include "modulo.gh"
#include "stdex.gh"
#include "listexex.gh"
#include <bitops.gh>
#include <nat.gh>
#include <listex.gh>

// ------------- arithmetic -------------

lemma void div_rem_nonneg_wrap(int D, int d);
    requires    0 <= D &*& 0 < d;
    ensures     D == D / d * d + D % d &*& 0 <= D / d &*& D / d <= D &*& 0 <= D % d &*& D % d < d;


lemma void div_minus_one(int a, int b);
    requires    0 < a &*& 0 < b;
    ensures     (a*b - 1) / b == a - 1;

lemma void div_plus_one(int a, int b);
    requires    0 < a &*& 1 < b;
    ensures     (a*b + 1) / b == a;

lemma void loop_fp_pop(int k, int capacity);
    requires    0 <= k &*& 0 < capacity;
    ensures     loop_fp(k, capacity) == k % capacity;

lemma void mod_reduce(int a, int b, int k);
    requires    0 <= a &*& 0 < b &*& 0 <= k;
    ensures     (a + b*k) % b == a % b;

lemma void mod_rotate_mul(int a, int b);
    requires    0 <= a &*& 0 < b;
    ensures     ((a * b) % b) == 0;

lemma void mod_mul(int a, int b, int k);
    requires    0 <= a &*& 0 < b &*& 0 < k &*& a % b == 0;
    ensures     (k*a) % (k*b) == 0;

// ------------- pow_nat/pow2 -------------

fixpoint int pow2(nat m) {
    return pow_nat(2, m);
}

lemma void pow_nat_div_rem(int x, nat n);
    requires    0 < x &*& n != zero;
    ensures     pow_nat(x, n) / x == pow_nat(x, nat_predecessor(n)) &*& pow_nat(x, n) % x == 0;

lemma void pow_nat_bounds(int x, nat n);
    requires    0 < x;
    ensures     0 < pow_nat(x, n);

fixpoint option<nat> is_pow2(int x, nat m) {
    switch(m) {
        case zero: return (x == pow2(zero) ? some(zero) : none);
        case succ(m_pred): return (x == pow2(m) ? some(m) : is_pow2(x, m_pred));
    }
}

lemma nat is_pow2_some(int x, nat m);
    requires    is_pow2(x, m) != none;
    ensures     x == pow2(result) &*& int_of_nat(result) <= int_of_nat(m);

// ------------- bitwise representation of capacity -------------

lemma void bits_of_int_zero(nat n);
    requires    true;
    ensures     true == forall(snd(bits_of_int(0, n)), (eq)(false)) &*& fst(bits_of_int(0, n)) == 0;

lemma void int_of_bits_zero(list<bool> bits);
    requires    true == forall(bits, (eq)(false));
    ensures     int_of_bits(0, bits) == 0;

lemma void bits_of_int_remainder(int x, nat n);
    requires    0 <= x &*& x < pow2(n);
    ensures     fst(bits_of_int(x, n)) == 0;

lemma void bits_of_int_pow2_mask(nat n, nat m);
    requires
        int_of_nat(m) <= int_of_nat(n);
    ensures
        true == forall(take(int_of_nat(m), snd(bits_of_int(pow2(m)-1, n))), (eq)(true)) &*& 
        true == forall(drop(int_of_nat(m), snd(bits_of_int(pow2(m)-1, n))), (eq)(false)) &*& 
        0 == fst(bits_of_int(pow2(m)-1, n));

// ------------- k & (capacity - 1)  -------------

fixpoint list<bool> bits_of_int_and(list<bool> x_bits, list<bool> y_bits) {
    switch(x_bits) {
        case nil: return y_bits;
        case cons(x0, xs0): return switch(y_bits) {
            case nil: return x_bits;
            case cons(y0, ys0): return cons(x0 && y0, bits_of_int_and(xs0, ys0));
        };
    }
}


lemma void length_bits_of_int_and(list<bool> x_bits, list<bool> y_bits);
    requires    true;
    ensures     length(bits_of_int_and(x_bits, y_bits)) == ((length(x_bits) < length(y_bits)) ? length(y_bits) : length(x_bits));

lemma_auto(length(snd(bits_of_int(x, n)))) void length_bits_of_int(int x, nat n) ;
    requires    true; 
    ensures     length(snd(bits_of_int(x, n))) == int_of_nat(n);

lemma void bits_of_int_and_zero(list<bool> x_bits, list<bool> y_bits);
    requires    length(x_bits) == length(y_bits) &*& true == forall(y_bits, (eq)(false)); 
    ensures     true == forall(bits_of_int_and(x_bits, y_bits), (eq)(false));

lemma void bits_of_int_and_mask(list<bool> k_bits, list<bool> mask_bits, int m);
    requires 
        length(k_bits) == length(mask_bits) &*& 
        true == forall(take(m, mask_bits), (eq)(true)) &*& 
        true == forall(drop(m, mask_bits), (eq)(false)) &*&
        0 <= m &*& m < length(k_bits);
    ensures
        take(m, k_bits) == take(m, bits_of_int_and(k_bits, mask_bits)) &*&
        true == forall(drop(m, bits_of_int_and(k_bits, mask_bits)), (eq)(false));

lemma void int_of_Z_of_bits(list<bool> bits);
    requires    true;
    ensures     int_of_Z(Z_of_bits(Zsign(false), bits)) == int_of_bits(0, bits);

lemma void int_of_bits_bounds(list<bool> bits);
    requires    true;
    ensures     0 <= int_of_bits(0, bits);

lemma void bits_of_int_of_bits(list<bool> bits, nat n);
    requires    int_of_nat(n) == length(bits);
    ensures     bits == snd(bits_of_int(int_of_bits(0, bits), n));

lemma void Z_bits_of_int_and_equiv(list<bool> xs, list<bool> ys);
    requires    length(xs) == length(ys);
    ensures     Z_and(Z_of_bits(Zsign(false), xs), Z_of_bits(Zsign(false), ys)) == Z_of_bits(Zsign(false), bits_of_int_and(xs, ys));

lemma void bits_of_int_and_def(int x, list<bool> x_bits, int y, list<bool> y_bits, nat n);
    requires 
        bits_of_int(x, n) == pair(0, x_bits) &*& 
        bits_of_int(y, n) == pair(0, y_bits) &*& 
        0 <= x &*& x < pow2(n) &*& 0 <= y &*& y < pow2(n);
    ensures
        (x & y) == int_of_bits(0, bits_of_int_and(x_bits, y_bits));

lemma void bits_of_int_apply_mask(int k, list<bool> k_bits, int mask, list<bool> mask_bits, int m, nat n); 
    requires 
        bits_of_int(k, n) == pair(0, k_bits) &*& 
        bits_of_int(mask, n) == pair(0, mask_bits) &*& 
        true == forall(take(m, mask_bits), (eq)(true)) &*& 
        true == forall(drop(m, mask_bits), (eq)(false)) &*& 
        0 <= k &*& k < pow2(n) &*& 0 <= mask &*& mask < pow2(n) &*& 
        0 <= m &*& m < int_of_nat(n); 
    ensures 
        take(m, snd(bits_of_int(k & mask, n))) == take(m, k_bits) &*& 
        true == forall(drop(m, snd(bits_of_int(k & mask, n))), (eq)(false));

// ------------- k % capacity -------------

lemma void bits_of_int_split(int k, nat n, int m, list<bool> k_bits, list<bool> l_bits, list<bool> r_bits); 
    requires 
        snd(bits_of_int(k, n)) == k_bits &*& 
        0 <= k &*& k < pow2(n) &*& 
        0 <= m &*& m < int_of_nat(n) &*& 
        length(l_bits) == length(r_bits) &*& length(r_bits) == length(k_bits) &*& 
        take(m, k_bits) == take(m, l_bits) &*& true == forall(drop(m, l_bits), (eq)(false)) &*& 
        drop(m, k_bits) == drop(m, r_bits) &*& true == forall(take(m, r_bits), (eq)(false));
    ensures
        k == int_of_bits(0, l_bits) + int_of_bits(0, r_bits);

lemma void int_of_bits_lt(list<bool> bits, nat m);
    requires
        0 <= int_of_nat(m) &*& int_of_nat(m) < length(bits) &*&
        true == forall(drop(int_of_nat(m), bits), (eq)(false));
    ensures
        int_of_bits(0, bits) < pow2(m);

lemma void int_of_bits_mul(list<bool> bits, nat m);
    requires
        0 <= int_of_nat(m) &*& int_of_nat(m) < length(bits) &*&
        true == forall(take(int_of_nat(m), bits), (eq)(false));
    ensures
        int_of_bits(0, bits) % pow2(m) == 0;

fixpoint list<bool> gen_r_bits(list<bool> k_bits, int m) {
    switch(k_bits) {
        case nil: return nil;
        case cons(k0, ks0): return ((m > 0) ? cons(false, gen_r_bits(ks0, m - 1)) : cons(k0, gen_r_bits(ks0, 0)));
    }
}

lemma void gen_r_bits_works(list<bool> k_bits, int m);
    requires    
        0 <= m &*& m <= length(k_bits);
    ensures     
        drop(m, gen_r_bits(k_bits, m)) == drop(m, k_bits) &*&
        true == forall(take(m, gen_r_bits(k_bits, m)), (eq)(false));

#endif //_MOD_POW2_GH_INCLUDED_
