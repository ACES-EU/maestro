#ifndef DIR248_GH
#define DIR248_GH

#include <bitops.gh>
#include "stdex.gh"

inductive lpm_rule = rule(Z, int, int); //ipv4, prefixlen, route
inductive dir_24_8 = tables(list<option<pair<bool, Z> > >, list<option<Z> >, int); //last is for tbl_long_index


fixpoint Z Z_of_int(int x, nat length){
  return Z_of_bits(Zsign(false), snd(bits_of_int(x, length)));
}

fixpoint lpm_rule init_rule(int ipv4, int prefixlen, int route){
  return rule(Z_of_int(ipv4, N32), prefixlen, route);
}

fixpoint int rule_ipv4(lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return int_of_Z(ipv4);
  }
}

fixpoint int rule_prefixlen(lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return prefixlen;
  }
}

fixpoint int rule_route(lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return route;
  }
}

fixpoint Z value_mask(){
  return Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zsign(false), false), true), true), true), true), true), true), true);
}
	
fixpoint int rule_24_get_value(Z entry){
  return int_of_Z(Z_and(entry, value_mask()));
}

fixpoint Z two_bytes_mask(){
  return Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zsign(false), true), true), true), true), true), true), true), true);
}
	
// INDEX COMPUTING FUNCTIONS
fixpoint int index24_from_ipv4(Z ipv4){
  return int_of_Z(Z_shiftright(ipv4, nat_of_int(8)));
}

fixpoint int indexlong_from_ipv4(Z ipv4, int index){
  return index * 256 + int_of_Z(Z_and(ipv4, two_bytes_mask()));
}

//Assuming that prefixlen <= 32
fixpoint int compute_rule_size(int prefixlen){
  return prefixlen < 24 ? pow_nat(2, nat_of_int(24 - prefixlen)) : pow_nat(2, nat_of_int(32 - prefixlen));
}

fixpoint Z mask_rec(int mask_length, nat total_length){
  switch(total_length){
    case zero: return Zsign(false);
    case succ(n): return int_of_nat(total_length) == mask_length ? Zdigit(mask_rec(mask_length-1, n), true) : Zdigit(mask_rec(mask_length, n), false);
  }
}
	
fixpoint Z mask32_from_prefixlen(int prefixlen){
  return mask_rec(prefixlen, N32);
}


fixpoint int compute_starting_index_24(lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return int_of_Z(Z_and(ipv4, mask32_from_prefixlen(prefixlen)));
  }
}
	
fixpoint int compute_starting_index_long(lpm_rule rule, int base_index){
  switch(rule){
    case rule(ipv4, prefixlen, value): return base_index * 256 + int_of_Z(Z_and(ipv4, mask32_from_prefixlen(prefixlen))) & 0xFF;
  }
}
	
fixpoint bool is_new_index_needed(option<pair<bool, Z> > entry){
  switch(entry){
    case none: return true;
    case some(p): return
      switch(p){
        case pair(f,v): return !f;
      };
    }
}

fixpoint int extract24_value(option<pair<bool, Z> > entry){
  switch(entry){
    case none: return 0;
    case some(p): return 
      switch(p){
        case pair(f, v): return int_of_Z(v);
      };
  }
}

//Entry is on 16 bits
fixpoint bool extract_flag(int entry){
  return (entry >> 15) == 1;
}

fixpoint int set_flag(int entry){
  return int_of_Z(Z_or(Z_of_int(entry, N16), Z_of_int(0x8000, N16)));
}

//The output value does not contain the flag
fixpoint int extract_value(int entry){
  return entry & 0x7FFF;
}
	
// LOOKUP FUNCTIONS
fixpoint option<pair<bool, Z> > lookup_tbl_24(int index, dir_24_8 dir){
  switch(dir){
    case(tables(tbl_24, tbl_long, long_index)): return nth(index, tbl_24);
  }
}

fixpoint option<Z> lookup_tbl_long(int index, dir_24_8 dir){
  switch(dir){
    case(tables(tbl_24, tbl_long, long_index)): return nth(index, tbl_long);
  }
}

fixpoint int lpm_dir_24_8_lookup(Z ipv4, dir_24_8 dir){
  switch(dir){
    case tables(tbl_24, tbl_long, index_long): return
      switch(lookup_tbl_24(index24_from_ipv4(ipv4), dir)){
        case none: return 0;
        case some(p): return
          switch(p){
            case pair(f, v): return
              f ?
                switch(lookup_tbl_long(indexlong_from_ipv4(ipv4, index_long), dir)){
                  case none: return 0;
                  case some(vl): return int_of_Z(vl);
                }
              :
                int_of_Z(v);
          };
      };
  }
}

// ADD ROUTE FUNCTIONS
fixpoint list<option<pair<bool, Z> > > update_n_tbl_24(list<option<pair<bool, Z> > > tbl_24, int start, int count, Z value, bool is_long_index){
  switch(tbl_24){
    case nil: return nil;
    case cons(v, cs0): return 
      start == 0 ? 
        count == 0 ? 
          cons(v, cs0)
        :
          is_long_index ? 
            cons(some(pair(true, value)), update_n_tbl_24(cs0, 0, count-1, value, is_long_index))
          :
            cons(some(pair(false, value)), update_n_tbl_24(cs0, 0, count-1, value, is_long_index))
      :
        update_n_tbl_24(cs0, start-1, count, value, is_long_index);		
  }
}
	
fixpoint list<option<Z> > update_n_tbl_long(list<option<Z> > tbl_long, int start, int count, Z value){
  switch(tbl_long){
    case nil: return nil;
    case cons(v, cs0): return
      start == 0 ?
        count == 0 ?
          cons(v, cs0)
        :
          cons(some(value), update_n_tbl_long(cs0, 0, count-1, value))
      :
        update_n_tbl_long(cs0, start-1, count, value);
  }
}

fixpoint list<option<pair<bool, Z> > > insert_route_24(list<option<pair<bool, Z> > > tbl_24, lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return update_n_tbl_24(tbl_24, compute_starting_index_24(rule), compute_rule_size(prefixlen), Z_of_int(route, N16), false);
  }
}
	
fixpoint list<option<Z> > insert_route_long(list<option<Z> > tbl_long, lpm_rule rule, int base_index){
  switch(rule){
    case rule(ipv4, prefixlen, route): return update_n_tbl_long(tbl_long, compute_starting_index_long(rule, base_index), compute_rule_size(prefixlen), Z_of_int(route, N16));
  }
}

fixpoint dir_24_8 insert_tbl_24(dir_24_8 dir, lpm_rule rule){
  switch(dir){
    case tables(tbl_24, tbl_long, long_index): return tables(insert_route_24(tbl_24, rule), tbl_long, long_index);
  }
}

fixpoint dir_24_8 insert_tbl_long(dir_24_8 dir, lpm_rule rule){
  switch(dir){
    case tables(tbl_24, tbl_long, long_index): return
      switch(rule){
        case rule(ipv4, prefixlen, route): return
          //Check whether a new index_long is needed 
          is_new_index_needed(lookup_tbl_24(index24_from_ipv4(ipv4), dir)) ? 
            //Check for available index, if not -> no change
            long_index == 256 ?
              tables(tbl_24, tbl_long, long_index)
            :
              //Update the value in tbl_24 and tbl_long
              tables(update_n_tbl_24(tbl_24, compute_starting_index_24(rule), 1, Z_of_int(long_index, N8()), true), insert_route_long(tbl_long, rule, long_index), long_index + 1)
          :
            //No need to update the value in tbl_24, only in tlb_long
            tables(tbl_24, insert_route_long(tbl_long, rule, extract24_value(lookup_tbl_24(index24_from_ipv4(ipv4), dir))), long_index);		
      };		
  }	
}

fixpoint dir_24_8 add_rule(dir_24_8 dir, lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return prefixlen < 24 ? insert_tbl_24(dir, rule) : insert_tbl_long(dir, rule);
  }
}

// STRUCTURE BUILDING FUNCTIONS

//If beginning with 1: valid is between 0 and 255 (0xFF)
//If beginning with 0: valid is between 0 and 0x7FFF
//INVALID is 0xFFFF (no route set yet)
fixpoint bool is_entry24_valid(int entry){
  return entry == 0xFFFF ? false : (extract_flag(entry) ? (0 <= entry && entry <= 0xFF) : (0 <= entry && entry <= 0x7FFF));
}

fixpoint option<pair<bool, Z> > entry_24_mapping(int entry){
  return entry == 0xFFFF ? none : some(pair(extract_flag(entry), Z_of_int(extract_value(entry), N16)));
}

fixpoint option<Z> entry_long_mapping(int entry){
  return entry == 0xFFFF ? none : some(Z_of_int(entry, N16));
}

fixpoint dir_24_8 build_tables(list<int> t_24, list<int> t_long, int long_index){
  return tables(map(entry_24_mapping, t_24), map(entry_long_mapping, t_long), long_index);
}

fixpoint dir_24_8 dir_init(){
  return tables(repeat_n(nat_of_int(16777216), entry_24_mapping(0xFFFF)), repeat_n(nat_of_int(65536), entry_long_mapping(0xFFFF)), 0);
}


// Those function must be called only when the option is known not to be none
fixpoint pair<bool, Z> get_someOption24(option<pair<bool, Z> > o){
  switch(o){
    case none: return pair(false, Zsign(false));//should never happen
    case some(p): return p;
  }
}

fixpoint int get_someOptionLong(option<int> o){
  switch(o){
    case none: return -1;//should never happen
    case some(v): return v;
  }
}
