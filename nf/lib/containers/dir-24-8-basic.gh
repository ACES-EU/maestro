#ifndef DIR248_GH
#define DIR248_GH

#include <bitops.gh>

inductive lpm_rule = rule(Z, int, int); //ipv4, prefixlen, route
inductive dir_24_8 = tables(list<option<pair<bool, Z> > >, list<option<Z> >, int); //last is for tbl_long_index

fixpoint lpm_rule init_rule(Z ipv4, int prefixlen, int route){
  return rule(ipv4, prefixlen, route);
}

fixpoint int rule_ipv4(lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return int_of_Z(ipv4);
  }
}

fixpoint int rule_prefixlen(lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return prefixlen;
  }
}

fixpoint int rule_route(lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return route;
  }
}

fixpoint Z value_mask(){
  return Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zsign(false), false), true), true), true), true), true), true), true);
}
	
fixpoint int rule_24_get_value(Z entry){
  return int_of_Z(Z_and(entry, value_mask()));
}

fixpoint Z two_bytes_mask(){
  return Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zsign(false), true), true), true), true), true), true), true), true);
}

fixpoint Z Z_of_int(int x){
  //Still have to find a good way to generate Z, maybe using bitops.gh lemmas?
  return Zsign(false);
}
	
// INDEX COMPUTING FUNCTIONS
fixpoint int index24_from_ipv4(Z ipv4){
  return int_of_Z(Z_shiftright(ipv4, nat_of_int(8)));
}

fixpoint int indexlong_from_ipv4(Z ipv4, int index){
  return index * 256 + int_of_Z(Z_and(ipv4, two_bytes_mask()));
}

//Assuming that prefixlen <= 32
fixpoint int compute_rule_size(int prefixlen){
  return prefixlen < 24 ? pow_nat(2, nat_of_int(24 - prefixlen)) : pow_nat(2, nat_of_int(32 - prefixlen));
}

fixpoint Z mask_rec(int mask_length, nat total_length){
  switch(total_length){
    case zero: return Zsign(false);
    case succ(n): return int_of_nat(total_length) == mask_length ? Zdigit(mask_rec(mask_length-1, n), true) : Zdigit(mask_rec(mask_length, n), false);
  }
}
	
fixpoint Z mask32_from_prefixlen(int prefixlen){
  return mask_rec(prefixlen, N32());
}


fixpoint int compute_starting_index_24(lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return int_of_Z(Z_and(ipv4, mask32_from_prefixlen(prefixlen)));
  }
}
	
fixpoint int compute_starting_index_long(lpm_rule rule, int base_index){
  switch(rule){
    case rule(ipv4, prefixlen, value): return base_index * 256 + int_of_Z(Z_and(ipv4, mask32_from_prefixlen(prefixlen))) & 0xFF;
  }
}
	
fixpoint bool is_new_index_needed(option<pair<bool, Z> > entry){
  switch(entry){
    case none: return true;
    case some(p): return
      switch(p){
        case pair(f,v): return !f;
      };
    }
}

fixpoint int extract24_value(option<pair<bool, Z> > entry){
  switch(entry){
    case none: return 0;
    case some(p): return 
      switch(p){
        case pair(f, v): return int_of_Z(v);
      };
  }
}
	
// LOOKUP FUNCTIONS
fixpoint option<pair<bool, Z> > lookup_tbl_24(int index, dir_24_8 dir){
  switch(dir){
    case(tables(tbl_24, tbl_long, long_index)): return nth(index, tbl_24);
  }
}

fixpoint option<Z> lookup_tbl_long(int index, dir_24_8 dir){
  switch(dir){
    case(tables(tbl_24, tbl_long, long_index)): return nth(index, tbl_long);
  }
}

fixpoint int lpm_dir_24_8_lookup(Z ipv4, dir_24_8 dir){
  switch(dir){
    case tables(tbl_24, tbl_long, index_long): return
      switch(lookup_tbl_24(index24_from_ipv4(ipv4), dir)){
        case none: return 0;
        case some(p): return
          switch(p){
            case pair(f, v): return
              f ?
                switch(lookup_tbl_long(indexlong_from_ipv4(ipv4, index_long), dir)){
                  case none: return 0;
                  case some(vl): return int_of_Z(vl);
                }
              :
                int_of_Z(v);
          };
      };
  }
}

// ADD ROUTE FUNCTIONS
fixpoint list<option<pair<bool, Z> > > update_n_tbl_24(list<option<pair<bool, Z> > > tbl_24, int start, int count, Z value, bool is_long_index){
  switch(tbl_24){
    case nil: return nil;
    case cons(v, cs0): return 
      start == 0 ? 
        count == 0 ? 
          cons(v, cs0)
        :
          is_long_index ? 
            cons(some(pair(true, value)), update_n_tbl_24(cs0, 0, count-1, value, is_long_index))
          :
            cons(some(pair(false, value)), update_n_tbl_24(cs0, 0, count-1, value, is_long_index))
      :
        update_n_tbl_24(cs0, start-1, count, value, is_long_index);		
  }
}
	
fixpoint list<option<Z> > update_n_tbl_long(list<option<Z> > tbl_long, int start, int count, Z value){
  switch(tbl_long){
    case nil: return nil;
    case cons(v, cs0): return
      start == 0 ?
        count == 0 ?
          cons(v, cs0)
        :
          cons(some(value), update_n_tbl_long(cs0, 0, count-1, value))
      :
        update_n_tbl_long(cs0, start-1, count, value);
  }
}

fixpoint list<option<pair<bool, Z> > > insert_route_24(list<option<pair<bool, Z> > > tbl_24, lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return update_n_tbl_24(tbl_24, compute_starting_index_24(rule), compute_rule_size(prefixlen), Z_of_int(route), false);
  }
}
	
fixpoint list<option<Z> > insert_route_long(list<option<Z> > tbl_long, lpm_rule rule, int base_index){
  switch(rule){
    case rule(ipv4, prefixlen, route): return update_n_tbl_long(tbl_long, compute_starting_index_long(rule, base_index), compute_rule_size(prefixlen), Z_of_int(route));
  }
}

fixpoint dir_24_8 insert_tbl_24(dir_24_8 dir, lpm_rule rule){
  switch(dir){
    case tables(tbl_24, tbl_long, long_index): return tables(insert_route_24(tbl_24, rule), tbl_long, long_index);
  }
}

fixpoint dir_24_8 insert_tbl_long(dir_24_8 dir, lpm_rule rule){
  switch(dir){
    case tables(tbl_24, tbl_long, long_index): return
      switch(rule){
        case rule(ipv4, prefixlen, route): return
          //Check whether a new index_long is needed 
          is_new_index_needed(lookup_tbl_24(index24_from_ipv4(ipv4), dir)) ? 
            //Check for available index, if not -> no change
            long_index == 256 ?
              tables(tbl_24, tbl_long, long_index)
            :
              //Update the value in tbl_24 and tbl_long
              tables(update_n_tbl_24(tbl_24, compute_starting_index_24(rule), 1, Z_of_int(long_index), true), insert_route_long(tbl_long, rule, long_index), long_index + 1)
          :
            //No need to update the value in tbl_24, only in tlb_long
            tables(tbl_24, insert_route_long(tbl_long, rule, extract24_value(lookup_tbl_24(index24_from_ipv4(ipv4), dir))), long_index);		
      };		
  }	
}

fixpoint dir_24_8 add_rule(dir_24_8 dir, lpm_rule rule){
  switch(rule){
    case rule(ipv4, prefixlen, route): return prefixlen < 24 ? insert_tbl_24(dir, rule) : insert_tbl_long(dir, rule);
  }
}
