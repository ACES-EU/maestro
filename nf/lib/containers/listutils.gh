#ifndef _LISTUTILS_GH_INCLUDED_
#define _LISTUTILS_GH_INCLUDED_

#include <nat.gh>
#include "stdex.gh"
#include "arith.gh"

fixpoint bool eq<t>(t x, t y) {
    return x == y;
}

fixpoint list<t> flatten<t>(list< list<t> > xs) {
    switch(xs) {
        case nil: return nil;
        case cons(x0, xs0): return append(x0, flatten(xs0));
    }
}

lemma void flatten_allnil<t>(list< list<t> > xs)
    requires    true == forall(xs, (eq)(nil));
    ensures     flatten(xs) == nil;
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): flatten_allnil(xs0);
    }
}

fixpoint list<t> list_append<t>(list<t> xs, t x_tail) {
    switch(xs) {
        case nil: return cons(x_tail, nil);
        case cons(x0, xs0): return cons(x0, list_append(xs0, x_tail));
    }
}

fixpoint list<t> chunk<t>(list<t> xs, int begin, int end) {
    return take(end - begin, drop(begin, xs));
}

lemma void chunk_shift<t>(list<t> xs, int begin, int end, int n)
    requires    0 <= begin &*& 0 <= n &*& n <= begin &*& begin + n <= length(xs);
    ensures     chunk(xs, begin, end) == chunk(drop(n, xs), begin - n, end - n);
{
    drop_drop(begin - n, n, xs);
}

//assume (chunk(xs, n * j, n * j + &) == chunk(drop(n,xs),n*(j-1),n*(j-1) + a));

fixpoint list<t> repeat<t>(t elem, nat n) {
    switch(n) {
        case zero: return nil;
        case succ(n_pred): return cons(elem, repeat(elem, n_pred));
    }
}

lemma_auto(length(repeat(elem, n))) void length_repeat<t>(t elem, nat n)
    requires    true;
    ensures     length(repeat(elem, n)) == int_of_nat(n);
{
    switch(n) {
        case zero:
        case succ(n_pred): length_repeat(elem, n_pred);
    }
}

lemma void repeat_content<t>(t elem, nat n)
    requires    true;
    ensures     true == forall(repeat(elem, n), (eq)(elem));
{
    switch(n) {
        case zero:
        case succ(n_pred): repeat_content(elem, n_pred);
    }
}

lemma void repeat_add<t>(t elem, nat n)
    requires    n == succ(?n_pred);
    ensures     cons(elem, repeat(elem, n_pred)) == repeat(elem, n);
{
    switch(n) {
        case zero:
        case succ(n_pred_bis): 
    }
}

lemma void repeat_nth<t>(t elem, nat n, int i) 
    requires    0 <= i &*& i < int_of_nat(n);
    ensures     nth(i, repeat(elem, n)) == elem;
{
    repeat_content(elem, n);
    forall_nth(repeat(elem, n), (eq)(elem), i);
}

lemma void repeat_tail<t>(t elem, nat n)
    requires    n == succ(?n_pred);
    ensures     tail(repeat(elem, n)) == repeat(elem, n_pred);
{}

fixpoint list<int> gen_limits(nat nb_split, int i, int j) {
    switch(nb_split) {
        case zero: return nil;
        case succ(nb_split_pred): 
            return (j > 0)
                ? cons(i + 1, gen_limits(nb_split_pred, i, j - 1))
                : cons(i, gen_limits(nb_split_pred, i, j - 1));
    }
}

lemma_auto(length(gen_limits(nb_split, i, j))) void length_gen_limits(nat nb_split, int i, int j)
    requires    true;
    ensures     length(gen_limits(nb_split, i, j)) == int_of_nat(nb_split);
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred): length_gen_limits(nb_split_pred, i, j - 1);
    }
}

lemma void gen_limits_allzero(nat nb_split, int i, int j)
    requires    j <= 0;
    ensures     true == forall(gen_limits(nb_split, i, j), (eq)(i));
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred): gen_limits_allzero(nb_split_pred, i, j - 1);
    }
}

lemma void gen_limits_increment_j(nat nb_split, int i, int j)
    requires    0 < j &*& j < int_of_nat(nb_split);
    ensures     gen_limits(nb_split, i, j + 1) == update(j, nth(j, gen_limits(nb_split, i, j + 1)), gen_limits(nb_split, i, j));
{
    assume (gen_limits(nb_split, i, j + 1) == update(j, nth(j, gen_limits(nb_split, i, j + 1)), gen_limits(nb_split, i, j)));
}

fixpoint list< list<t> > split_varlim<t>(list<t> xs, int n, list<int> limits) {
    switch(limits) {
        case nil: return nil;
        case cons(l0, ls0): return cons(take(l0, xs), split_varlim(drop(n, xs), n, ls0));
    }
}

lemma void mul_equal(int a, int b, int c)
    requires    a * b == c &*& a >= 0 &*& b > 0 &*& c >= 0;
    ensures     a <= c;
{
    assume (a <= c);//TODO
}

lemma void split_varlim_nolim<t>(list<t> xs, int n, list<int> limits)
    requires    
        true == forall(limits, (eq)(0)) &*&
        0 <= n &*& n * length(limits) == length(xs);
    ensures
        true == forall(split_varlim(xs, n, limits), (eq)(nil));
{
    switch(limits) {
        case nil:
            assert (length(xs) == 0);
        case cons(l0, ls0):            
            mul_equal(n, length(limits), length(xs));
            length_drop(n, xs);
            assert (length(ls0) == length(limits) - 1); 
            mul_subst (length(ls0), length(limits) - 1, n);
            split_varlim_nolim(drop(n, xs), n, ls0);
    }
}

lemma void split_varlim_chunk_equiv<t>(list<t> xs, int n, list<int> limits, int j)
    requires    0 <= n &*& 0 <= j &*& j < length(limits) &*& n * (j+1) <= length(xs) ;
    ensures     nth(j, split_varlim(xs, n, limits)) == chunk(xs, n * j, n * j + nth(j, limits));
{
    switch(limits) {
        case nil: 
        case cons(l0, ls0):
            if (j == 0) {
                assert (chunk(xs, 0, l0) == take(l0, xs));
            } else {
                split_varlim_chunk_equiv(drop(n, xs), n, ls0, j - 1);
                assert (nth(j, split_varlim(xs, n, limits)) == nth(j-1, split_varlim(drop(n,xs),n,ls0)));
                assert (nth(j, limits) == nth(j-1,ls0));

                mul_nonnegative(n, j);
                mul_bounds(1, j, n, n);
                chunk_shift(xs, n * j, n * j + nth(j, limits), n);
            }
    }
}

fixpoint list< list<t> > split<t>(list<t> xs, nat nb_split, int n) {
    switch(nb_split) {
        case zero: return nil;
        case succ(nb_split_pred): 
            return cons(take(n, xs), split(drop(n, xs), nb_split_pred, n));
    }
}

lemma void split_to_source<t>(list<t> xs, nat nb_split, int n, int i, int j)
    requires    length(xs) == int_of_nat(nb_split) * n &*&
                0 <= i &*& i < n &*&
                0 <= j &*& j < int_of_nat(nb_split);
    ensures     nth(i, nth(j, split(xs, nb_split, n))) == nth(j * n + i, xs);
{
    assume (nth(i, nth(j, split(xs, nb_split, n))) == nth(j * n + i, xs));
}

lemma_auto(length(split(xs, nb_split, n))) void length_split<t>(list<t> xs, nat nb_split, int n)
    requires    length(xs) == int_of_nat(nb_split) * n;
    ensures     length(split(xs, nb_split, n)) == int_of_nat(nb_split);
{
    assume (length(split(xs, nb_split, n)) == int_of_nat(nb_split));
}

lemma void length_split_forall<t>(list<t> xs, nat nb_split, int n, int i)
    requires    length(xs) == int_of_nat(nb_split) * n &*& 0 <= i &*& i < length(xs);
    ensures     length(nth(i, split(xs, nb_split, n))) == n;
{
    assume (length(nth(i, split(xs, nb_split, n))) == n);
}

fixpoint list< pair<int, t> > zip_with_index_recursive<t>(list<t> xs, int index) {
    switch(xs) {
        case nil: return nil;
        case cons(x0, xs0): return cons( pair(index, x0), zip_with_index_recursive(xs0, index + 1) );
    }
}

fixpoint list< pair<int, t> > zip_with_index<t>(list<t> xs) {
    return zip_with_index_recursive(xs, 0);
}

fixpoint list< pair<t1, t2> > zip<t1, t2>(list<t1> xs, list<t2> ys) {
    switch(xs) {
        case nil: return nil;
        case cons(x0, xs0): return cons( pair(x0, head(ys)) , zip(xs0, tail(ys)) );
    }
}

fixpoint list<int> integers_list_rec(nat cnt, int index) {
    switch(cnt) {
        case zero: return nil;
        case succ(cnt_pred): return cons(index, integers_list_rec(cnt_pred, index + 1));
    }
}

fixpoint list<int> integers_list(int n, int start) {
    return integers_list_rec(nat_of_int(n), start);
}

lemma void take_full<t>(list<t> xs)
    requires    true;
    ensures     take(length(xs), xs) == xs;
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): take_full(xs0);
    }
}

lemma void ints_to_nth(list<int> xs, list<int> xs_orig, int i, int val)
    requires    xs == update(i, val, xs_orig);
    ensures     nth(i, xs) == val;
{
    assume (nth(i, xs) == val);
    // TODO
}

lemma void append_take<t>(list<t> xs, int i, fixpoint (t,bool) f)
    requires 
        0 <= i &*& i < length(xs) &*&
        true == forall(take(i, xs), f) &*& true == f(nth(i, xs));
    ensures 
        true == forall(take(i + 1, xs), f);
{
    assume (true == forall(take(i + 1, xs), f));
    // TODO
}

lemma void unzip<t>(list<t> xs)
    requires    true;
    ensures     xs == map(snd, zip_with_index(xs));
{
    assume (xs == map(snd, zip_with_index(xs)));
    // TODO
}

lemma void isolate_chunk_length<t>(list<t> xs, int begin, int end)
    requires    0 <= begin &*& begin <= end &*& end <= length(xs);
    ensures     length(chunk(xs, begin, end)) == end - begin;
{
    length_take(begin, xs);
    length_drop(end - begin, drop(begin, xs));
}

lemma void append_length<t>(list<t> xs, t x)
    requires    true;
    ensures     length(list_append(xs, x)) == length(xs) + 1;
{
    switch(xs) {
        case nil: 
        case cons(x0, xs0): append_length(xs0, x);
    }
}

lemma void append_preserves_fixpoint<t>(list<t> xs, t x, fixpoint (t,bool) f)
    requires 
        true == forall(xs, (f)) &*&
        true == f(x);
    ensures
        true == forall(list_append(xs, x), (f));
{
    switch(xs) {
        case nil:
            assert (list_append(xs, x) == cons(x, nil));
            assert (true == f(x));
        case cons(x0, xs0):
            append_preserves_fixpoint(xs0, x, f);
    }
}

lemma void append_preserves_bounds(list<int> xs, int x, int low_bound, int up_bound)
    requires
        true == forall(xs, (lt)(up_bound)) &*&
        true == forall(xs, (ge)(low_bound)) &*&
        low_bound <= x &*& x < up_bound;
    ensures
        true == forall(list_append(xs, x), (lt)(up_bound)) &*&
        true == forall(list_append(xs, x), (ge)(low_bound));
{
    switch(xs) {
        case nil:
            assert (list_append(xs, x) == cons(x, nil));
            assert (low_bound <= x && x < up_bound);
        case cons(x0, xs0):
            assert (low_bound <= x0 && x0 < up_bound);
            append_preserves_bounds(xs0, x, low_bound, up_bound);
    }
}

lemma void append_to_zip<t>(list<t> xs, t x) 
    requires true;
    ensures list_append(zip_with_index(xs), pair(length(xs),x)) == zip_with_index(list_append(xs, x));
{
    switch(xs) {
        case nil:
            assert (list_append(xs, x) == cons(x, nil));
            list<t> l = list_append(xs, x);
            assert (zip_with_index(l) == cons(pair(0, x), nil) );
            
            list< pair<int, t> > z = zip_with_index(xs);
            assert (list_append(z, pair(0, x)) == cons( pair(0, x), nil));

        case cons(x0, xs0):
            assume (list_append(zip_with_index(xs), pair(length(xs),x)) == zip_with_index(list_append(xs, x)));
            //TODO
    }
} 

lemma void zip_with_index_bounds<t>(list<t> xs) 
    requires true;
    ensures 
        true == forall( map(fst, zip_with_index(xs)), (lt)(length(xs)) ) &*&
        true == forall( map(fst, zip_with_index(xs)), (ge)(0) );
{
    assume ( true == forall( map(fst, zip_with_index(xs)), (lt)(length(xs)) ));
    assume ( true == forall( map(fst, zip_with_index(xs)), (ge)(0) ));
    //TODO
}

lemma void zip_no_dups_helper<t>(list<t> xs, int index)
    requires true;
    ensures xs == nil ? true : fst(head(zip_with_index_recursive(xs, index))) == index;
{
    switch(xs) {
        case nil: true;
        case cons(x0, xs0): assert(fst(head(zip_with_index_recursive(xs, index))) == index);
    }
}

lemma void zip_no_dups_rec<t>(list< pair<int, t> > xs_ziped, list<t> xs, int index)
    requires xs_ziped == zip_with_index_recursive(xs, index);
    ensures true == no_dups(map(fst, xs_ziped));
{
    assume (true == no_dups(map(fst, xs_ziped))); //TODO
}

lemma void zip_no_dups<t>(list<t> xs)
    requires true;
    ensures true == no_dups(map(fst, zip_with_index(xs)));
{
    list< pair<int, t> > xs_ziped = zip_with_index_recursive(xs, 0);
    zip_no_dups_rec(xs_ziped, xs, 0);
}

lemma void chunk_zerosize<t>(list<t> xs, int n)
    requires true;
    ensures chunk(xs, n, n) == nil;
{
    list<t> drop_xs = drop(n, xs);
    take_0(drop_xs);
}

#endif //_LISTUTILS_GH_INCLUDED_
