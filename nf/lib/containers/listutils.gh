#ifndef _LISTUTILS_GH_INCLUDED_
#define _LISTUTILS_GH_INCLUDED_

#include <nat.gh>
#include "stdex.gh"
#include "arith.gh"

// ------------- index_of_fixpoint -------------

fixpoint option<int> index_of_fp<t>(list<t> xs, int idx, fixpoint (t,bool) fp) {
    switch(xs) {
        case nil: return none;
        case cons(x0, xs0): return fp(x0) ? some(idx) : index_of_fp(xs0, idx + 1, fp);
    }
}

fixpoint t unpack_option_default<t>(option<t> opt, t default_value) {
    switch(opt) {
        case none: return default_value;
        case some(value): return value;
    }
}

lemma void index_of_fp_exists<t>(list<t> xs, int idx, fixpoint (t,bool) fp, int i)
    requires    true == forall(take(i, xs), (sup)((eq)(false), fp)) &*& true == fp(nth(i, xs));
    ensures     index_of_fp(xs, idx, fp) == some(idx + i);
{
    assume (index_of_fp(xs, idx, fp) == some(idx + i));
}


// ------------- integer_copies -------------

fixpoint bool integer_copies(nat val, int nb_copies, list<int> xs) {
    switch(val) {
        case zero: return count(xs, (eq)(int_of_nat(val))) == nb_copies;
        case succ(val_pred): return count(xs, (eq)(int_of_nat(val))) == nb_copies && integer_copies(val_pred, nb_copies, xs);
    }
}

lemma_auto(integer_copies(val, nb_copies, nil)) void integer_copies_nil(nat val, int nb_copies)
    requires    0 == nb_copies;
    ensures     true == integer_copies(val, nb_copies, nil);
{
    switch(val) {
        case zero:
        case succ(val_pred): integer_copies_nil(val_pred, nb_copies);
    }
}

lemma void integer_copies_val(int x, nat val, int nb_copies, list<int> xs)
    requires    true == integer_copies(val, nb_copies, xs) &*& 0 <= x &*& x <= int_of_nat(val);
    ensures     count(xs, (eq)(x)) == nb_copies;
{
    switch(val) {
        case zero:
        case succ(val_pred):
            if (int_of_nat(val) != x) {
                integer_copies_val(x, val_pred, nb_copies, xs);
            }
    }
}

lemma void integer_copies_append(list<int> xs, list<int> ys, int xs_count, int ys_count, nat val)
    requires
        true == integer_copies(val, xs_count, xs) &*& 
        true == integer_copies(val, ys_count, ys);
    ensures
        true == integer_copies(val, xs_count + ys_count, append(xs, ys));
{
    assume (true == integer_copies(val, xs_count + ys_count, append(xs, ys)));
}

// ------------- sub_integer_copies -------------

fixpoint bool sub_integer_copies(nat val, int nb_copies, list<int> xs) {
    switch(val) {
        case zero: return count(xs, (eq)(int_of_nat(val))) <= nb_copies;
        case succ(val_pred): return count(xs, (eq)(int_of_nat(val))) <= nb_copies && sub_integer_copies(val_pred, nb_copies, xs);
    }
}

lemma_auto(sub_integer_copies(val, nb_copies, nil)) void sub_integer_copies_nil(nat val, int nb_copies)
    requires    0 <= nb_copies;
    ensures     true == sub_integer_copies(val, nb_copies, nil);
{
    switch(val) {
        case zero:
        case succ(val_pred): sub_integer_copies_nil(val_pred, nb_copies);
    }
}

lemma void sub_integer_copies_val(int x, nat val, int nb_copies, list<int> xs)
    requires    true == sub_integer_copies(val, nb_copies, xs) &*& 0 <= x &*& x <= int_of_nat(val);
    ensures     count(xs, (eq)(x)) <= nb_copies;
{
    switch(val) {
        case zero:
        case succ(val_pred):
            if (int_of_nat(val) != x) {
                sub_integer_copies_val(x, val_pred, nb_copies, xs);
            }
    }
}

lemma void sub_integer_copies_append(list<int> xs, list<int> ys, int xs_count, int ys_count, nat val)
    requires
        true == sub_integer_copies(val, xs_count, xs) &*& 
        true == sub_integer_copies(val, ys_count, ys);
    ensures
        true == sub_integer_copies(val, xs_count + ys_count, append(xs, ys));
{
    assume (true == sub_integer_copies(val, xs_count + ys_count, append(xs, ys)));
}

// ------------- flatten -------------

fixpoint list<t> flatten<t>(list< list<t> > xs) {
    switch(xs) {
        case nil: return nil;
        case cons(x0, xs0): return append(x0, flatten(xs0));
    }
}

lemma void flatten_allnil<t>(list< list<t> > xs)
    requires    true == forall(xs, (eq)(nil));
    ensures     flatten(xs) == nil;
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): flatten_allnil(xs0);
    }
}

lemma void flatten_count(list< list<int> > xs, nat val)
    requires    true == forall(xs, (integer_copies)(val, 1));
    ensures     true == integer_copies(val, length(xs), flatten(xs));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): 
            flatten_count(xs0, val);
            forall_nth(xs, (integer_copies)(val, 1), 0);
            integer_copies_append(x0, flatten(xs0), 1, length(xs0), val);
    }
}

lemma void flatten_subcount(list< list<int> > xs, nat val)
    requires    true == forall(xs, (sub_integer_copies)(val, 1));
    ensures     true == sub_integer_copies(val, length(xs), flatten(xs));
{
    switch(xs) {
        case nil:
        case cons(x0, xs0): 
            flatten_subcount(xs0, val);
            forall_nth(xs, (sub_integer_copies)(val, 1), 0);
            sub_integer_copies_append(x0, flatten(xs0), 1, length(xs0), val);
    }
}

lemma void flatten_subcount_special(list< list<int> > xs, nat val, int i, int special_val)
    requires    true == forall(xs, (sub_integer_copies)(val, 1)) &*& count(nth(i, xs), (eq)(special_val)) == 0;
    ensures     count(flatten(xs), (eq)(special_val)) < length(xs);
{
    assume (count(flatten(xs), (eq)(special_val)) < length(xs));
}

lemma void flatten_subcount_update_relevant(list< list<int> > xs, list< list<int> > ys, nat val, int i, int special_val)
    requires    
        true == forall(xs, (sub_integer_copies)(val, 1)) &*& count(nth(i, xs), (eq)(special_val)) == 0 &*&
        true == forall(ys, (sub_integer_copies)(val, 1)) &*& count(nth(i, ys), (eq)(special_val)) == 1 &*&
        ys == update(i, nth(i, ys), xs) &*&
        0 <= i &*& i < length(xs);
    ensures     
        count(flatten(ys), (eq)(special_val)) == count(flatten(xs), (eq)(special_val)) + 1;
{
    assume (count(flatten(ys), (eq)(special_val)) == count(flatten(xs), (eq)(special_val)) + 1);
}

lemma void flatten_subcount_update_unrelevant(list< list<int> > xs, list< list<int> > ys, nat val, int i, int special_val, int count)
    requires    
        true == forall(xs, (sub_integer_copies)(val, 1)) &*& count(nth(i, xs), (eq)(special_val)) == count &*&
        true == forall(ys, (sub_integer_copies)(val, 1)) &*& count(nth(i, ys), (eq)(special_val)) == count &*&
        ys == update(i, nth(i, ys), xs) &*&
        0 <= i &*& i < length(xs);
    ensures     
        count(flatten(ys), (eq)(special_val)) == count(flatten(xs), (eq)(special_val));
{
    assume (count(flatten(ys), (eq)(special_val)) == count(flatten(xs), (eq)(special_val)));
}

// ------------- chunk -------------

fixpoint list<t> chunk<t>(list<t> xs, int begin, int end) {
    return take(end - begin, drop(begin, xs));
}

lemma void chunk_zerosize<t>(list<t> xs, int n)
    requires true;
    ensures chunk(xs, n, n) == nil;
{
    list<t> drop_xs = drop(n, xs);
    take_0(drop_xs);
}

lemma void chunk_length<t>(list<t> xs, int begin, int end)
    requires    0 <= begin &*& begin <= end &*& end <= length(xs);
    ensures     length(chunk(xs, begin, end)) == end - begin;
{
    length_drop(begin, xs);
    length_take(end - begin, drop(begin, xs));
}

lemma void chunk_shift<t>(list<t> xs, int begin, int end, int n)
    requires    0 <= begin &*& 0 <= n &*& n <= begin &*& begin + n <= length(xs);
    ensures     chunk(xs, begin, end) == chunk(drop(n, xs), begin - n, end - n);
{
    drop_drop(begin - n, n, xs);
}

lemma void chunk_append<t>(list<t> xs, int begin, int end)
    requires    0 <= begin &*& begin <= end &*& end <= length(xs);
    ensures     chunk(xs, begin, end + 1) == append(chunk(xs, begin, end), cons(nth(end, xs), nil));
{
    assume (chunk(xs, begin, end + 1) == append(chunk(xs, begin, end), cons(nth(end, xs), nil)));
}

lemma void chunk_take<t>(list<t> xs, int begin, int end1, int end2)
    requires    0 <= begin &*& begin <= end1 &*& end1 <= end2 &*& end2 <= length(xs);
    ensures     take(end1 - begin, chunk(xs, begin, end2)) == chunk(xs, begin, end1);
{
    list<t> drop_xs = drop(begin, xs);
    take_take(end1 - begin, end2 - begin, drop_xs);
}

lemma void chunk_to_source<t>(list<t> xs, int begin, int end, int i)
    requires    0 <= begin &*& begin <= end &*& end <= length(xs);
    ensures     nth(begin + i, xs) == nth(i, chunk(xs, begin, end));
{
    assume (nth(begin + i, xs) == nth(i, chunk(xs, begin, end)));
}

lemma void chunk_update_unrelevant<t>(list<t> xs, list<t> ys, int begin, int end, int i, t val)
    requires 
        0 <= begin &*& begin <= end &*& end <= i &*& i < length(xs) &*&
        ys == update(i, val, xs);
    ensures
        chunk(xs, begin, end) == chunk(update(i, val, xs), begin, end);
{
    // take(end - begin, drop(begin, xs))
    // take(end - begin, drop(begin, update(i, val, xs)))
    list<t> tmp = update(i - begin, val, drop(begin, xs));
    drop_update_relevant(begin, i, val, xs);
    take_update_unrelevant(end, i, val, drop(begin, xs));
    take_update_unrelevant(end, i, val, tmp);
    assume (chunk(xs, begin, end) == chunk(update(i, val, xs), begin, end));
}

// ------------- repeat -------------

fixpoint list<t> repeat<t>(t elem, nat n) {
    switch(n) {
        case zero: return nil;
        case succ(n_pred): return cons(elem, repeat(elem, n_pred));
    }
}

lemma_auto(length(repeat(elem, n))) void length_repeat<t>(t elem, nat n)
    requires    true;
    ensures     length(repeat(elem, n)) == int_of_nat(n);
{
    switch(n) {
        case zero:
        case succ(n_pred): length_repeat(elem, n_pred);
    }
}

lemma void repeat_content<t>(t elem, nat n)
    requires    true;
    ensures     true == forall(repeat(elem, n), (eq)(elem));
{
    switch(n) {
        case zero:
        case succ(n_pred): repeat_content(elem, n_pred);
    }
}

lemma void repeat_add<t>(t elem, nat n)
    requires    n == succ(?n_pred);
    ensures     cons(elem, repeat(elem, n_pred)) == repeat(elem, n);
{
    switch(n) {
        case zero:
        case succ(n_pred_bis): 
    }
}

lemma void repeat_nth<t>(t elem, nat n, int i) 
    requires    0 <= i &*& i < int_of_nat(n);
    ensures     nth(i, repeat(elem, n)) == elem;
{
    repeat_content(elem, n);
    forall_nth(repeat(elem, n), (eq)(elem), i);
}

lemma void repeat_tail<t>(t elem, nat n)
    requires    n == succ(?n_pred);
    ensures     tail(repeat(elem, n)) == repeat(elem, n_pred);
{}

// ------------- gen_limits -------------

fixpoint list<int> gen_limits(nat nb_split, int i, int j) {
    switch(nb_split) {
        case zero: return nil;
        case succ(nb_split_pred): 
            return (j > 0)
                ? cons(i + 1, gen_limits(nb_split_pred, i, j - 1))
                : cons(i, gen_limits(nb_split_pred, i, j - 1));
    }
}

lemma_auto(length(gen_limits(nb_split, i, j))) void length_gen_limits(nat nb_split, int i, int j)
    requires    true;
    ensures     length(gen_limits(nb_split, i, j)) == int_of_nat(nb_split);
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred): length_gen_limits(nb_split_pred, i, j - 1);
    }
}

lemma void gen_limits_allzero(nat nb_split, int i, int j)
    requires    j <= 0;
    ensures     true == forall(gen_limits(nb_split, i, j), (eq)(i));
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred): gen_limits_allzero(nb_split_pred, i, j - 1);
    }
}

lemma void gen_limits_get_val(nat nb_split, int i, int j, int k)
    requires    0 <= k &*& k < int_of_nat(nb_split);
    ensures     nth(k, gen_limits(nb_split, i, j)) == ( (k < j) ? (i + 1) : i );
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred): 
            if (k > 0) {
                gen_limits_get_val(nb_split_pred, i, j - 1, k - 1); 
            }
    }
}

lemma void gen_limits_increment_i(nat nb_split, int i)
    requires    true;
    ensures     gen_limits(nb_split, i + 1, 0) == gen_limits(nb_split, i, int_of_nat(nb_split));
{
    assume (gen_limits(nb_split, i, int_of_nat(nb_split)) == gen_limits(nb_split, i + 1, 0));
}

lemma void gen_limits_increment_j(nat nb_split, int i, int j)
    requires    0 <= j &*& j < int_of_nat(nb_split);
    ensures     gen_limits(nb_split, i, j + 1) == update(j, nth(j, gen_limits(nb_split, i, j + 1)), gen_limits(nb_split, i, j));
{
    assume (gen_limits(nb_split, i, j + 1) == update(j, nth(j, gen_limits(nb_split, i, j + 1)), gen_limits(nb_split, i, j)));
}

lemma void gen_limits_all_same(nat nb_split, int i)
    requires    true;
    ensures     true == forall(gen_limits(nb_split, i, 0), (eq)(i));
{
    assume (forall(gen_limits(nb_split, i, 0), (eq)(i)));
}

// ------------- split_varlim -------------

fixpoint list< list<t> > split_varlim<t>(list<t> xs, int n, list<int> limits) {
    switch(limits) {
        case nil: return nil;
        case cons(l0, ls0): return cons(take(l0, xs), split_varlim(drop(n, xs), n, ls0));
    }
}

lemma_auto(length(split_varlim(xs, n, limits))) void length_split_varlim<t>(list<t> xs, int n, list<int> limits)
    requires    length(xs) == length(limits) * n;
    ensures     length(split_varlim(xs, n, limits)) == length(limits);
{
    assume (length(split_varlim(xs, n, limits)) == length(limits));
}

lemma void split_varlim_nolim<t>(list<t> xs, int n, list<int> limits)
    requires    
        true == forall(limits, (eq)(0)) &*&
        0 <= n &*& n * length(limits) == length(xs);
    ensures
        true == forall(split_varlim(xs, n, limits), (eq)(nil));
{
    switch(limits) {
        case nil:
            assert (length(xs) == 0);
        case cons(l0, ls0):            
            mul_equal(n, length(limits), length(xs));
            length_drop(n, xs);
            assert (length(ls0) == length(limits) - 1); 
            mul_subst (length(ls0), length(limits) - 1, n);
            split_varlim_nolim(drop(n, xs), n, ls0);
    }
}

lemma void split_varlim_chunk_equiv<t>(list<t> xs, int n, list<int> limits, int j)
    requires    0 <= n &*& 0 <= j &*& j < length(limits) &*& n * (j+1) <= length(xs) ;
    ensures     nth(j, split_varlim(xs, n, limits)) == chunk(xs, n * j, n * j + nth(j, limits));
{
    switch(limits) {
        case nil:
        case cons(l0, ls0):
            if (j > 0) {
                split_varlim_chunk_equiv(drop(n, xs), n, ls0, j - 1);
                mul_nonnegative(n, j);
                mul_bounds(1, j, n, n);
                chunk_shift(xs, n * j, n * j + nth(j, limits), n);
            }
    }
}

lemma void split_varlim_update<t>(list<t> xs, int n, list<int> limits1, list<int> limits2, int i)
    requires    
        0 <= i &*& i < length(limits1) &*& 
        limits2 == update(i, nth(i, limits2), limits1) &*&
        nth(i, limits1) != nth(i, limits2);
    ensures     
        split_varlim(xs, n, limits2) == update(i, nth(i, split_varlim(xs, n, limits2)), split_varlim(xs, n, limits1));
{
    switch(limits1) {
        case nil:
        case cons(l0, ls0):
            if (i > 0) {
                split_varlim_update(drop(n, xs), n, ls0, tail(limits2), i - 1);
            }
    }
}

lemma void split_varlim_update_unrelevant<t>(list<t> xs1, list<t> xs2, list<int> limits, int n, int i, int j, t new_val)
    requires    
        xs2 == update(n * j + i, new_val, xs1) &*& nth(n * j + i, xs2) == new_val &*& nth(j, limits) <= i &*&
        true == forall(limits, (ge)(0)) &*& true == forall(limits, (le)(n)) &*&
        length(xs1) == n * length(limits) &*&
        0 <= i &*& i < n &*&
        0 <= j &*& j < length(limits);
    ensures     
        split_varlim(xs1, n, limits) == split_varlim(xs2, n, limits);
{
    switch(limits) {
        case nil:
        case cons(l0, ls0):
            if (j > 0) {
                mul_bounds(n, n, 1, j);
                mul_bounds(n, n, j + 1, length(limits));
                assert(n * j + i <= n * (j + 1) - 1);
                assert (n * (j+1) - 1 < length(xs1));
                assert (n * j + i < length(xs1));

                drop_update_relevant(n, n * j + i, new_val, xs1);
                nth_drop(n * j + i - n, n, xs2);
                length_drop(n, xs1);
                assert( length(ls0) == length(limits) - 1);
                mul_subst(length(ls0), length(limits) - 1, n);
                split_varlim_update_unrelevant(drop(n, xs1), drop(n, xs2), ls0, n, i, j - 1, new_val);
                
                take_update_unrelevant(l0, n * j + i, new_val, xs1);
            } else {
                take_update_unrelevant(l0, i, new_val, xs1);
                drop_update_unrelevant(n, i, new_val, xs1);
            }
    }
}

lemma void split_varlim_split_equiv<t>(list<t> xs, list<int> limits, int n, nat nb_split)
    requires    true == forall(limits, (eq)(n)) &*& length(limits) == int_of_nat(nb_split);
    ensures     split_varlim(xs, n, limits) == split(xs, nb_split, n);
{
    assume (split_varlim(xs, n, limits) == split(xs, nb_split, n));
}

// ------------- split -------------

fixpoint list< list<t> > split<t>(list<t> xs, nat nb_split, int n) {
    switch(nb_split) {
        case zero: return nil;
        case succ(nb_split_pred): 
            return cons(take(n, xs), split(drop(n, xs), nb_split_pred, n));
    }
}

lemma void split_to_source<t>(list<t> xs, nat nb_split, int n, int i, int j)
    requires    length(xs) == int_of_nat(nb_split) * n &*&
                0 <= i &*& i < n &*&
                0 <= j &*& j < int_of_nat(nb_split);
    ensures     nth(i, nth(j, split(xs, nb_split, n))) == nth(j * n + i, xs);
{
    // use chunk_to_source
    assume (nth(i, nth(j, split(xs, nb_split, n))) == nth(j * n + i, xs));
}

lemma_auto(length(split(xs, nb_split, n))) void length_split<t>(list<t> xs, nat nb_split, int n)
    requires    length(xs) == int_of_nat(nb_split) * n;
    ensures     length(split(xs, nb_split, n)) == int_of_nat(nb_split);
{
    assume (length(split(xs, nb_split, n)) == int_of_nat(nb_split));
}

lemma void length_split_nth<t>(list<t> xs, nat nb_split, int n, int i)
    requires    length(xs) == int_of_nat(nb_split) * n &*& 0 <= i &*& i < length(xs);
    ensures     length(nth(i, split(xs, nb_split, n))) == n;
{
    assume (length(nth(i, split(xs, nb_split, n))) == n);
}

lemma void length_split_forall<t>(list<t> xs, nat nb_split, int n)
    requires    length(xs) == int_of_nat(nb_split) * n &*& 0 <= n &*& n <= length(xs);
    ensures     true == forall(split(xs, nb_split, n), (length_eq)(n));
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred):
            if (nb_split_pred != zero) {
                length_drop(n, xs);
                mul_subst(int_of_nat(nb_split_pred) + 1, int_of_nat(nb_split), n);
                mul_equal(n, int_of_nat(nb_split_pred), length(xs) - n);
                length_split_forall(drop(n, xs), nb_split_pred, n);
            }
    }
}

lemma void split_chunk_equiv<t>(list<t> xs, nat nb_split, int n, int i)
    requires    0 < n &*& 0 <= i &*& i < int_of_nat(nb_split) &*& n * (i+1) <= length(xs);
    ensures     nth(i, split(xs, nb_split, n)) == chunk(xs, n * i, n * (i+1));
{
    switch(nb_split) {
        case zero:
        case succ(nb_split_pred):
            if (i > 0) {
                split_chunk_equiv(drop(n, xs), nb_split_pred, n, i-1);
                mul_nonnegative(n, i);
                mul_bounds(1, i, n, n);
                chunk_shift(xs, n * i, n * (i+1), n);
            }
    }
}

lemma void split_append<t>(list<t> xs, nat nb_split, nat nb_split_pred, int n)
    requires    nb_split == succ(nb_split_pred) &*& int_of_nat(nb_split) * n <= length(xs) &*& 0 < n;
    ensures     split(xs, nb_split, n) == append(split(xs, nb_split_pred, n), cons(chunk(xs, n * int_of_nat(nb_split_pred), n * int_of_nat(nb_split_pred) + n), nil));
{
    switch(nb_split_pred) {
        case zero:
            split_chunk_equiv(xs, nb_split, n, 0); 
        case succ(nb_split_pred_pred):
            mul_mono_strict(1, int_of_nat(nb_split), n);
            length_drop(n, xs);
            assert(int_of_nat(nb_split_pred) + 1 == int_of_nat(nb_split));
            mul_subst(int_of_nat(nb_split_pred) + 1, int_of_nat(nb_split), n);
            split_append(drop(n, xs), nb_split_pred, nb_split_pred_pred, n);

            assume (split(xs, nb_split, n) == append(split(xs, nb_split_pred, n), cons(chunk(xs, n * int_of_nat(nb_split_pred), n * int_of_nat(nb_split_pred) + n), nil)));
    }
}

lemma void split_update_unrelevant<t>(list<t> xs1, list<t> xs2, nat nb_split, int n, int i, t val)
    requires    true;
    ensures     split(xs1, nb_split, n) == split(xs2, nb_split, n);
{
    assume (split(xs1, nb_split, n) == split(xs2, nb_split, n));
}

// ------------- zip -------------

fixpoint list< pair<int, t> > zip_with_index_recursive<t>(list<t> xs, int index) {
    switch(xs) {
        case nil: return nil;
        case cons(x0, xs0): return cons( pair(index, x0), zip_with_index_recursive(xs0, index + 1) );
    }
}

fixpoint list< pair<int, t> > zip_with_index<t>(list<t> xs) {
    return zip_with_index_recursive(xs, 0);
}

fixpoint list< pair<t1, t2> > zip<t1, t2>(list<t1> xs, list<t2> ys) {
    switch(xs) {
        case nil: return nil;
        case cons(x0, xs0): return cons( pair(x0, head(ys)) , zip(xs0, tail(ys)) );
    }
}

// ------------- integers_list -------------

fixpoint list<int> integers_list(nat cnt, int index) {
    switch(cnt) {
        case zero: return nil;
        case succ(cnt_pred): return cons(index, integers_list(cnt_pred, index + 1));
    }
}

// ------------- lemmas -------------

lemma void ints_to_nth(list<int> xs, list<int> xs_orig, int i, int val)
    requires    xs == update(i, val, xs_orig);
    ensures     nth(i, xs) == val;
{
    assume (nth(i, xs) == val);
    // TODO
}

lemma void append_take<t>(list<t> xs, int i, fixpoint (t,bool) f)
    requires 
        0 <= i &*& i < length(xs) &*&
        true == forall(take(i, xs), f) &*& true == f(nth(i, xs));
    ensures 
        true == forall(take(i + 1, xs), f);
{
    assume (true == forall(take(i + 1, xs), f));
    // TODO
}

lemma void unzip<t>(list<t> xs)
    requires    true;
    ensures     xs == map(snd, zip_with_index(xs));
{
    assume (xs == map(snd, zip_with_index(xs)));
    // TODO
}

lemma void append_to_zip<t>(list<t> xs, t x) 
    requires true;
    ensures append(zip_with_index(xs), cons(pair(length(xs),x), nil)) == zip_with_index(append(xs, cons(x, nil)));
{
    assume (append(zip_with_index(xs), cons(pair(length(xs),x), nil)) == zip_with_index(append(xs, cons(x, nil))));
} 

lemma void zip_with_index_bounds<t>(list<t> xs) 
    requires true;
    ensures 
        true == forall( map(fst, zip_with_index(xs)), (lt)(length(xs)) ) &*&
        true == forall( map(fst, zip_with_index(xs)), (ge)(0) );
{
    assume ( true == forall( map(fst, zip_with_index(xs)), (lt)(length(xs)) ));
    assume ( true == forall( map(fst, zip_with_index(xs)), (ge)(0) ));
    //TODO
}

lemma void zip_no_dups_helper<t>(list<t> xs, int index)
    requires true;
    ensures xs == nil ? true : fst(head(zip_with_index_recursive(xs, index))) == index;
{
    switch(xs) {
        case nil: true;
        case cons(x0, xs0): assert(fst(head(zip_with_index_recursive(xs, index))) == index);
    }
}

lemma void zip_no_dups_rec<t>(list< pair<int, t> > xs_ziped, list<t> xs, int index)
    requires xs_ziped == zip_with_index_recursive(xs, index);
    ensures true == no_dups(map(fst, xs_ziped));
{
    assume (true == no_dups(map(fst, xs_ziped))); //TODO
}

lemma void zip_no_dups<t>(list<t> xs)
    requires true;
    ensures true == no_dups(map(fst, zip_with_index(xs)));
{
    list< pair<int, t> > xs_ziped = zip_with_index_recursive(xs, 0);
    zip_no_dups_rec(xs_ziped, xs, 0);
}

#endif //_LISTUTILS_GH_INCLUDED_
